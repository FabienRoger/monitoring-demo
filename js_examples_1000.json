[
  "function(query, option) {\n  var result = new RegExp(query, \"i\").exec(option.textContent);\n  if (result) {\n    return option.textContent.replace(result[0], \"<span class='selectr-match'>\" + result[0] + \"</span>\");\n  }\n  return false;\n}",
  "function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (_.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t}",
  "function constructCredentials(password, question, answer) {\n    var credentials = {};\n    if(password) credentials.password = constructPassword(password);\n    if(question && answer) credentials.recovery_question = constructRecoveryQuestion(question, answer);\n    return credentials;\n}",
  "function parseDb(data, cb) {\n              if (data && data.trim().length) {\n                log.debug(\"Parsing database\");\n                t.__db = jsonlint.parse(data);\n              } else {\n                log.debug(\"No database to parse\");\n                t.__db = {};\n              }\n              cb(null, t.__db);\n            }",
  "function attachLibraryToSelf () {\n            for(var i in libs)\n                if(libs.hasOwnProperty(i) && !self[i]) self[i] = libs[i];\n            return self;\n        }",
  "function emit(instance, name) {\n        var args = [].slice.call(arguments, 2);\n        if (events.indexOf(name) > -1) {\n          if (instance.handlers[name] && instance.handlers[name] instanceof Array) {\n            forEach(instance.handlers[name], function (handle) {\n              window.setTimeout(function () {\n                handle.callback.apply(handle.context, args);\n              }, 0);\n            });\n          }\n        } else {\n          throw new Error(name + ' event cannot be found on TreeView.');\n        }\n      }",
  "function ScrollAction(opt_callback, opt_distance_func) {\n    var self = this;\n\n    this.beginMeasuringHook = function() {}\n    this.endMeasuringHook = function() {}\n\n    this.callback_ = opt_callback;\n    this.distance_func_ = opt_distance_func;\n  }",
  "function makeHooksSafe(routes, store) {\n  if (Array.isArray(routes)) {\n    return routes.map(route => makeHooksSafe(route, store));\n  }\n\n  const onEnter = routes.onEnter;\n\n  if (onEnter) {\n    routes.onEnter = function safeOnEnter(...args) {\n      try {\n        store.getState();\n      } catch (err) {\n        if (onEnter.length === 3) {\n          args[2]();\n        }\n\n        // There's no store yet so ignore the hook\n        return;\n      }\n\n      onEnter.apply(null, args);\n    };\n  }\n\n  if (routes.childRoutes) {\n    makeHooksSafe(routes.childRoutes, store);\n  }\n\n  if (routes.indexRoute) {\n    makeHooksSafe(routes.indexRoute, store);\n  }\n\n  return routes;\n}",
  "function(id) {\n            var existing = doc.getElementById(id);\n            if (existing) {\n                existing.parentNode.removeChild(existing);\n            }\n        }",
  "function(target, dd, e, dragData) {\n        delete this.dropOK;\n        if (!target) {\n            return;\n        }\n\n//      Check that a field is being dragged.\n        var f = dragData.field;\n        if (!f) {\n            return;\n        }\n\n//      Check whether the data type of the column being dropped on accepts the\n//      dragged field type. If so, set dropOK flag, and highlight the target node.\n        var type = target.record.fields.get(target.fieldName).type,\n            types = Ext.data.Types;\n        switch(type){\n            case types.FLOAT:\n            case types.INT:\n                if (!f.isXType('numberfield')) {\n                    return;\n                }\n                break;\n            case types.DATE:\n                if (!f.isXType('datefield')) {\n                    return;\n                }\n                break;\n            case types.BOOL:\n                if (!f.isXType('checkbox')) {\n                    return;\n                }\n        }\n        this.dropOK = true;\n        Ext.fly(target.node).addCls('x-drop-target-active');\n    }",
  "function contentsToDisplay(req, res, scsId, scId = 0, cb) {\n  var zlSiteContentIn = app.models.zlSiteContentIn;\n  var Role = app.models.Role;\n  var compMod = require('./helpers/component-from-model')(app);\n\n  // emit that content was requested\n  if (res.locals.emiter.emit(`fetching content ${scsId}`, cb)) {\n    // if a package listen, it is responsible for callback\n    // also enable using scsId that is not in db to not cause error\n    return;\n  }\n\n  var { themeData } = res.locals;\n\n  // first, make sure they are allowed to view page\n  // get role permission for page\n  let filter = {fields: {scsPermission: true, zlSiteId: true}};\n  app.models.zlSiteContentSet.findById(scsId, filter, (err, scs) => {\n    if (err || !scs) return cb(`page does not exist`);\n    let ctx = app.locals.authCtx(req, res);\n    Role.isInRole(scs.scsPermission, ctx, (err, isInRole) => {\n      if (isInRole) {\n        // filter for model search\n        let filter = {\n          fields: {scId: true},\n          include: {\n            relation: 'zlSiteContent',\n            scope: {\n              where: {scStatus: 'publish', zlSiteId: res.locals.zlSite.zsId},\n            },\n          },\n          where: {scsId: scsId},\n        };\n        zlSiteContentIn.find(filter, (err, data) => {\n          // to keep list of promises\n          var promises = [];\n          // functions in component-from-model may need to make promises\n          compMod.promises = promises;\n\n          _.forEach(data, function(val, key) {\n            if (!val || !val.zlSiteContent) return data.splice(key, 1);\n            // converts from loopback object to json\n            val = val.toJSON().zlSiteContent;\n            if ('page content' === val.scType) {\n              // overide data to this value\n              data = val.scContent;\n              // iterate list of page content\n              if (_.isArray(data)) {\n                _.forEach(data, function(subVal, subKey) {\n                  // make sure there is a scId\n                  subVal.scId = (subVal.scId)?subVal.scId:`pg${scsId}-cont${subKey}`;\n\n                  prepContent(req, res, data, subVal, subKey, promises,\n                    compMod, scsId, cb);\n                });\n              }\n              // end here since only 1 active content list is used\n              return false;\n            } else {\n              // other type (like 'post' but not yet used anywhere)\n              data[key] = val.scContent;\n              prepContent(req, res, data, val.scContent, key, promises,\n                compMod, scsId, cb);\n            }\n          });\n          // emit that content loaded; allowing other sources to populate further\n          res.locals.emiter.emit(`loaded content ${scsId}`, data, promises);\n          // when all promise met, callback\n          Promise.all(promises).then(values => {\n            cb(null, data);\n          });\n        });\n      } else cb('Page Authorization failed');\n    });\n  });\n\n  compMod.themeData = themeData;\n}",
  "function sendPacket(socket, srcMAC, type, serverIP, yourIP) {\n  // Request info option\n  const opt55 = {\n    id: 55,\n    bytes: [\n      1, // subnet\n      3, // router\n      6, // dns\n    ],\n  };\n\n  let options;\n  if (serverIP && yourIP) {\n    const opt54 = {\n      id: 54,\n      bytes: [serverIP.a, serverIP.b, serverIP.c, serverIP.d],\n    };\n    const opt50 = {\n      id: 50,\n      bytes: [yourIP.a, yourIP.b, yourIP.c, yourIP.d],\n    };\n    options = [opt55, opt54, opt50];\n  } else {\n    options = [opt55];\n  }\n\n  const u8 = dhcpPacket.create(type, srcMAC, options);\n  socket.send(IP4Address.BROADCAST, 67, u8);\n}",
  "function endsWith(data, str) {\n    if (data.length < str.length) return false;\n    if (data === str) return true;\n    return data.lastIndexOf(str) === data.length - str.length;\n}",
  "function templatesFromStream(templateStream) {\n        var firstTemplate = null;\n        templateStream.on('data', function(file) {\n            var relpath = file.relative;\n            var deferred;\n            if (registry.hasOwnProperty(relpath)) {\n                deferred = registry[relpath];\n            } else {\n                deferred = registry[relpath] = new Deferred();\n            }\n            try {\n                if (!file.isBuffer()) {\n                    throw pluginError('Template source must be buffer');\n                }\n                var template = compile({\n                    data: file.contents.toString(),\n                    name: file.path,\n                    path: file.path\n                });\n                deferred.resolve(template);\n                if (firstTemplate === null) {\n                    firstTemplate = template;\n                } else {\n                    firstTemplate = false;\n                    theOnlyTemplate.reject(pluginError('Multiple templates given, must select one'));\n                }\n            } catch(err) {\n                deferred.reject(err);\n            }\n        }).on('end', function() {\n            if (firstTemplate)\n                theOnlyTemplate.resolve(firstTemplate);\n            else\n                theOnlyTemplate.reject(pluginError('No templates in template stream'));\n            noMoreTemplates();\n        }).on('error', function(err) {\n            templateStreamError = err;\n            noMoreTemplates();\n        });\n    }",
  "function ValidationErrors(errors) {\n  this.errors = errors ? errors : {};\n\n  this.addError = function(field, message) {\n    if (!this.errors[field]) { this.errors[field] = []; }\n    this.errors[field].push(util.format(message, field));\n  };\n\n  // omit field for full hash of errors\n  this.getErrors = function(field) {\n    if (field) {\n      return this.errors[field];\n    } else {\n      return this.errors;\n    }\n  };\n\n  this.hasErrors = function() {\n    return _.keys(this.errors).length > 0;\n  };\n\n  this.isValidationErrors = function() {\n    return true;\n  };\n}",
  "function fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\t\t\n\t\t_.each(colorStops, function(cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i)\n\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs))\n\t\t\t\tcs.position = 1;\n\t\t\t\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function(cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}",
  "function createTableGrid(node) {\n\t\t\t\tvar selection = ed.selection, tblElm = ed.dom.getParent(node || selection.getNode(), 'table');\n\n\t\t\t\tif (tblElm)\n\t\t\t\t\treturn new TableGrid(tblElm, ed.dom, selection);\n\t\t\t}",
  "function get(self, steamObj, key) {\n    steamObj = steamObj || {};\n    if (steamObj[key] !== undefined) {\n        return steamObj[key];\n    }\n    else if (self[key] !== undefined) {\n        return self[key];\n    }\n    else if (Steam[key] !== undefined) {\n        return Steam[key];\n    }\n    else {\n        throw new Error(\"Missing required field: \"+key);\n    }\n}",
  "function constructProfile(firstName, lastName, email, login, mobilePhone, customAttribs) {\n    var profile = {};\n    profile.login = (login ? login : email);\n    profile.email = email;\n    profile.firstName = firstName;\n    profile.lastName = lastName;\n    profile.mobilePhone = mobilePhone;\n    if(customAttribs != undefined) {\n        for(prop in customAttribs) {\n            profile[prop] = customAttribs[prop];\n        }\n    }\n    return profile;\n}",
  "function makeThresholdsSieve(options, defaults) {\n\n\tif (!options) options = {};\n\n\t// Pre-apply defaults.\n\tObject.keys(defaults).forEach(key => options[key] || (options[key] = defaults[key]));\n\n\treturn (key, overrides) => {\n\t\tif (overrides && overrides[key] !== void 0) return overrides[key];\n\t\treturn options[key];\n\t}\n}",
  "function zset(obj, vonly) {\n  var vtype = this.type(3)\n    , key = !vonly ? this.getStringBuffer(obj.key) : new Buffer(0)\n    , length = obj.length !== undefined\n        ? obj.length : Object.keys(obj.value).length\n    , len = this.getLengthEncoding(length, false)\n    , value = this.object(obj.value);\n  return Buffer.concat(\n    [\n      vtype,\n      key,\n      len,\n      value\n    ],\n    vtype.length + key.length + len.length + value.length\n  )\n}",
  "function showValidation(feedback) {\n  feedback.errors.forEach(function (error) {\n    console.log('ERROR: ' + error);\n  });\n  feedback.warnings.forEach(function (warning) {\n    console.log('WARNING: ' + warning);\n  });\n  console.log(\"Validator finished with \" + feedback.warnings.length + \" warnings and \" + feedback.errors.length + \" errors.\");\n  process.exit(feedback.errors.length > 0 ? 2 : 0);\n}",
  "function skipUntil(predicate) {\r\n    return function* (iterable) {\r\n        let i = 0;\r\n        let canReturn = false;\r\n        for (const item of iterable) {\r\n            if (!canReturn) {\r\n                canReturn = predicate(item, i);\r\n                if (canReturn) {\r\n                    yield item;\r\n                }\r\n                i = i + 1;\r\n            }\r\n            else {\r\n                yield item;\r\n            }\r\n        }\r\n    };\r\n}",
  "function findRecorder(div, selector) {\n  if (!div) {\n    if (!RecordingContext.recorders) {\n      throw 'You must call RecordingContext.recordAll() before using other RecordingContext static methods';\n    } else if (RecordingContext.recorders.length == 0) {\n      throw 'Called a RecordingContext method, but no canvases are being recorded.';\n    } else if (RecordingContext.recorders.length > 1) {\n      throw 'Called a RecordingContext method while multiple canvases were being recorded. Specify one using a div and selector.';\n    } else {\n      return RecordingContext.recorders[0][1];\n    }\n  } else {\n    return RecordingContext.recorderForSelector(div, selector);\n  }\n}",
  "function _prepopulate_metadata(_arg, _cb) {\n        var entry;\n        try {\n            entry = JSON.parse(_arg);\n        } catch (e) {\n            _cb();\n            return;\n        }\n\n        var nm = path.join(entry.parent, entry.name);\n\n        var k = sprintf(FILES_KEY_FMT, nm);\n\n        // if already in LRU cache, return\n        var stats = self.cache.get(k);\n        if (stats) {\n            _cb();\n            return;\n        }\n\n        self.db.get(k, function (err, val) {\n            // if already in db, return\n            if (!err) {\n                _cb();\n                return;\n            }\n\n            var fh = uuid.v4();\n            var info;\n            var cfile = path.join(self.location, 'fscache', fh);\n            if (entry.type !== 'directory') {\n                info = {\n                    name: entry.name,\n                    extension: 'bin',\n                    type: 'application/octet-stream',\n                    size: entry.size,\n                    headers: {\n                        'last-modified': entry.mtime\n                    },\n                    _fhandle: fh,\n                    _cacheFile: cfile,\n                    last_stat: now\n                };\n\n            } else {\n                info = {\n                    name: entry.name,\n                    extension: 'directory',\n                    type: 'application/x-json-stream; type=directory',\n                    headers: {\n                        'last-modified': entry.mtime,\n                        'result-set-size': 3\n                    },\n                    last_modified: entry.mtime,\n                    _fhandle: fh,\n                    _cacheFile: cfile,\n                    last_stat: now\n                };\n            }\n\n            var k1 = sprintf(FHANDLE_KEY_FMT, nm);\n            var k2 = sprintf(FNAME_KEY_FMT, fh);\n\n            self.db.batch()\n                .put(k, info)\n                .put(k1, fh)\n                .put(k2, nm)\n                .write(function (err2) {\n                    if (!err2)\n                        self.cache.set(k, info);\n                    _cb();\n                });\n        });\n    }",
  "function processPointerPosition(e) {\n    var xOffset = e.clientX,\n        yOffset = e.clientY;\n\n    var radius = this.rect.width / 2;\n    this.lastValue = this.value;\n\n    if (!this.usesRotation) {\n      if (this.lastPosition !== -1) {\n        //this.__value -= ( yOffset - this.lastPosition ) / (radius * 2);\n        this.__value = 1 - yOffset / this.rect.height;\n      }\n    } else {\n      var xdiff = radius - xOffset;\n      var ydiff = radius - yOffset;\n      var angle = Math.PI + Math.atan2(ydiff, xdiff);\n      this.__value = (angle + Math.PI * 1.5) % (Math.PI * 2) / (Math.PI * 2);\n\n      if (this.lastRotationValue > .8 && this.__value < .2) {\n        this.__value = 1;\n      } else if (this.lastRotationValue < .2 && this.__value > .8) {\n        this.__value = 0;\n      }\n    }\n\n    if (this.__value > 1) this.__value = 1;\n    if (this.__value < 0) this.__value = 0;\n\n    this.lastRotationValue = this.__value;\n    this.lastPosition = yOffset;\n\n    var shouldDraw = this.output();\n\n    if (shouldDraw) this.draw();\n  }",
  "function proxyDataGetter(ctx, prop) {\n    let proxyProps = ctx.__proxyProps;\n    proxyProps || (proxyProps = ctx.__proxyProps = {});\n    if (proxyProps[prop]) {\n        return;\n    }\n\n    proxyProps[prop] = true;\n\n    let descriptor = Object.getOwnPropertyDescriptor(ctx, prop);\n    if (descriptor && descriptor.configurable) {\n        let newDescriptor = Object.assign({}, descriptor, {\n            get() {\n                ctx.__deps && ctx.__deps.push(prop);\n                return descriptor.get && descriptor.get.call(ctx);\n            }\n        });\n        Object.defineProperty(ctx, prop, newDescriptor);\n    }\n    else {\n        console.warn('cannot configure the data prop descriptor info:', prop);\n    }\n}",
  "function readUint64(buffer, offset) {\n  var hi = (buffer[offset] << 24 |\n            buffer[offset + 1] << 16 |\n            buffer[offset + 2] << 8 |\n            buffer[offset + 3] << 0) >>> 0;\n  var lo = (buffer[offset + 4] << 24 |\n            buffer[offset + 5] << 16 |\n            buffer[offset + 6] << 8 |\n            buffer[offset + 7] << 0) >>> 0;\n  return hi * 0x100000000 + lo;\n}",
  "function(type, content, textAfter, state) {\n                  if (this.jsonMode) {\n                    return /^[\\[,{]$/.test(content) || /^}/.test(textAfter);\n                  } else {\n                    if (content == \";\" && state.lexical && state.lexical.type == \")\") return false;\n                    return /^[;{}]$/.test(content) && !/^;/.test(textAfter);\n                  }\n                }",
  "function publish(bundleId, pathsNotFound) {\n\t      // exit if id isn't defined\n\t      if (!bundleId) return;\n\t      var q = bundleCallbackQueue[bundleId]; // cache result\n\n\t      bundleResultCache[bundleId] = pathsNotFound; // exit if queue is empty\n\n\t      if (!q) return; // empty callback queue\n\n\t      while (q.length) {\n\t        q[0](bundleId, pathsNotFound);\n\t        q.splice(0, 1);\n\t      }\n\t    }",
  "function TextfontCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length > 2) {\n        this.family = parsed.args[0];\n        this.style = parsed.args[1];\n        this.size = parsed.args[2];\n    } else if (parsed.args.length > 1) {\n        this.familyOrStyle = parsed.args[0];\n        this.size = parsed.args[1];\n    } else if (parsed.args.length > 0) {\n        var arg = parsed.args[0];\n        if (arg.child.type === 'string' || arg.child instanceof statements.StringStatement) this.familyOrStyle = arg;\n        else this.size = arg;\n    } else {\n        this.reset = true;\n    }\n}",
  "function(columns) {\n        var i,\n            len = columns.length,\n            column;\n\n        for (i = 0; i < len; i++) {\n            column = columns[i];\n            if (!column.processed && column.locked) {\n                return true;\n            }\n        }\n    }",
  "function makePath(dirPath) {\n    dirPath = path.dirname(dirPath).split(path.sep)\n    dirPath.reduce(function(dirPath, p) {\n        dirPath = path.join(dirPath, p)\n        if (! fs.existsSync(dirPath)) {\n            try {\n                fs.mkdirSync(dirPath)\n            } catch (e) {\n                throw 'Could not make path ' + dirPath\n            }\n        }\n        return dirPath\n    }, '')\n}",
  "function TransformStreamCloseReadable(transformStream) {\n  // console.log('TransformStreamCloseReadable()');\n\n  if (transformStream._errored === true) {\n    throw new TypeError('TransformStream is already errored');\n  }\n\n  if (transformStream._readableClosed === true) {\n    throw new TypeError('Readable side is already closed');\n  }\n\n  TransformStreamCloseReadableInternal(transformStream);\n}",
  "function recordOrderInCriteo( cart, orderId ) {\n\tif ( ! isAdTrackingAllowed() || ! isCriteoEnabled ) {\n\t\treturn;\n\t}\n\n\tconst params = [\n\t\t'trackTransaction',\n\t\t{\n\t\t\tid: orderId,\n\t\t\tcurrency: cart.currency,\n\t\t\titem: cartToCriteoItems( cart ),\n\t\t},\n\t];\n\tdebug( 'recordOrderInCriteo:', params );\n\trecordInCriteo( ...params );\n}",
  "function(str, delim) {\n      var res = []; \n      var segs = str.split(delim);\n      var accum = '';\n      for (let i = 0; i < segs.length; i++) {\n        var seg = segs[i];\n        if (seg.endsWith('\\\\')) {\n          accum += seg.substring(0, seg.length - 1) + delim;\n        }\n        else {\n          accum += seg;\n          res.push(accum);\n          accum = '';\n        }\n      }\n      return res;\n    }",
  "function (event) {\n    var target = event.target;\n    if ((target !== absoluteAnchor) && !util.isChildOf(target, absoluteAnchor)) {\n      destroy();\n    }\n  }",
  "function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}",
  "function isObject(obj) {\n  // incase of arrow function and array\n  return Object(obj) === obj && String(obj) === '[object Object]' && !isFunction(obj) && !isArray(obj);\n}",
  "function getTextContent(node) {\n  if (isCommentNode(node)) {\n    return node.data || '';\n  }\n  if (isTextNode(node)) {\n    return node.value || '';\n  }\n  var subtree = nodeWalkAll(node, isTextNode);\n  return subtree.map(getTextContent).join('');\n}",
  "function nextchild(compare, a, i, j) {\n\n  if (j - i < 2) return i;\n\n  if (compare(a[i], a[i + 1]) <= 0) return i;\n\n  return i + 1;\n}",
  "function _getRoundedValue3D(prop, def, precision, lockValue) {\n        if (!prop || !prop.init) {\n            return def;\n        }\n        return [\n            prop.enabled[0] ? (Math.round((prop.curState.x + ((prop.endState.x - prop.curState.x) * lockValue)) / precision) * precision) : prop.endState.x,\n            prop.enabled[1] ? (Math.round((prop.curState.y + ((prop.endState.y - prop.curState.y) * lockValue)) / precision) * precision) : prop.endState.y,\n            prop.enabled[2] ? (Math.round((prop.curState.z + ((prop.endState.z - prop.curState.z) * lockValue)) / precision) * precision) : prop.endState.z\n        ];\n    }",
  "function writeBuffer(buffer) {\n  var written = fs.writeSync(this.fd, buffer, 0, buffer.length, null);\n  fs.fsyncSync(this.fd);\n  return written;\n}",
  "function(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\t\t\t\n\t\t\trequire('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}",
  "function changeData(state, sourceName, data) {\n  const source = state.sources[sourceName];\n  if (!source) {\n    return state;\n  }\n  const src_mixin = {};\n\n  // update the individual source.\n  src_mixin[sourceName] = Object.assign({}, source, {\n    data,\n  });\n\n  // kick back the new state.\n  return Object.assign({}, state, {\n    sources: Object.assign({}, state.sources, src_mixin),\n  }, incrementVersion(state.metadata, dataVersionKey(sourceName)));\n}",
  "function (data, arr, options) {\n  return arr.map(function(lookup) {\n    return expander.process(data, lookup, options);\n  });\n}",
  "function CreateSetPolyfill() {\n            return /** @class */ (function () {\n                function Set() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set.prototype, \"size\", {\n                    get: function () { return this._map.size; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set.prototype.has = function (value) { return this._map.has(value); };\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\n                Set.prototype.clear = function () { this._map.clear(); };\n                Set.prototype.keys = function () { return this._map.keys(); };\n                Set.prototype.values = function () { return this._map.values(); };\n                Set.prototype.entries = function () { return this._map.entries(); };\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n                return Set;\n            }());\n        }",
  "function(ev) {\n        this.cliView.cli.update({\n            typed: this.request.typed,\n            cursor: { start:0, end:0 }\n        });\n        this.cliView.cli.exec();\n    }",
  "function(key) {\n        var me = this,\n            value;\n\n        if (me.containsKey(key)) {\n            value = me.map[key];\n            delete me.map[key];\n            --me.length;\n            if (me.hasListeners.remove) {\n                me.fireEvent('remove', me, key, value);\n            }\n            return true;\n        }\n        return false;\n    }",
  "function pos(el) {\n    var o = { x:el.offsetLeft, y:el.offsetTop }\n    while((el = el.offsetParent))\n      o.x+=el.offsetLeft, o.y+=el.offsetTop\n\n    return o\n  }",
  "function(data) {\n    if (this.app) {\n      data._app = this.app;\n    }\n    if (this.model) {\n      data._model = this.model;\n    }\n    if (this.collection) {\n      data._collection = this.collection;\n    }\n    data._view = this;\n    return data;\n  }",
  "function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t}",
  "function processInitialData(value, name) {\n            if (name == View.prototype.modelName) {\n                options.model = def.models[name].unique(value);\n            } else if (def.models[name]) {\n                    options.data[name] = def.models[name].unique(value);\n            } else {\n                    options.data[name] = value;\n            }\n        }",
  "function parseImports(data, file, extensions) {\n\n\tconst imports = [];\n\n\tlet result = importRegExp.exec(data);\n\tlet encoding;\n\n\twhile(result !== null) {\n\n\t\tencoding = extensions[path.extname(result[2])];\n\n\t\t// Filter irrelevant imports.\n\t\tif(encoding !== undefined) {\n\n\t\t\timports.push(new FileImport(\n\t\t\t\tresult.index,\n\t\t\t\timportRegExp.lastIndex,\n\t\t\t\tresult[1],\n\t\t\t\tpath.resolve(path.dirname(file), result[2]),\n\t\t\t\tencoding\n\t\t\t));\n\n\t\t}\n\n\t\tresult = importRegExp.exec(data);\n\n\t}\n\n\treturn Promise.resolve([imports, data]);\n\n}",
  "function rename(obj) {\n  return rename_(function(parsedPath) {\n    return {\n      extname: obj.extname || parsedPath.extname,\n      dirname: (obj.dirnamePrefix || '') + parsedPath.dirname,\n      basename: parsedPath.basename\n    };\n  });\n}",
  "function _endTransferableAnimations(item) {\n        for (var j = 0; j < item.transferables.length; j++) {\n            var transferable = item.transferables[j];\n            for (var i = 0; i < this._renderables.transferables.length; i++) {\n                if (this._renderables.transferables[i] === transferable.renderNode) {\n                    this._renderables.transferables.splice(i, 1);\n                    break;\n                }\n            }\n            transferable.source.show(transferable.originalSource);\n            transferable.target.show(transferable.originalTarget);\n        }\n        item.transferables = [];\n        this.layout.reflowLayout();\n    }",
  "function(fireEvent) {\n        var me = this;\n        if (fireEvent && !me.bulkChange) {\n            me.fireEvent('selectionchange', me, me.getSelection());\n        }\n    }",
  "function (rootPath) {\n\t// public properties\n\tthis.plugins = {};\n\tthis.mainTree = {};\n\tthis.groups = {};\n\tthis.resolved = false;\n\tif (rootPath) {\n\t\tif (typeof rootPath !== 'string') {\n\t\t\tthrow new Error( 'Invalid rootPath parameter creating tree' );\n\t\t}\n\t\tthis.rootPath = rootPath;\n\t} else {\n\t\t// no argument passed\n\t\tthis.rootPath = '.';\n\t}\n}",
  "function(e) {\n\t\t\te.data.handler.over = true;\n\t\t\t$.iframeTracker.retrieveFocus();\n\t\t\ttry {\n\t\t\t\te.data.handler.overCallback(this, e);\n\t\t\t} catch (ex) {}\n\t\t}",
  "function handleError(req, res, err) {\n    switch (err.name) {\n      case 'NotFoundError':\n        render(req, res, 'error', err, {status: 404});\n        break;\n      default:\n        render(req, res, 'error', err, {status: 500});\n    }\n  }",
  "function patchFileObjects( formData ) {\n\t// There are several landmines to avoid when making file uploads work on all browsers:\n\t// - the `new File()` constructor trick breaks file uploads on Safari 10 in a way that's\n\t//   impossible to detect: it will send empty files in the multipart/form-data body.\n\t//   Therefore we need to detect Chrome.\n\t// - IE11 and Edge don't support the `new File()` constructor at all. It will throw exception,\n\t//   so it's detectable by the `supportsFileConstructor` code.\n\t// - `window.chrome` exists also on Edge (!), `window.chrome.webstore` is only in Chrome and\n\t//   not in other Chromium based browsers (which have the site isolation bug, too).\n\tif ( ! window.chrome || ! supportsFileConstructor ) {\n\t\treturn;\n\t}\n\n\tfor ( let i = 0; i < formData.length; i++ ) {\n\t\tconst val = getFileValue( formData[ i ][ 1 ] );\n\t\tif ( val ) {\n\t\t\tformData[ i ][ 1 ] = new File( [ val ], val.name, { type: val.type } );\n\t\t}\n\t}\n}",
  "function filterFunctionWordsAnywhere( wordCombinations, functionWords ) {\n\treturn wordCombinations.filter( function( combination ) {\n\t\treturn isEmpty(\n\t\t\tintersection( functionWords, combination.getWords() )\n\t\t);\n\t} );\n}",
  "function optOnIconMouseDownListener (e) { // outlineIcons.src.icon_opton  needed?\n    var target = thisOutline.targetOf(e)\n    var p = target.parentNode\n    termWidget.replaceIcon(p.parentNode,\n      outlineIcons.termWidgets.optOn,\n      outlineIcons.termWidgets.optOff, optOffIconMouseDownListener)\n    p.parentNode.parentNode.removeAttribute('optional')\n  }",
  "function forEach(declarations, reqName, callback) {\n        var d;\n        if (reqName === \"*\") {\n            // Iterate over all declarations.\n            for (d in declarations) {\n                callback.call(this, d);\n            }\n        } else if (reqName.charAt(reqName.length - 1) === \"*\") {\n            // Iterate over uncapped `*` declarations.\n            var baseName = reqName.substring(0, reqName.length - 1);\n            for (d in declarations) {\n                if (d.indexOf(baseName) === 0) {\n                    callback.call(this, d);\n                }\n            }\n        } else {\n            // A single dependency iteration.\n            if (declarations[reqName]) {\n                callback.call(this, reqName);\n            } else {\n                error(\"Invalid dependency '\" + reqName + \"'\");\n            }\n        }\n    }",
  "function _processAnimations(event) {\n        var prevItem;\n        for (var i = 0; i < this._viewStack.length; i++) {\n            var item = this._viewStack[i];\n            switch (item.state) {\n                case ItemState.HIDE:\n                    item.state = ItemState.HIDING;\n                    _initHideAnimation.call(this, item, prevItem, event.size);\n                    _updateState.call(this);\n                    break;\n                case ItemState.SHOW:\n                    item.state = ItemState.SHOWING;\n                    _initShowAnimation.call(this, item, prevItem, event.size);\n                    _updateState.call(this);\n                    break;\n            }\n            prevItem = item;\n        }\n    }",
  "function getLogicalPartitions(disk, index, offset, extendedPartitionOffset, limit) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (extendedPartitionOffset === undefined) {\n            extendedPartitionOffset = offset;\n        }\n        if (limit === undefined) {\n            limit = Infinity;\n        }\n        const result = [];\n        if (limit <= 0) {\n            return result;\n        }\n        const buf = yield readFromDisk(disk, offset, MBR_SIZE);\n        for (const p of getPartitionsFromMBRBuf(buf)) {\n            if (!p.extended) {\n                result.push(mbrPartitionDict(p, offset, index));\n            }\n            else if (limit > 0) {\n                const logicalPartitions = yield getLogicalPartitions(disk, index + 1, extendedPartitionOffset + p.byteOffset(), extendedPartitionOffset, limit - 1);\n                result.push(...logicalPartitions);\n                return result;\n            }\n        }\n        return result;\n    });\n}",
  "async function downloadLibtensorflow(callback) {\n  // Ensure dependencies staged directory is available:\n  await ensureDir(depsPath);\n\n  console.warn('* Downloading libtensorflow');\n  resources.downloadAndUnpackResource(\n      getPlatformLibtensorflowUri(), depsPath, async () => {\n        if (platform === 'win32') {\n          // Some windows libtensorflow zip files are missing structure and the\n          // eager headers. Check, restructure, and download resources as\n          // needed.\n          const depsIncludePath = path.join(depsPath, 'include');\n          if (!await exists(depsLibTensorFlowPath)) {\n            // Verify that tensorflow.dll exists\n            const libtensorflowDll = path.join(depsPath, 'tensorflow.dll');\n            if (!await exists(libtensorflowDll)) {\n              throw new Error('Could not find libtensorflow.dll');\n            }\n\n            await ensureDir(depsLibPath);\n            await rename(libtensorflowDll, depsLibTensorFlowPath);\n          }\n\n          // Next check the structure for the C-library headers. If they don't\n          // exist, download and unzip them.\n          if (!await exists(depsIncludePath)) {\n            // Remove duplicated assets from the original libtensorflow package.\n            // They will be replaced by the download below:\n            await unlink(path.join(depsPath, 'c_api.h'));\n            await unlink(path.join(depsPath, 'LICENSE'));\n\n            // Download the C headers only and unpack:\n            resources.downloadAndUnpackResource(\n                TF_WIN_HEADERS_URI, depsPath, () => {\n                  if (callback !== undefined) {\n                    callback();\n                  }\n                });\n          } else {\n            if (callback !== undefined) {\n              callback();\n            }\n          }\n        } else {\n          // No other work is required on other platforms.\n          if (callback !== undefined) {\n            callback();\n          }\n        }\n      });\n}",
  "function(options) {\n          var self = this\n          var result = []\n          if (options._id) {\n            var id = Array.isArray(options._id) ? options._id : [options._id]\n            id.forEach(function(id) {\n              if (self.cache[id]) {\n                result.push(self.cache[id])\n              }\n            })\n          } else {\n            result = Object.keys(this.cache).map(function(k) {\n              return self.cache[k]\n            }).sort(function(count1, count2) {\n              return count1._id - count2._id\n            })\n            if (options.skip || options.limit) {\n              var skip = options.skip || 0\n              var limit = options.limit || 0\n              return result.slice(skip, skip + limit)\n            }\n          }\n          return result\n        }",
  "function(key, value) {\n        // if we have no value, it means we need to get the key from the object\n        if (value === undefined) {\n            value = key;\n            key = this.getKey(value);\n        }\n\n        return [key, value];\n    }",
  "function updateLastSeenTime( proposedTime, fromStorage ) {\n\tlet fromNote = false;\n\tlet mostRecentNoteTime = 0;\n\n\t// Make sure we aren't getting milliseconds\n\t// The check time is Aug 8, 2005 in ms\n\tif ( proposedTime > 1123473600000 ) {\n\t\tproposedTime = proposedTime / 1000;\n\t}\n\n\tdebug( 'updateLastSeenTime 0', {\n\t\tproposedTime: proposedTime,\n\t\tfromStorage: fromStorage,\n\t\tlastSeenTime: this.lastSeenTime,\n\t} );\n\n\t// Event was triggered by another tab's localStorage.setItem; ignore localStorage and remote.\n\tif ( fromStorage ) {\n\t\tif ( proposedTime <= this.lastSeenTime ) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.lastSeenTime = proposedTime;\n\t\treturn true;\n\t}\n\n\tconst notes = getAllNotes( store.getState() );\n\tif ( notes.length ) {\n\t\tmostRecentNoteTime = Date.parse( notes[ 0 ].timestamp ) / 1000;\n\t}\n\n\tdebug( 'updateLastSeenTime 1', {\n\t\tproposedTime: proposedTime,\n\t\tshowing: this.showing,\n\t\tvisible: this.visible,\n\t\tlastSeenTime: this.lastSeenTime,\n\t\tmostRecentNoteTime: mostRecentNoteTime,\n\t} );\n\n\t// Advance proposedTime to the latest visible note time.\n\tif ( this.isShowing && this.isVisible && mostRecentNoteTime > proposedTime ) {\n\t\tproposedTime = mostRecentNoteTime;\n\t\tfromNote = true;\n\t}\n\n\tdebug( 'updateLastSeenTime 2', {\n\t\tproposedTime: proposedTime,\n\t\tfromNote: fromNote,\n\t\toldNews: proposedTime <= this.lastSeenTime,\n\t} );\n\n\t// Ignore old news.\n\tif ( proposedTime <= this.lastSeenTime ) {\n\t\treturn false;\n\t}\n\n\tthis.lastSeenTime = proposedTime;\n\n\ttry {\n\t\tlocalStorage.setItem( 'notesLastMarkedSeen', this.lastSeenTime );\n\t} catch ( e ) {}\n\n\t// Update the database only if an unseen note has become visible.\n\tif ( fromNote ) {\n\t\tdebug( 'updateLastSeenTime 3', this.lastSeenTime );\n\t\tsendLastSeenTime( this.lastSeenTime );\n\t}\n\n\treturn true;\n}",
  "function strip_ignored_bytes(octets) {\n        for (var o=octets.length-1; o>=0; o--) {\n            switch (octets[o]) {\n                case XON:\n                case XON_HIGH:\n                case XOFF:\n                case XOFF_HIGH:\n                    octets.splice(o, 1);\n                    continue;\n            }\n        }\n\n        return octets;\n    }",
  "function moduleCommand(shell, args, data, evaluationId) {\n  var deferred = shell.runtime.q.defer();\n\n  installer.install(args.name, shell.config.userPath, /* quiet */ false, function(error) {\n    if (error) {\n      deferred.reject(shell.createError('Could not install module'));\n    }\n    else {\n      shell.installedModules[args.name] = true;\n      deferred.resolve();\n    }\n  });\n\n  return deferred.promise;\n}",
  "function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    var filteredAST = cloneDeep(abstractSyntaxTree);\n    var astRules = abstractSyntaxTree.nodes[0];\n    var selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = mergeWith(\n        cloneDeep(allowedStyles[astRules.selector]),\n        allowedStyles['*'],\n        function(objValue, srcValue) {\n          if (Array.isArray(objValue)) {\n            return objValue.concat(srcValue);\n          }\n        }\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      filteredAST.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return filteredAST;\n  }",
  "function listRecusively (marker) {\n    options.marker = marker;\n\n    self.listObjectsPage(\n      options,\n      function (error, nextMarker, s3Objects) {\n        if (error) {\n          return callback(error);\n        }\n\n        // Send all of these S3 object definitions to be piped onwards.\n        s3Objects.forEach(function (object) {\n          object.Bucket = options.bucket;\n          self.push(object);\n        });\n\n        if (nextMarker) {\n          listRecusively(nextMarker);\n        }\n        else {\n          callback();\n        }\n      }\n    );\n  }",
  "function setFocus() {\n\t  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t  var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t  if (!is$1.element(element)) {\n\t    return;\n\t  } // Set regular focus\n\n\n\t  element.focus({\n\t    preventScroll: true\n\t  }); // If we want to mimic keyboard focus via tab\n\n\t  if (tabFocus) {\n\t    toggleClass(element, this.config.classNames.tabFocus);\n\t  }\n\t}",
  "function sortCombinations( wordCombinations ) {\n\twordCombinations.sort( function( combinationA, combinationB ) {\n\t\tconst difference = combinationB.getRelevance() - combinationA.getRelevance();\n\t\t// The combination with the highest relevance comes first.\n\t\tif ( difference !== 0 ) {\n\t\t\treturn difference;\n\t\t}\n\t\t// In case of a tie on relevance, the longest combination comes first.\n\t\treturn combinationB.getLength() - combinationA.getLength();\n\t} );\n}",
  "function(store, columns) {\n        var me = this,\n            oldStore = me.store,\n            lockedGrid = me.lockedGrid,\n            normalGrid = me.normalGrid;\n\n        Ext.suspendLayouts();\n        if (columns) {\n            lockedGrid.headerCt.removeAll();\n            normalGrid.headerCt.removeAll();\n\n            columns = me.processColumns(columns);\n\n            // Flag to the locked column add listener to do nothing\n            me.ignoreAddLockedColumn = true;\n            lockedGrid.headerCt.add(columns.locked.items);\n            me.ignoreAddLockedColumn = false;\n            normalGrid.headerCt.add(columns.normal.items);\n\n            // Ensure locked grid is set up correctly with correct width and bottom border,\n            // and that both grids' visibility and scrollability status is correct\n            me.syncLockedWidth();\n        }\n\n        if (store && store !== oldStore) {\n            store = Ext.data.StoreManager.lookup(store);\n            me.store = store;\n            lockedGrid.bindStore(store);\n            normalGrid.bindStore(store);\n        } else {\n            lockedGrid.getView().refresh();\n            normalGrid.getView().refresh();\n        }\n        Ext.resumeLayouts(true);\n    }",
  "function setup_member(context, k) {\n\tvar handler;\n\tvar routes = context.routes;\n\tvar opts = context.opts;\n\tvar middleware = context.middleware;\n\tvar app = context.app;\n\tvar target = context.target;\n\tvar loop_counter = context.loop_counter;\n\tvar v = routes[k];\n\tvar v_is_function = is.func(v) ? true : false;\n\n\t// Special methods\n\tif(_special_methods.indexOf(k) >= 0) {\n\t\thandler = v_is_function ? v : FUNCTION(do_send).curry(opts, v);\n\t\tif(middleware.length === 0) {\n\t\t\tapp[_express_methods[k]](target, build_request(opts, handler) );\n\t\t} else if(k === 'USE') {\n\t\t\t//debug.log('target = ', target);\n\t\t\t//debug.log('k = ', k);\n\t\t\t//debug.log('_express_methods[', k,'] = ', _express_methods[k]);\n\n\t\t\tapp[_express_methods[k]](target, join_plugins( [fix_for_missing_req_route(target, 'use')].concat(middleware).concat([build_request(opts, handler)]) ) );\n\t\t} else {\n\t\t\tapp[_express_methods[k]](target, fix_for_missing_req_route(target, (''+k).toLowerCase() ), middleware, build_request(opts, handler));\n\t\t}\n\t\treturn;\n\t}\n\n\t// Functions\n\tif(process.env.DEBUG_NOR_EXPRESS) {\n\t\tdebug.log( /*(req.id ? '['+req.id+'] ' : '') + */ 'target = ', target);\n\t\tdebug.log( /*(req.id ? '['+req.id+'] ' : '') + */ 'k = ', k);\n\t}\n\n\tvar new_target = (target==='/') ? ('/' + k) : (target + '/' + k);\n\tvar new_route = ROUTES.parse(v);\n\tROUTES.setup(app, new_route, new_target, merge(opts, {'loop_counter': loop_counter+1}));\n}",
  "function executeMainProcessMethod(moduleName, methodChain, args) {\n  const theModule = electron[moduleName];\n  const path = methodChain.join('.');\n  return get(theModule, path).apply(theModule, args);\n}",
  "function(object, options) {\n          return this.collection.findOneAndReplace(\n            {_id: object._id}, object, {returnOriginal: false}).value\n        }",
  "function() {\n            var tip = this.tip;\n            if (!tip) {\n                tip = this.tip = Ext.create('Ext.tip.QuickTip', {\n                    ui: 'form-invalid'\n                });\n                tip.tagConfig = Ext.apply({}, {attribute: 'errorqtip'}, tip.tagConfig);\n            }\n        }",
  "function configureGlobals() {\n\t// Set up the global DirectlyRTM function, required for the RTM widget.\n\t// This snippet is pasted from Directly's setup code.\n\twindow.DirectlyRTM =\n\t\twindow.DirectlyRTM ||\n\t\tfunction() {\n\t\t\t( window.DirectlyRTM.cq = window.DirectlyRTM.cq || [] ).push( arguments );\n\t\t};\n\t// Since we can only configure once per pageload, this library only provides a\n\t// single global configuration.\n\twindow.DirectlyRTM( 'config', getDefaultOptions() );\n}",
  "function ArrayType(typeSpec) {\n    if (typeSpec instanceof Type) {\n        this.subtype = typeSpec;\n    }\n    else if (typeof typeSpec === 'string') {\n        this.subtype = types.getType(typeSpec);\n        if (this.subtype == null) {\n            throw new Error('Unknown array subtype: ' + typeSpec);\n        }\n    }\n    else {\n        throw new Error('Can\\' handle array subtype');\n    }\n}",
  "function addTimeToArrayFromToken(token, input, config) {\n        var a, datePartArray = config._a;\n\n        switch (token) {\n        // MONTH\n        case 'M' : // fall through to MM\n        case 'MM' :\n            datePartArray[1] = (input == null) ? 0 : ~~input - 1;\n            break;\n        case 'MMM' : // fall through to MMMM\n        case 'MMMM' :\n            a = getLangDefinition(config._l).monthsParse(input);\n            // if we didn't find a month name, mark the date as invalid.\n            if (a != null) {\n                datePartArray[1] = a;\n            } else {\n                config._isValid = false;\n            }\n            break;\n        // DAY OF MONTH\n        case 'D' : // fall through to DDDD\n        case 'DD' : // fall through to DDDD\n        case 'DDD' : // fall through to DDDD\n        case 'DDDD' :\n            if (input != null) {\n                datePartArray[2] = ~~input;\n            }\n            break;\n        // YEAR\n        case 'YY' :\n            datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2000);\n            break;\n        case 'YYYY' :\n        case 'YYYYY' :\n            datePartArray[0] = ~~input;\n            break;\n        // AM / PM\n        case 'a' : // fall through to A\n        case 'A' :\n            config._isPm = getLangDefinition(config._l).isPM(input);\n            break;\n        // 24 HOUR\n        case 'H' : // fall through to hh\n        case 'HH' : // fall through to hh\n        case 'h' : // fall through to hh\n        case 'hh' :\n            datePartArray[3] = ~~input;\n            break;\n        // MINUTE\n        case 'm' : // fall through to mm\n        case 'mm' :\n            datePartArray[4] = ~~input;\n            break;\n        // SECOND\n        case 's' : // fall through to ss\n        case 'ss' :\n            datePartArray[5] = ~~input;\n            break;\n        // MILLISECOND\n        case 'S' :\n        case 'SS' :\n        case 'SSS' :\n            datePartArray[6] = ~~ (('0.' + input) * 1000);\n            break;\n        // UNIX TIMESTAMP WITH MS\n        case 'X':\n            config._d = new Date(parseFloat(input) * 1000);\n            break;\n        // TIMEZONE\n        case 'Z' : // fall through to ZZ\n        case 'ZZ' :\n            config._useUTC = true;\n            config._tzm = timezoneMinutesFromString(input);\n            break;\n        }\n\n        // if the input is null, the date is not valid\n        if (input == null) {\n            config._isValid = false;\n        }\n    }",
  "function (success, fail, args) {\r\n\t\targs = JSON.parse(decodeURIComponent(args[\"input\"]));\r\n\t\tvibration.getInstance().vibration_request(args);\r\n\t\tsuccess();\r\n\t}",
  "function _getOuterSize(gridSize, sizeScreen) {\n  if ('lg' === sizeScreen) {\n    if (gridSize && gridSize.lg) {\n      return gridSize.lg;\n    }\n    else if (gridSize && gridSize.md) {\n      return gridSize.md;\n    }\n    else if (gridSize && gridSize.sm) {\n      return gridSize.sm;\n    }\n    else if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  else if ('md' === sizeScreen) {\n    if (gridSize && gridSize.md) {\n      return gridSize.md;\n    }\n    else if (gridSize && gridSize.sm) {\n      return gridSize.sm;\n    }\n    else if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  else if ('sm' === sizeScreen) {\n    if (gridSize && gridSize.sm) {\n      return gridSize.sm;\n    }\n    else if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  else if ('xs' === sizeScreen) {\n    if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  // default\n  return grid;\n}",
  "function codeConfig(config) {\n  const conf = Object.create(null);\n  for (const key in config.custom) {\n    conf[key] = config.custom[key];\n  }\n  for (const key of ['host', 'port', 'backendPort']) {\n    conf[key] = config[key];\n  }\n  return conf;\n}",
  "function () {\n    var apps = {};\n    var baseUrl = configHelpers.getServerUrl();\n    Object.keys(config.apps || {}).forEach(function(name){\n      apps[name] = {\n        name: config.apps[name].name,\n        displayName: config.apps[name].displayName,\n        version: config.apps[name].version,\n        url: baseUrl + '/apps/' + config.apps[name].name + '/'\n      };\n    });\n    return apps;\n  }",
  "function readLength() {\n    var byte = delta[deltaOffset++];\n    var length = byte & 0x7f;\n    var shift = 7;\n    while (byte & 0x80) {\n      byte = delta[deltaOffset++];\n      length |= (byte & 0x7f) << shift;\n      shift += 7;\n    }\n    return length;\n  }",
  "function preprocessCartForServer( {\n\tcoupon,\n\tis_coupon_applied,\n\tis_coupon_removed,\n\tcurrency,\n\ttemporary,\n\textra,\n\tproducts,\n\ttax,\n} ) {\n\tconst needsUrlCoupon = ! (\n\t\tcoupon ||\n\t\tis_coupon_applied ||\n\t\tis_coupon_removed ||\n\t\ttypeof document === 'undefined'\n\t);\n\tconst urlCoupon = needsUrlCoupon ? url.parse( document.URL, true ).query.coupon : '';\n\n\treturn Object.assign(\n\t\t{\n\t\t\tcoupon,\n\t\t\tis_coupon_applied,\n\t\t\tis_coupon_removed,\n\t\t\tcurrency,\n\t\t\ttax,\n\t\t\ttemporary,\n\t\t\textra,\n\t\t\tproducts: products.map(\n\t\t\t\t( { product_id, meta, free_trial, volume, extra: productExtra } ) => ( {\n\t\t\t\t\tproduct_id,\n\t\t\t\t\tmeta,\n\t\t\t\t\tfree_trial,\n\t\t\t\t\tvolume,\n\t\t\t\t\textra: productExtra,\n\t\t\t\t} )\n\t\t\t),\n\t\t},\n\t\tneedsUrlCoupon &&\n\t\t\turlCoupon && {\n\t\t\t\tcoupon: urlCoupon,\n\t\t\t\tis_coupon_applied: false,\n\t\t\t}\n\t);\n}",
  "function _getNextSiblingThatIsNotBlank(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling && _isBlankTextNode(nextSibling)) {\n      nextSibling = nextSibling.nextSibling;\n    }\n    return nextSibling;\n  }",
  "function sample(collection, n, guard) {\n      var length = collection ? collection.length : 0;\n      if (typeof length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[random(length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }",
  "function LineCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 4) throw new SyntaxError('LINE command requires 4 arguments');\n    this.x1 = parsed.args[0];\n    this.y1 = parsed.args[1];\n    this.x2 = parsed.args[2];\n    this.y2 = parsed.args[3];\n    this.width = parsed.args.length > 4 ? parsed.args[4] : false;\n}",
  "function _getClusterState() {\n        return k8s.list('app=teraslice', 'pods')\n            .then(k8sPods => k8sState.gen(k8sPods, clusterState, clusterNameLabel))\n            .catch((err) => {\n                // TODO: We might need to do more here.  I think it's OK to just\n                // log though.  This only gets used to show slicer info through\n                // the API.  We wouldn't want to disrupt the cluster master\n                // for rare failures to reach the k8s API.\n                logger.error(err, 'Error listing teraslice pods in k8s');\n            });\n    }",
  "function convertOfficialMap (attributes) {\n  let map = {}\n  for (let attribute in attributes) {\n    let key = officialAttributeMap[attribute]\n    map[key] = attributes[attribute]\n  }\n  return map\n}",
  "function nextVersions (options, nameVersionPairs, checkLatestOnly) {\n  check.verify.object(options, 'expected object with options')\n  check.verify.array(nameVersionPairs, 'expected array')\n  nameVersionPairs = cleanVersions(nameVersionPairs)\n\n  const verbose = verboseLog(options)\n  verbose('checking NPM registry')\n  var MAX_CHECK_TIMEOUT = options.checkVersionTimeout || 10000\n\n  var fetchPromises = nameVersionPairs.map(fetchVersions.bind(null, options))\n  var fetchAllPromise = q.all(fetchPromises)\n        .timeout(MAX_CHECK_TIMEOUT, 'timed out waiting for NPM after ' + MAX_CHECK_TIMEOUT + 'ms')\n\n  return fetchAllPromise.then(\n    _.partial(filterFetchedVersions, checkLatestOnly),\n    q.reject\n  )\n}",
  "function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tmemo = memo || [];\n\t\t\t\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-'))\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function(n) {\n\t\t\t\t\t\tif (data[n])\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\t\t\t\n\t\t\treturn matchedItem;\n\t\t}",
  "function parse_status_block(block) {\n    var match;\n\n    var parsed = {};\n    if ((match = block.match(/bssid=([A-Fa-f0-9:]{17})/))) {\n        parsed.bssid = match[1].toLowerCase();\n    }\n\n    if ((match = block.match(/freq=([0-9]+)/))) {\n        parsed.frequency = parseInt(match[1], 10);\n    }\n\n    if ((match = block.match(/mode=([^\\s]+)/))) {\n        parsed.mode = match[1];\n    }\n\n    if ((match = block.match(/key_mgmt=([^\\s]+)/))) {\n        parsed.key_mgmt = match[1].toLowerCase();\n    }\n\n    if ((match = block.match(/[^b]ssid=([^\\n]+)/))) {\n        parsed.ssid = match[1];\n    }\n\n    if ((match = block.match(/[^b]pairwise_cipher=([^\\n]+)/))) {\n        parsed.pairwise_cipher = match[1];\n    }\n\n    if ((match = block.match(/[^b]group_cipher=([^\\n]+)/))) {\n        parsed.group_cipher = match[1];\n    }\n\n    if ((match =  block.match(/p2p_device_address=([A-Fa-f0-9:]{17})/))) {\n        parsed.p2p_device_address = match[1];\n    }\n\n    if ((match = block.match(/wpa_state=([^\\s]+)/))) {\n        parsed.wpa_state = match[1];\n    }\n\n    if ((match = block.match(/ip_address=([^\\n]+)/))) {\n        parsed.ip = match[1];\n    }\n\n    if ((match = block.match(/[^_]address=([A-Fa-f0-9:]{17})/))) {\n        parsed.mac = match[1].toLowerCase();\n    }\n\n    if ((match = block.match(/uuid=([^\\n]+)/))) {\n        parsed.uuid = match[1];\n    }\n\n    if ((match = block.match(/[^s]id=([0-9]+)/))) {\n        parsed.id = parseInt(match[1], 10);\n    }\n\n    return parsed;\n}",
  "function removeAttribute(node, prop) {\n            if (node && node.el) {\n                node.el.removeAttribute(prop);\n            }\n        }",
  "function() {\n            var cid = this.containerId,\n                scroll = \"scroll.\" + cid,\n                resize = \"resize.\"+cid,\n                orient = \"orientationchange.\"+cid,\n                mask, maskCss;\n\n            this.container.addClass(\"select2-dropdown-open\").addClass(\"select2-container-active\");\n\n            this.clearDropdownAlignmentPreference();\n\n            if(this.dropdown[0] !== this.body().children().last()[0]) {\n                this.dropdown.detach().appendTo(this.body());\n            }\n\n            // create the dropdown mask if doesnt already exist\n            mask = $(\"#select2-drop-mask\");\n            if (mask.length == 0) {\n                mask = $(document.createElement(\"div\"));\n                mask.attr(\"id\",\"select2-drop-mask\").attr(\"class\",\"select2-drop-mask\");\n                mask.hide();\n                mask.appendTo(this.body());\n                mask.on(\"mousedown touchstart click\", function (e) {\n                    var dropdown = $(\"#select2-drop\"), self;\n                    if (dropdown.length > 0) {\n                        self=dropdown.data(\"select2\");\n                        if (self.opts.selectOnBlur) {\n                            self.selectHighlighted({noFocus: true});\n                        }\n                        self.close();\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                });\n            }\n\n            // ensure the mask is always right before the dropdown\n            if (this.dropdown.prev()[0] !== mask[0]) {\n                this.dropdown.before(mask);\n            }\n\n            // move the global id to the correct dropdown\n            $(\"#select2-drop\").removeAttr(\"id\");\n            this.dropdown.attr(\"id\", \"select2-drop\");\n\n            // show the elements\n            maskCss=_makeMaskCss();\n\n            mask.css(maskCss).show();\n\n            this.dropdown.show();\n            this.positionDropdown();\n\n            this.dropdown.addClass(\"select2-drop-active\");\n\n            // attach listeners to events that can change the position of the container and thus require\n            // the position of the dropdown to be updated as well so it does not come unglued from the container\n            var that = this;\n            this.container.parents().add(window).each(function () {\n                $(this).on(resize+\" \"+scroll+\" \"+orient, function (e) {\n                    var maskCss=_makeMaskCss();\n                    $(\"#select2-drop-mask\").css(maskCss);\n                    that.positionDropdown();\n                });\n            });\n\n            function _makeMaskCss() {\n                return {\n                    width  : Math.max(document.documentElement.scrollWidth,  $(window).width()),\n                    height : Math.max(document.documentElement.scrollHeight, $(window).height())\n                }\n            }\n        }",
  "function () {\n    const url = BASE_URL + '/drive/v2/about?fields=user';\n    // requesting user info(mainly for userAdress)\n    return this._request('GET', url, {}).then(function (resp){\n      try {\n        const info = JSON.parse(resp.responseText);\n        return Promise.resolve(info);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    });\n  }",
  "function evaluateConditions(template, variables) {\n  let source;\n  do {\n    source = template;\n    template = processSimpleConditions(template, variables);\n    template = processIfElseConditions(template, variables);\n  } while (source !== template);\n\n  return template;\n}",
  "function handleMouseDown(event) {\n        mouseDown = true;\n        lastMouseX = event.clientX;\n        lastMouseY = event.clientY;\n        startX = event.clientX;\n        startY = event.clientY;\n\n        //get coordinates within canvas (with the right orientation)\n        var r = viewer._canvas.getBoundingClientRect();\n        var viewX = startX - r.left;\n        var viewY = viewer._height - (startY - r.top);\n\n        //this is for picking\n        id = viewer._getID(viewX, viewY);\n\n        /**\n        * Occurs when mousedown event happens on underlying canvas.\n        *\n        * @event xViewer#mouseDown\n        * @type {object}\n        * @param {Number} id - product ID of the element or null if there wasn't any product under mouse\n        */\n        viewer._fire('mouseDown', {id: id});\n\n\n        //keep information about the mouse button\n        switch (event.button) {\n            case 0:\n                button = 'left';\n                break;\n\n            case 1:\n                button = 'middle';\n                break;\n\n            case 2:\n                button = 'right';\n                break;\n\n            default:\n                button = 'left';\n                break;\n        }\n\n        viewer._disableTextSelection();\n    }",
  "function StatsDataLocalList( options ) {\n\tif ( ! ( this instanceof StatsDataLocalList ) ) {\n\t\treturn new StatsDataLocalList( options );\n\t}\n\n\tif ( 'string' !== typeof options.localStoreKey ) {\n\t\tthrow new TypeError( 'a options.localStoreKey must be passed in' );\n\t}\n\n\tdebug( 'creating new local list' );\n\tthis.localStoreKey = options.localStoreKey;\n\tthis.limit = options.limit || 10;\n\treturn this;\n}",
  "function moveCursor(stream, dx, dy) {\n  if (stream === null || stream === undefined)\n    return;\n\n  if (dx < 0) {\n    stream.write(CSI`${-dx}D`);\n  } else if (dx > 0) {\n    stream.write(CSI`${dx}C`);\n  }\n\n  if (dy < 0) {\n    stream.write(CSI`${-dy}A`);\n  } else if (dy > 0) {\n    stream.write(CSI`${dy}B`);\n  }\n}",
  "function supportedLocalesOf(service, locales, options) {\n  if (IS_NULL(InternalRegExpMatch(GetServiceRE(), service))) {\n    throw MakeError(kWrongServiceType, service);\n  }\n\n  // Provide defaults if matcher was not specified.\n  if (IS_UNDEFINED(options)) {\n    options = {};\n  } else {\n    options = TO_OBJECT(options);\n  }\n\n  var matcher = options.localeMatcher;\n  if (!IS_UNDEFINED(matcher)) {\n    matcher = TO_STRING(matcher);\n    if (matcher !== 'lookup' && matcher !== 'best fit') {\n      throw MakeRangeError(kLocaleMatcher, matcher);\n    }\n  } else {\n    matcher = 'best fit';\n  }\n\n  var requestedLocales = initializeLocaleList(locales);\n\n  // Cache these, they don't ever change per service.\n  if (IS_UNDEFINED(AVAILABLE_LOCALES[service])) {\n    AVAILABLE_LOCALES[service] = getAvailableLocalesOf(service);\n  }\n\n  // Use either best fit or lookup algorithm to match locales.\n  if (matcher === 'best fit') {\n    return initializeLocaleList(bestFitSupportedLocalesOf(\n        requestedLocales, AVAILABLE_LOCALES[service]));\n  }\n\n  return initializeLocaleList(lookupSupportedLocalesOf(\n      requestedLocales, AVAILABLE_LOCALES[service]));\n}",
  "function defer(func) {\r\n    return new (class {\r\n        constructor(generator) {\r\n            this.generator = generator;\r\n        }\r\n        [Symbol.iterator]() {\r\n            return this.generator()[Symbol.iterator]();\r\n        }\r\n    })(func);\r\n}",
  "function LeipzigEvent(name, data) {\n    var leipzigEvent = undefined;\n\n    if (window.CustomEvent) {\n      leipzigEvent = new CustomEvent(name, {\n        detail: data,\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      // For Internet Explorer & PhantomJS\n      leipzigEvent = document.createEvent('CustomEvent');\n      leipzigEvent.initCustomEvent(name, true, true, data);\n    }\n\n    return leipzigEvent;\n  }",
  "function userHasAccess (item) {\n       if (typeof item.isSecure !== 'boolean' || item.isSecure === false) {\n           // page has no security settings or false, let user pass\n           return true;\n       } else {\n           // page is secured, check if user has access\n           var pageRoles = item.roles;\n           debug('pageRoles', item.title, pageRoles)\n\n           if (Array.isArray(pageRoles) && pageRoles.length === 0) {\n               // page is secured, but requires no specific role\n               if (req.session.user) {\n                   // user is authenticated, let pass\n                   return true;\n               } else {\n                   // user is not authenticated, reject\n                   return false\n               }\n           }\n\n           if (!req.session.user || !req.session.user.roleIds) {\n               // user session does not exist, skip\n               return false;\n           }\n\n           // make sure roleIds are strings (on first request they are objects)\n           var userRoles = [];\n           var sessionRoleIds = req.session.user.roleIds;\n           for (var r in sessionRoleIds) {\n               userRoles.push(sessionRoleIds[r].toString());\n           }\n\n           // compare required roles and user roles\n           for (var r in pageRoles) {\n               var pageRoleId = pageRoles[r].toString();\n               if (userRoles.indexOf(pageRoleId) !== -1) {\n                   // user has role, let pass\n                   return true;\n               }\n           }\n       }\n       // all pass rules failed, reject user\n       return false;\n   }",
  "function(datasetClientId, fields, callback) {\n      fields.id = datasetClientId;\n      return metrics.timeAsyncFunc(metrics.KEYS.MONGODB_OPERATION_TIME, doUpdateDatasetClient)(datasetClientId, fields, true, callback);\n    }",
  "function(property, callback) {\n\t\tif(typeof property !=  \"string\") {\n\t\t\tcallback = property;\n\t\t\tproperty = \"__all__\";\n\t\t}\n\t\t\n\t\tthis._subscribers[property] = this._subscribers[property] || [];\n\t\t\n\t\tif(this._subscribers[property].indexOf(callback) == -1) { \n\t\t\tthis._subscribers[property].push(callback);\n\t\t}\n\t}",
  "function addPlugin(useLevel, fn) {\n  let pluginFn = fn;\n  if (typeof fn === 'undefined' && typeof useLevel === 'function') {\n    pluginFn = useLevel;\n  }\n\n  if (typeof pluginFn !== 'function') {\n    throw new Error('Plugin must be a function!');\n  }\n\n  if (typeof useLevel === 'string') {\n    pluginFn = (id, level, stats, ...rest) => {\n      if (level === useLevel.toUpperCase()) {\n        return fn(id, level, stats, ...rest);\n      }\n      return [id, level, stats, ...rest];\n    };\n  }\n\n  pluginsRegistry.push(pluginFn);\n}",
  "function getStartingState (cb) {\n      // if we are just starting or if a chain re-org has happened\n      if (!headBlock || reorg) {\n        blockchain.getBlock(block.header.parentHash, function (err, parentBlock) {\n          parentState = parentBlock.header.stateRoot\n          // generate genesis state if we are at the genesis block\n          // we don't have the genesis state\n          if (!headBlock) {\n            return self.stateManager.generateCanonicalGenesis(cb)\n          } else {\n            cb(err)\n          }\n        })\n      } else {\n        parentState = headBlock.header.stateRoot\n        cb()\n      }\n    }",
  "function staticConfig (projectPath, app) {\n  if (!projectPath) throw new Error('project path is required for load static configs');\n\n  // return configs if already is loaded\n  if (app.staticConfigsIsLoad) return app.config;\n\n  // - load and merge project configs\n\n  let projectConfigFolder = app.projectConfigFolder;\n\n  let files = [];\n\n  try {\n    files = fs.readdirSync(projectConfigFolder);\n  } catch(e) {\n    if (e.code != 'ENOENT') console.error('Error on load project config folder: ', e);\n  }\n\n  let file;\n  for (let i = 0; i < files.length; i++) {\n    if (files[i] == 'local.js') continue; // skip locals.js to load after all\n    if (!files[i].endsWith('.js')) continue; // only accepts .js config files\n\n    file = path.resolve(projectConfigFolder, files[i]);\n    // skip dirs\n    if (fs.lstatSync(file).isDirectory()) continue;\n    _.merge(app.config, require(file));\n  }\n\n  let jsonConfiguration = staticConfig.readJsonConfiguration(projectConfigFolder);\n  let localConfigFile = staticConfig.readLocalConfigFile(projectConfigFolder);\n\n  // load project local config file\n  _.merge(app.config, jsonConfiguration, localConfigFile);\n\n  app.staticConfigsIsLoad = true;\n\n  return app.config;\n}",
  "function createDeviationFragments( syllableConfig ) {\n\tvar deviationFragments = [];\n\n\tvar deviations = syllableConfig.deviations;\n\n\tif ( ! isUndefined( deviations.words ) && ! isUndefined( deviations.words.fragments ) ) {\n\t\tdeviationFragments = flatMap( deviations.words.fragments, function( fragments, fragmentLocation ) {\n\t\t\treturn map( fragments, function( fragment ) {\n\t\t\t\tfragment.location = fragmentLocation;\n\n\t\t\t\treturn new DeviationFragment( fragment );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn deviationFragments;\n}",
  "function(name) {\n      delete this.__scope.unresolved[name];\n      var stub = name + \".\";\n      for (var id in this.__scope.unresolved) {\n        if (id.startsWith(stub)) {\n          delete this.__scope.unresolved[id];\n        } \n      }\n    }",
  "function (distroName, actions, callback) {\n    if (distros[distroName] !== undefined) {\n      var distro = distros[distroName];\n      logger.info('Installing plugins...');\n      async.eachSeries(distro.plugins, function addPlugin (pluginName, cb) {\n        actions.installPlugin(pluginName, cb);\n      }, function installApps (err) {\n        if (err) {\n          callback(err);\n        } else {\n          logger.info('Installing apps...');\n          async.eachSeries(distro.apps, function addApp (appName, cb) {\n            actions.installApp(appName, cb);\n          }, callback);\n        }\n      });\n    } else {\n      throw new Error('Unknown distro, can\\'t install it');\n    }\n  }",
  "function normalizeApiAttributes( attributes ) {\n\tattributes = clone( attributes );\n\tattributes = normalizeTermsForApi( attributes );\n\n\tif ( attributes.author ) {\n\t\tattributes.author = attributes.author.ID;\n\t}\n\n\treturn attributes;\n}",
  "function() {\n\t\t\tif (!this.children.length)\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = _.last(deepestChild.children);\n\t\t\t}\n\t\t\t\n\t\t\treturn deepestChild;\n\t\t}",
  "function round(number, step) {\n\t  if (step < 1) {\n\t    var places = getDecimalPlaces(step);\n\t    return parseFloat(number.toFixed(places));\n\t  }\n\n\t  return Math.round(number / step) * step;\n\t}",
  "function genParam(param) {\n    var res = {\n        name: param.name || '',\n        description: param.description || '',\n        optional: !!param.optional\n    };\n    if (param.type) {\n        res.types = param.type.names.slice(0);\n    }\n\n    if (param.defaultvalue) {\n        res['default'] = param.defaultvalue;\n    }\n    return res;\n}",
  "function _haltItemAtFrame(item, perc) {\n        item.mod.halt();\n        item.halted = true;\n        if (item.startSpec && (perc !== undefined)) {\n            if ((item.startSpec.opacity !== undefined) && (item.endSpec.opacity !== undefined)) {\n                item.mod.setOpacity(_interpolate(item.startSpec.opacity, item.endSpec.opacity, perc));\n            }\n            if (item.startSpec.transform && item.endSpec.transform) {\n                var transform = [];\n                for (var i = 0; i < item.startSpec.transform.length; i++) {\n                    transform.push(_interpolate(item.startSpec.transform[i], item.endSpec.transform[i], perc));\n                }\n                item.mod.setTransform(transform);\n            }\n        }\n    }",
  "function parseAsElement( node, _parsed ) {\n\t// Attempt to convert string element into DOM node. If invalid, this will\n\t// return a string, not window.Element\n\tconst element = createElementFromString( node );\n\tif ( element instanceof window.Element ) {\n\t\t// Recursing will trigger the DOM strategy\n\t\treturn _recurse( element, _parsed );\n\t}\n\n\treturn _parsed;\n}",
  "function initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag$2:\n      return cloneArrayBuffer(object);\n\n    case boolTag$2:\n    case dateTag$2:\n      return new Ctor(+object);\n\n    case dataViewTag$3:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag$1: case float64Tag$1:\n    case int8Tag$1: case int16Tag$1: case int32Tag$1:\n    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag$4:\n      return new Ctor;\n\n    case numberTag$2:\n    case stringTag$3:\n      return new Ctor(object);\n\n    case regexpTag$2:\n      return cloneRegExp(object);\n\n    case setTag$4:\n      return new Ctor;\n\n    case symbolTag$2:\n      return cloneSymbol(object);\n  }\n}",
  "function RSASetPrivate(N,E,D) {\n  if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert(\"Invalid RSA private key\");\n}",
  "function three(context, next) {\n  console.log('Hi from three', context);\n  setTimeout(function() {\n    context.three = 'Hello';\n    console.log('Hello from three', context);\n  }, 1000);\n}",
  "function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {\n        var newSelectorPath, lastSelector, newJoinedSelector;\n        // our new selector path\n        newSelectorPath = [];\n\n        // construct the joined selector - if & is the first thing this will be empty,\n        // if not newJoinedSelector will be the last set of elements in the selector\n        if (beginningPath.length > 0) {\n            newSelectorPath = utils.copyArray(beginningPath);\n            lastSelector = newSelectorPath.pop();\n            newJoinedSelector = originalSelector.createDerived(utils.copyArray(lastSelector.elements));\n        }\n        else {\n            newJoinedSelector = originalSelector.createDerived([]);\n        }\n\n        if (addPath.length > 0) {\n            // /deep/ is a CSS4 selector - (removed, so should deprecate)\n            // that is valid without anything in front of it\n            // so if the & does not have a combinator that is \"\" or \" \" then\n            // and there is a combinator on the parent, then grab that.\n            // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n            var combinator = replacedElement.combinator, parentEl = addPath[0].elements[0];\n            if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {\n                combinator = parentEl.combinator;\n            }\n            // join the elements so far with the first part of the parent\n            newJoinedSelector.elements.push(new Element(\n                combinator,\n                parentEl.value,\n                replacedElement.isVariable,\n                replacedElement._index,\n                replacedElement._fileInfo\n            ));\n            newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));\n        }\n\n        // now add the joined selector - but only if it is not empty\n        if (newJoinedSelector.elements.length !== 0) {\n            newSelectorPath.push(newJoinedSelector);\n        }\n\n        // put together the parent selectors after the join (e.g. the rest of the parent)\n        if (addPath.length > 1) {\n            var restOfPath = addPath.slice(1);\n            restOfPath = restOfPath.map(function (selector) {\n                return selector.createDerived(selector.elements, []);\n            });\n            newSelectorPath = newSelectorPath.concat(restOfPath);\n        }\n        return newSelectorPath;\n    }",
  "function KoaNunjucks(oCtx, sPath, oOpts) {\n\n    // Configure Nunjucks\n    this.enviornment = nunjucks.configure(sPath, oOpts);\n\n    // Save context\n    this._ctx = oCtx;\n}",
  "function RestClient(baseUrl) {\n\n    if (typeof baseUrl !== 'string') {\n        if (typeof document !== 'undefined') {\n            baseUrl = document.getElementById('baseUrlHolder').getAttribute('data') + '/api/';\n        } else {\n            baseUrl = '/api/';\n        }\n    }\n    this.organizations = new OrganizationsClient(baseUrl);\n    this.projects = new ProjectsClient(baseUrl);\n    this.user = new UserClient(baseUrl);\n    this.users = new UsersClient(baseUrl);\n\n    /**\n     * Gets the current user\n     * @return {Promise} //TODO: How to document the resolved value.\n     */\n    this.getStatus = () => {\n        return this.user.get(['status']);\n    };\n}",
  "function _isRepeatData(current) {\n\t    var last = this._lastData;\n\t    if (!last || current.message !== last.message || // defined for captureMessage\n\t    current.transaction !== last.transaction // defined for captureException/onerror\n\t    ) return false; // Stacktrace interface (i.e. from captureMessage)\n\n\t    if (current.stacktrace || last.stacktrace) {\n\t      return isSameStacktrace$1(current.stacktrace, last.stacktrace);\n\t    } else if (current.exception || last.exception) {\n\t      // Exception interface (i.e. from captureException/onerror)\n\t      return isSameException$1(current.exception, last.exception);\n\t    }\n\n\t    return true;\n\t  }",
  "function validSubAttrCriteria(c) {\r\n    return _.isObject(c) && (\r\n            !_.isUndefined(c.not) || !_.isUndefined(c.greaterThan) || !_.isUndefined(c.lessThan) ||\r\n            !_.isUndefined(c.greaterThanOrEqual) || !_.isUndefined(c.lessThanOrEqual) || !_.isUndefined(c['<']) ||\r\n            !_.isUndefined(c['<=']) || !_.isUndefined(c['!']) || !_.isUndefined(c['>']) || !_.isUndefined(c['>=']) ||\r\n            !_.isUndefined(c.startsWith) || !_.isUndefined(c.endsWith) || !_.isUndefined(c.contains) || !_.isUndefined(c.like));\r\n}",
  "function serializeState(){\n      var data = model.data,\n          scale = model.scale,\n          translate = model.translate;\n      model.state = {\n        nodes: data.nodes.map(function(node){\n          return {\n            type: node.type,\n            property: node.property,\n            fixed: node.fixed,\n\n            // Keep size of JSON small, so it fits in a URL.\n            x: Math.round(node.x),\n            y: Math.round(node.y)\n          };\n        }),\n        links: data.links.map(function(link){\n          // Replaced link object references with indices for serialization.\n          return {\n            source: link.source.index,\n            target: link.target.index\n          };\n        }),\n        scale: scale,\n        translate: translate\n      };\n    }",
  "function liftFeedbackLoop(loops, mappings) {\n    return function (outerState, scheduler) {\n        var embededLoops = loops.map(function (loop) {\n            return loop(outerState.pipe(map_1.map(mappings.mapState)), scheduler)\n                .pipe(map_1.map(mappings.mapEvent));\n        });\n        return rx.merge.apply(rx, embededLoops);\n    };\n}",
  "function (itemData) {\n\n\t\tvar newItems = this.items.concat(itemData),\n\t\t\t// Calculate aspect ratios for items only; exclude spacing\n\t\t\trowWidthWithoutSpacing = this.width - (newItems.length - 1) * this.spacing,\n\t\t\tnewAspectRatio = newItems.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0),\n\t\t\ttargetAspectRatio = rowWidthWithoutSpacing / this.targetRowHeight,\n\t\t\tpreviousRowWidthWithoutSpacing,\n\t\t\tpreviousAspectRatio,\n\t\t\tpreviousTargetAspectRatio;\n\n\t\t// Handle big full-width breakout photos if we're doing them\n\t\tif (this.isBreakoutRow) {\n\t\t\t// Only do it if there's no other items in this row\n\t\t\tif (this.items.length === 0) {\n\t\t\t\t// Only go full width if this photo is a square or landscape\n\t\t\t\tif (itemData.aspectRatio >= 1) {\n\t\t\t\t\t// Close out the row with a full width photo\n\t\t\t\t\tthis.items.push(itemData);\n\t\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / itemData.aspectRatio, 'justify');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newAspectRatio < this.minAspectRatio) {\n\n\t\t\t// New aspect ratio is too narrow / scaled row height is too tall.\n\t\t\t// Accept this item and leave row open for more items.\n\n\t\t\tthis.items.push(merge(itemData));\n\t\t\treturn true;\n\n\t\t} else if (newAspectRatio > this.maxAspectRatio) {\n\n\t\t\t// New aspect ratio is too wide / scaled row height will be too short.\n\t\t\t// Accept item if the resulting aspect ratio is closer to target than it would be without the item.\n\t\t\t// NOTE: Any row that falls into this block will require cropping/padding on individual items.\n\n\t\t\tif (this.items.length === 0) {\n\n\t\t\t\t// When there are no existing items, force acceptance of the new item and complete the layout.\n\t\t\t\t// This is the pano special case.\n\t\t\t\tthis.items.push(merge(itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// Calculate width/aspect ratio for row before adding new item\n\t\t\tpreviousRowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;\n\t\t\tpreviousAspectRatio = this.items.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0);\n\t\t\tpreviousTargetAspectRatio = previousRowWidthWithoutSpacing / this.targetRowHeight;\n\n\t\t\tif (Math.abs(newAspectRatio - targetAspectRatio) > Math.abs(previousAspectRatio - previousTargetAspectRatio)) {\n\n\t\t\t\t// Row with new item is us farther away from target than row without; complete layout and reject item.\n\t\t\t\tthis.completeLayout(previousRowWidthWithoutSpacing / previousAspectRatio, 'justify');\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Row with new item is us closer to target than row without;\n\t\t\t\t// accept the new item and complete the row layout.\n\t\t\t\tthis.items.push(merge(itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// New aspect ratio / scaled row height is within tolerance;\n\t\t\t// accept the new item and complete the row layout.\n\t\t\tthis.items.push(merge(itemData));\n\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\treturn true;\n\n\t\t}\n\n\t}",
  "function(options) {\n  if (typeof this === \"function\") {\n    return new this(options);\n  }\n  this.tokens = tokens;\n  this.lexer = new lexer(this);\n  this.ast = new AST();\n  this.parser = new parser(this.lexer, this.ast);\n  if (options && typeof options === \"object\") {\n    // disable php7 from lexer if already disabled from parser\n    if (options.parser && options.parser.php7 === false) {\n      if (!options.lexer) {\n        options.lexer = {};\n      }\n      options.lexer.php7 = false;\n    }\n    combine(options, this);\n  }\n}",
  "function getDisplayValue (item) {\n    return $q.when(getItemText(item) || item).then(function(itemText) {\n      if (itemText && !angular.isString(itemText)) {\n        $log.warn('md-autocomplete: Could not resolve display value to a string. ' +\n          'Please check the `md-item-text` attribute.');\n      }\n\n      return itemText;\n    });\n\n    /**\n     * Getter function to invoke user-defined expression (in the directive)\n     * to convert your object to a single string.\n     */\n    function getItemText (item) {\n      return (item && $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;\n    }\n  }",
  "function() {\n            var me = this,\n                offsetParent = me.dom.offsetParent,\n                style = me.getStyle(['left', 'top']),\n                x = style.left,\n                y = style.top;\n\n            if (!x || x === 'auto') {\n                x = 0;\n            } else if (me.pxRe.test(x)) {\n                x = parseFloat(x);\n            } else {\n                x = me.getX();\n                if (offsetParent) {\n                    x -= Element.getX(offsetParent);\n                }\n            }\n\n            if (!y || y === 'auto') {\n                y = 0;\n            } else if (me.pxRe.test(y)) {\n                y = parseFloat(y);\n            } else {\n                y = me.getY();\n                if (offsetParent) {\n                    y -= Element.getY(offsetParent);\n                }\n            }\n\n            return [x, y];\n        }",
  "function cons (b, value, next) {\n  var free = readValue(b, 0) || 8\n  updateValue(b, free, value); updateNext(b, free, next)\n  updateValue(b, 0, free+8) //update free pointer\n  return free\n}",
  "function(name, data) {\n      if (typeof data == 'undefined') { data = {}; }\n      if (!data.context) { data.context = this; }\n      return this.app.trigger(name, data);\n    }",
  "function share (network) {\n      this.openSharer(network, this.createSharingUrl(network));\n\n      this.$root.$emit('social_shares_open', network, this.url);\n      this.$emit('open', network, this.url);\n    }",
  "function removeCaretContainer(caretContainer) {\r\n\t\t\tvar child, currentCaretContainer, lastContainer;\r\n\r\n\t\t\tif (caretContainer) {\r\n\t\t\t\t\trng = selection.getRng(true);\r\n\t\t\t\t\trng.setStartBefore(caretContainer);\r\n\t\t\t\t\trng.setEndBefore(caretContainer);\r\n\r\n\t\t\t\t\tchild = findFirstTextNode(caretContainer);\r\n\t\t\t\t\tif (child && child.nodeValue.charAt(0) == invisibleChar) {\r\n\t\t\t\t\t\tchild = child.deleteData(0, 1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdom.remove(caretContainer, true);\r\n\r\n\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t} else {\r\n\t\t\t\tcurrentCaretContainer = getParentCaretContainer(selection.getStart());\r\n\t\t\t\twhile ((caretContainer = dom.get(caretContainerId)) && caretContainer !== lastContainer) {\r\n\t\t\t\t\tif (currentCaretContainer !== caretContainer) {\r\n\t\t\t\t\t\tchild = findFirstTextNode(caretContainer);\r\n\t\t\t\t\t\tif (child && child.nodeValue.charAt(0) == invisibleChar) {\r\n\t\t\t\t\t\t\tchild = child.deleteData(0, 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdom.remove(caretContainer, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlastContainer = caretContainer;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
  "function hasStatic(node) {\n    var args = node.arguments;\n    if (!args) {\n        return false;\n    }\n    return args.length >= 3 &&\n        args[1].type === \"ObjectExpression\" &&\n        args[2].type === \"ObjectExpression\";\n}",
  "function(){\n        var me = this,\n            last = me.getPageData().pageCount;\n\n        if (me.fireEvent('beforechange', me, last) !== false) {\n            me.store.loadPage(last);\n        }\n    }",
  "function MongodbQueue(name, metrics, lock, opts) {\n  if (!name) {\n    throw new Error('name is required to create a mongodb queue');\n  }\n  if (!opts || !opts.mongodb) {\n    throw new Error('mongodb is not specified to create mongodb queue');\n  }\n  this.queueName = name;\n  this.metrics = metrics;\n  this.lock = lock;\n  this.lockName = opts.lockName || ('lock:sync:' + this.queueName);\n  this.lockTimeout = opts.lockTimeout || 10000;\n  this.mongodb = opts.mongodb;\n  this.queueOptions = {\n    visibility: opts.visibility || 30,\n    ttl: opts.queueMessagesTTL || 24*60*60\n  };\n  this.queue;\n}",
  "function onmessage( e ) {\n\tdebug( 'onmessage' );\n\n\t// safeguard...\n\tif ( e.origin !== proxyOrigin ) {\n\t\tdebug( 'ignoring message... %o !== %o', e.origin, proxyOrigin );\n\t\treturn;\n\t}\n\n\tlet { data } = e;\n\tif ( ! data ) {\n\t\treturn debug( 'no `data`, bailing' );\n\t}\n\n\t// Once the iframe is loaded, we can start using it.\n\tif ( data === 'ready' ) {\n\t\tonload();\n\t\treturn;\n\t}\n\n\tif ( postStrings && 'string' === typeof data ) {\n\t\tdata = JSON.parse( data );\n\t}\n\n\t// check if we're receiving a \"progress\" event\n\tif ( data.upload || data.download ) {\n\t\treturn onprogress( data );\n\t}\n\n\tif ( ! data.length ) {\n\t\treturn debug( '`e.data` doesn\\'t appear to be an Array, bailing...' );\n\t}\n\n\t// first get the `xhr` instance that we're interested in\n\tconst id = data[ data.length - 1 ];\n\tif ( ! ( id in requests ) ) {\n\t\treturn debug( 'bailing, no matching request with callback: %o', id );\n\t}\n\n\tconst xhr = requests[ id ];\n\n\t// Build `error` and `body` object from the `data` object\n\tconst { params } = xhr;\n\tlet body, statusCode, headers;\n\n\t// apiNamespace (WP-API)\n\tconst { apiNamespace } = params;\n\n\tbody = data[ 0 ];\n\tstatusCode = data[ 1 ];\n\theaders = data[ 2 ];\n\n\tif ( statusCode === 207 ) {\n\t\t// 207 is a signal from rest-proxy. It means, \"this isn't the final\n\t\t// response to the query.\" The proxy supports WebSocket connections\n\t\t// by invoking the original success callback for each message received.\n\t} else {\n\t\t// this is the final response to this query\n\t\tdelete requests[ id ];\n\t}\n\n\tif ( ! params.metaAPI ) {\n\t\tdebug( 'got %o status code for URL: %o', statusCode, params.path );\n\t} else {\n\t\tstatusCode = body === 'metaAPIupdated' ? 200 : 500;\n\t}\n\n\t// add statusCode into headers object\n\tif ( typeof headers === 'object' ) {\n\t\theaders.status = statusCode;\n\t}\n\n\tif ( statusCode && 2 === Math.floor( statusCode / 100 ) ) {\n\t\t// 2xx status code, success\n\t\tresolve( xhr, body, headers );\n\t} else {\n\t\t// any other status code is a failure\n\t\tconst wpe = WPError( params, statusCode, body );\n\t\treject( xhr, wpe, headers );\n\t}\n}",
  "function(activeHd, toIdx) {\n        var me         = this,\n            normalGrid = me.normalGrid,\n            lockedGrid = me.lockedGrid,\n            normalHCt  = normalGrid.headerCt,\n            lockedHCt  = lockedGrid.headerCt,\n            refreshFlags,\n            ownerCt;\n\n        activeHd = activeHd || normalHCt.getMenu().activeHeader;\n        ownerCt = activeHd.ownerCt;\n\n        // if column was previously flexed, get/set current width\n        // and remove the flex\n        if (activeHd.flex) {\n            activeHd.width = activeHd.getWidth();\n            delete activeHd.flex;\n        }\n\n        Ext.suspendLayouts();\n        ownerCt.remove(activeHd, false);\n        activeHd.locked = true;\n\n        // Flag to the locked column add listener to do nothing\n        me.ignoreAddLockedColumn = true;\n        if (Ext.isDefined(toIdx)) {\n            lockedHCt.insert(toIdx, activeHd);\n        } else {\n            lockedHCt.add(activeHd);\n        }\n        me.ignoreAddLockedColumn = false;\n\n        refreshFlags = me.syncLockedWidth();\n        if (refreshFlags[0]) {\n            lockedGrid.getView().refresh();\n        }\n        if (refreshFlags[1]) {\n            normalGrid.getView().refresh();\n        }\n        Ext.resumeLayouts(true);\n\n        me.fireEvent('lockcolumn', me, activeHd);\n    }",
  "function titleCase (s) {\n                    var arr = [];\n                    libs.object.each(s.split(' '), function (t) { arr.push(libs.string.ucFirst(t)); });\n                    return arr.join(' ');\n                }",
  "function AssetLoader(manifest, loader) {\n  this.assets = loadAssets(manifest, loader, function(err) {\n    if (err) {\n      console.error(err);\n    }\n  });\n}",
  "function formatMoment(m, format) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return m.lang().longDateFormat(input) || input;\n        }\n\n        while (i-- && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n        }\n\n        if (!formatFunctions[format]) {\n            formatFunctions[format] = makeFormatFunction(format);\n        }\n\n        return formatFunctions[format](m);\n    }",
  "function grayTransform (entry, direction, x, dim) { // :: Int -> Int -> Int -> Int\n    return bitwise.rotateRight((x ^ entry), dim, 0, direction + 1)\n}",
  "async function streamToString(readableStream) {\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n    readableStream.on(\"data\", data => {\n      chunks.push(data.toString());\n    });\n    readableStream.on(\"end\", () => {\n      resolve(chunks.join(\"\"));\n    });\n    readableStream.on(\"error\", reject);\n  });\n}",
  "function settingsRequest( state = false, { type } ) {\n\tswitch ( type ) {\n\t\tcase WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST:\n\t\tcase WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE:\n\t\t\treturn WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST === type;\n\t}\n\n\treturn state;\n}",
  "function checkWikipedia(brands) {\n    Object.keys(brands).forEach(k => {\n        ['brand:wikipedia', 'operator:wikipedia'].forEach(t => {\n            let wp = brands[k].tags[t];\n            if (wp && !/^[a-z_]{2,}:[^_]*$/.test(wp)) {\n                _wrongFormat.push([k, wp, t]);\n            }\n        });\n    });\n}",
  "function replace(url) {\n    var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!this.disabled && url) {\n      if (this.isImg) {\n        this.element.src = url;\n      }\n\n      if (hasSameSize) {\n        this.url = url;\n        this.image.src = url;\n\n        if (this.ready) {\n          this.viewBoxImage.src = url;\n          forEach(this.previews, function (element) {\n            element.getElementsByTagName('img')[0].src = url;\n          });\n        }\n      } else {\n        if (this.isImg) {\n          this.replaced = true;\n        }\n\n        this.options.data = null;\n        this.uncreate();\n        this.load(url);\n      }\n    }\n\n    return this;\n  }",
  "function filter(fn, ctx) {\n  assert.equal(typeof fn, 'function')\n  return function(val) {\n    val = Array.isArray(val) ? val : [val]\n    return Promise.resolve(val.filter(fn, ctx))\n  }\n}",
  "function(key) {\n        var obj = this.loadVar(key);\n        if (!obj || typeof (obj) != 'object') {\n            exitProcess('the value of ' +key+' is a necessary object ,but get '+ obj, this.alarm);\n            return false;\n        }\n        return obj;\n    }",
  "function findLast(data, items, index) {\n    var currentIndex = -1, found = '';\n    for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        var location = data.lastIndexOf(item, index);\n        if (location > currentIndex) {\n            currentIndex = location;\n            found = item;\n        }\n    }\n    return {\n        index: currentIndex,\n        found: found\n    };\n}",
  "function LoaderCache(options) {\n  if (!(this instanceof LoaderCache)) {\n    return new LoaderCache(options);\n  }\n  this.options = options || {};\n  this.defaultType = this.options.defaultType || 'sync';\n  this.types = [];\n  this.decorate('resolve');\n  this.decorate('get');\n}",
  "function () {\n        var me = this,\n            cfg = {\n                app: me,\n                menu: []\n            },\n            launcher;\n\n        Ext.apply(cfg, me.startConfig);\n\n        Ext.each(me.modules, function (module) {\n            launcher = module.launcher;\n            if (launcher) {\n                launcher.handler = launcher.handler || Ext.bind(me.createWindow, me, [module]);\n                cfg.menu.push(module.launcher);\n            }\n        });\n\n        return cfg;\n    }",
  "function _getViewSequenceAtIndex(index, startViewSequence) {\n        if (this._viewSequence.getAtIndex) {\n            return this._viewSequence.getAtIndex(index, startViewSequence);\n        }\n        var viewSequence = startViewSequence || this._viewSequence;\n        var i = viewSequence ? viewSequence.getIndex() : index;\n        if (index > i) {\n            while (viewSequence) {\n                viewSequence = viewSequence.getNext();\n                if (!viewSequence) {\n                    return undefined;\n                }\n                i = viewSequence.getIndex();\n                if (i === index) {\n                    return viewSequence;\n                }\n                else if (index < i) {\n                    return undefined;\n                }\n            }\n        }\n        else if (index < i) {\n            while (viewSequence) {\n                viewSequence = viewSequence.getPrevious();\n                if (!viewSequence) {\n                    return undefined;\n                }\n                i = viewSequence.getIndex();\n                if (i === index) {\n                    return viewSequence;\n                }\n                else if (index > i) {\n                    return undefined;\n                }\n            }\n        }\n        return viewSequence;\n    }",
  "function remove(el) {\n            while (el._events.length > 0) {\n                el._events.shift().remove();\n            }\n\n            if (el.children) {\n                destroy(el.children);\n            }\n            if (el.elGroup !== undefined) {\n                el.elGroup.delete(el.el);\n            }\n\n            if (el.el !== undefined) {\n                if (el.el.remove) {\n                    el.el.remove();\n                } else if (el.el.parentNode) {\n                    el.el.parentNode.removeChild(el.el);\n                }\n                delete el.el;\n            }\n        }",
  "function hasTrailingCommaForFunction(node) {\n            const length = node.params.length\n\n            return (\n                length >= 1 &&\n                sourceCode.getTokenAfter(node.params[length - 1]).value === \",\"\n            )\n        }",
  "function(ua, uaLength) {\n    let temp = [];\n    for (let i = 0; i < uaLength; i += 4) {\n        let x = ua[i] * 0x1000000 + (ua[i + 1] || 0) * 0x10000 + (ua[i + 2] || 0) * 0x100 + (ua[i + 3] || 0);\n        temp.push((x > 0x7fffffff) ? x - 0x100000000 : x);\n    }\n    return CryptoJS.lib.WordArray.create(temp, uaLength);\n}",
  "function(h, skip_undo) {\r\n\t\t\tvar ed = this.editor, r = ed.selection.getRng();\r\n\r\n\t\t\t// First delete the contents seems to work better on WebKit when the selection spans multiple list items or multiple table cells.\r\n\t\t\tif (!ed.selection.isCollapsed() && r.startContainer != r.endContainer)\r\n\t\t\t\ted.getDoc().execCommand('Delete', false, null);\r\n\r\n\t\t\ted.execCommand('mceInsertContent', false, h, {skip_undo : skip_undo});\r\n\t\t}",
  "function getRange(text) {\n  const range = text.match(/\\d+/g).map(Number);\n\n  if (Number.isFinite(range[1]) && range[1] < range[0]) {\n    throw new SyntaxError(`Numbers out of order in ${text} quantifier`);\n  }\n\n  return range;\n}",
  "function getActiveExecution(exId) {\n        const str = terminalStatusList().map(state => ` _status:${state} `).join('OR');\n        const query = `ex_id: ${exId} NOT (${str.trim()})`;\n        return searchExecutionContexts(query, null, 1, '_created:desc')\n            .then((ex) => {\n                if (ex.length === 0) {\n                    const error = new Error(`no active execution context was found for ex_id: ${exId}`);\n                    error.code = 404;\n                    return Promise.reject(error);\n                }\n                return ex[0];\n            });\n    }",
  "function setAspectRatio(aspectRatio) {\n    var options = this.options;\n\n    if (!this.disabled && !isUndefined(aspectRatio)) {\n      // 0 -> NaN\n      options.aspectRatio = Math.max(0, aspectRatio) || NaN;\n\n      if (this.ready) {\n        this.initCropBox();\n\n        if (this.cropped) {\n          this.renderCropBox();\n        }\n      }\n    }\n\n    return this;\n  }",
  "function(path) {\n            var node = this.$getNode(path, false);\n            if (node !== null){\n                return _.keys(node.nodes);\n            } else {\n                return null;\n            }\n        }",
  "function doListUpdates(datasetId, criteria, options, callback) {\n  debug('[%s] doListUpdates criteria = %j',datasetId,criteria);\n  var updatesCollection = mongoClient.collection(getDatasetUpdatesCollectionName(datasetId));\n  var docLimit = options && options.limit;\n  var cursor = updatesCollection.find(criteria);\n  if (docLimit && docLimit > 0) {\n    cursor = cursor.limit(docLimit);\n  }\n  cursor.toArray(function(err, updates) {\n    if (err) {\n      debugError('[%s] Failed to doListUpdates due to error %s :: criteria = %j' + criteria,datasetId,err,criteria);\n      return callback(err);\n    }\n    return callback(null, updates);\n  });\n}",
  "function(datasetId, criteria, options, callback) {\n      return metrics.timeAsyncFunc(metrics.KEYS.MONGODB_OPERATION_TIME, doListUpdates)(datasetId, criteria, options, callback);\n    }",
  "function serializeSpan(span, serializers, index, options) {\n    if (span === '\\n' && serializers.hardBreak) {\n      return h(serializers.hardBreak, {key: `hb-${index}`})\n    }\n\n    if (typeof span === 'string') {\n      return serializers.text ? h(serializers.text, {key: `text-${index}`}, span) : span\n    }\n\n    let children\n    if (span.children) {\n      children = {\n        children: span.children.map((child, i) =>\n          options.serializeNode(child, i, span.children, true)\n        )\n      }\n    }\n\n    const serializedNode = objectAssign({}, span, children)\n\n    return h(serializers.span, {\n      key: span._key || `span-${index}`,\n      node: serializedNode,\n      serializers\n    })\n  }",
  "function consume_doctype_or_comment (proc_stack) {\n  let html = \"<!\";\n  proc_stack.tSkip(2);\n  html += proc_stack.tAcceptUntil(\">\") + proc_stack.tAccept();\n  return html;\n}",
  "function(url, params, options) {\n        var script = document.createElement('script');\n        script.setAttribute(\"src\", Ext.urlAppend(url, Ext.Object.toQueryString(params)));\n        script.setAttribute(\"async\", true);\n        script.setAttribute(\"type\", \"text/javascript\");\n        return script;\n    }",
  "function() {\n        var reply = [];\n        this.getSettingNames().forEach(function(setting) {\n            reply.push({\n                'key': setting,\n                'value': this.getSetting(setting).get()\n            });\n        }, this);\n        return reply;\n    }",
  "function spy(obj, method) {\n  if (!obj && !method) {\n    obj = { spy: function(){} };\n    method = 'spy';\n  }\n  return double(obj, method);\n}",
  "function(name, location) {\n      var t = this;\n      var requiredOpts = {\n        load: t.isLoadScope(),\n        defer: t.__inDefer,\n        construct: t.__classMeta && t.__classMeta.functionName == \"$$constructor\",\n        location: location\n      };\n      var dest = t.__environmentChecks.required[name];\n      if (!dest) {\n        dest = t.__environmentChecks.required[name] = {};\n      }\n      if (requiredOpts.load) {\n        dest.load = true;\n      }\n      if (requiredOpts.defer) {\n        dest.defer = true; \n      }\n      if (requiredOpts.construct) {\n        dest.construct = true;\n      }\n      t._requireClass(\"qx.core.Environment\", { location: location });\n      if (qx.tool.compiler.ClassFile.ENVIRONMENT_CONSTANTS[name] === undefined) {\n        var entry = qx.tool.compiler.ClassFile.ENVIRONMENT_CHECKS[name];\n        if (entry && entry.className) {\n          t._requireClass(entry.className, { load: requiredOpts.load, location: location });\n          dest.className = entry.className;\n        } else if (!entry) {\n          t._requireClass(name, { load: requiredOpts.load, location: location });\n        }\n      }\n    }",
  "function omit(originalObject, keys = []) {\n  // code based on babel's _objectWithoutProperties\n  const newObject = {};\n  for (const key in originalObject) {\n    if (keys.indexOf(key) >= 0) {\n      continue;\n    }\n    if (!Object.prototype.hasOwnProperty.call(originalObject, key)) {\n      continue;\n    }\n    newObject[key] = originalObject[key];\n  }\n  return newObject;\n}",
  "function loader(content) {\n    const { addDependency, resource, resourcePath } = this;\n\n    // Get callback because the SVG is going to be optimized and that is an async operation\n    const callback = this.async();\n\n    // Parse the loader query and apply the default values in case no values are provided\n    const { iconName, publicPath, sprite, svgoOptions } = Object.assign({}, DEFAULT_LOADER_OPTIONS, loaderUtils.getOptions(this));\n\n    // Add the icon as a dependency\n    addDependency(resourcePath);\n\n    // Start optimizing the SVG file\n    imagemin\n        .buffer(content, {\n            plugins: [\n                imageminSvgo(svgoOptions),\n            ],\n        })\n        .then((content) => {\n\n            // Create the icon name with the hash of the optimized content\n            const name = loaderUtils.interpolateName(this, iconName, { content });\n\n            // Register the icon using its resource path with query as id\n            // so that tools like: `svg-transform-loader` can be used in combination with this loader.\n            const icon = sprite.addIcon(resource, name, content.toString());\n\n            // Export the icon as a metadata object that contains urls to be used on an <img/> in HTML or url() in CSS\n            // If the outputted file is not hashed and to support hot module reload, we must force the browser\n            // to re-download the sprite on subsequent compilations\n            // We do this by adding a cache busting on the URL, with the following pattern: img/sprite.svg?icon-abcd#icon-abcd\n            // It's important that the cache busting is not included initially so that it plays well with server-side rendering,\n            // otherwise many view libraries will complain about mismatches during rehydration (such as React)\n            const hasSamePath = sprite.originalResourcePath === sprite.resourcePath;\n\n            setImmediate(() => {\n                callback(\n                    null,\n                    `var publicPath = ${publicPath ? `'${publicPath}'` : '__webpack_public_path__'};\n                    var symbolUrl = '${icon.getUrlToSymbol()}';\n                    var viewUrl = '${icon.getUrlToView()}';\n\n                    ${process.env.NODE_ENV !== 'production' && hasSamePath ? `\n                        var addCacheBust = typeof document !== 'undefined' && document.readyState === 'complete';\n    \n                        if (addCacheBust) {\n                            symbolUrl = '${icon.getUrlToSymbol(true)}';\n                            viewUrl = '${icon.getUrlToView(true)}';\n                        }\n                    ` : '' }\n\n                    module.exports = {\n                        symbol: publicPath + symbolUrl,\n                        view: publicPath + viewUrl,\n                        viewBox: '${icon.getDocument().getViewBox()}',\n                        title: '${icon.getDocument().getTitle()}',\n                        toString: function () {\n                            return JSON.stringify(this.view);\n                        }\n                    };`\n                );\n            });\n        })\n        .catch((err) => {\n            setImmediate(() => callback(err));\n        });\n}",
  "function(v, date1904) {\n      if (date1904) v += 1462;\n      var epoch = Date.parse(v);\n      var result = (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);\n      return Math.floor(result);\n    }",
  "function signManifest(template, manifest, callback) {\n  var identifier = template.passTypeIdentifier().replace(/^pass./, \"\");\n\n  var args = [\n    \"smime\",\n    \"-sign\", \"-binary\",\n    \"-signer\",    Path.resolve(template.keysPath, identifier + \".pem\"),\n    \"-certfile\",  Path.resolve(template.keysPath, \"wwdr.pem\"),\n    \"-passin\",    \"pass:\" + template.password\n  ];\n  var sign = execFile(\"openssl\", args, { stdio: \"pipe\" }, function(error, stdout, stderr) {\n    var trimmedStderr = stderr.trim();\n    // Windows outputs some unhelpful error messages, but still produces a valid signature\n    if (error || (trimmedStderr && trimmedStderr.indexOf('- done') < 0)) {\n      callback(new Error(stderr));\n    } else {\n      var signature = stdout.split(/(\\r\\n|\\n\\n)/)[3];\n      callback(null, Buffer.from(signature, \"base64\"));\n    }\n  });\n  sign.stdin.write(manifest);\n  sign.stdin.end();\n}",
  "function formatTime() {\n\t  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t  var displayHours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t  var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n\t  // Bail if the value isn't a number\n\t  if (!is$1.number(time)) {\n\t    return formatTime(null, displayHours, inverted);\n\t  } // Format time component to add leading zero\n\n\n\t  var format = function format(value) {\n\t    return \"0\".concat(value).slice(-2);\n\t  }; // Breakdown to hours, mins, secs\n\n\n\t  var hours = getHours(time);\n\t  var mins = getMinutes(time);\n\t  var secs = getSeconds(time); // Do we need to display hours?\n\n\t  if (displayHours || hours > 0) {\n\t    hours = \"\".concat(hours, \":\");\n\t  } else {\n\t    hours = '';\n\t  } // Render\n\n\n\t  return \"\".concat(inverted && time > 0 ? '-' : '').concat(hours).concat(format(mins), \":\").concat(format(secs));\n\t}",
  "function append(parent, child) {\n            if (parent.el !== undefined && child.el !== undefined) {\n                parent.el.appendChild(child.el);\n            }\n        }",
  "function retrieveSteamAPIMethods(key, callback) {\n\n    var _steam = new Steam();\n    _steam.getSupportedAPIList({key:key}, function(err, data) {\n\n        if (err) return callback(err);\n\n        var apiList = data.apilist;\n        if (apiList === undefined) return callback(new Error('No data returned'));\n\n        apiList = apiList.interfaces;\n\n        // List of interfaces\n        for (var i= 0; i<apiList.length; i++) {\n            var _interface = apiList[i];\n            var methods = _interface.methods;\n\n            // List of methods\n            for (var j= 0; j<methods.length; j++) {\n                var method = methods[j];\n                var optionalParams = [], requiredParams = [];\n                var params = method.parameters;\n\n                //List of parameters\n                for (var k=0; k<params.length; k++) {\n                    var param = params[k];\n\n                    if (param.optional) {\n                        optionalParams.push(param.name);\n                    } else {\n                        requiredParams.push(param.name);\n                    }\n                }\n\n                buildSteamWrapperMethod(_interface.name, method.name, method.version, method.httpmethod, requiredParams, optionalParams);\n            }\n        }\n        callback();\n\n    });\n}",
  "function(obj) {\n        var i = 0,\n            items = this.items,\n            len = this.length,\n            item, el;\n            \n        for (; i < len; i++) {\n            item = items[i];\n            el = item.el;\n            if (el) {\n                el.setStyle(obj);\n            }\n        }\n    }",
  "function setDownloadUrl() {\n\t    var button = this.elements.buttons.download; // Bail if no button\n\n\t    if (!is$1.element(button)) {\n\t      return;\n\t    } // Set attribute\n\n\n\t    button.setAttribute('href', this.download);\n\t  }",
  "function (parent, el) {\n        var id = el.id,\n            children = parent.children,\n            items = this.items;\n\n        if(children) {\n            Ext.Array.remove(children, items[id]);\n        }\n        delete items[id];\n    }",
  "function removePendingChanges(clientRecords, localDatasetClient, pendingChanges) {\n  _.each(pendingChanges, function(pendingChange, uid) {\n    if (clientRecords[uid]) {\n      delete clientRecords[uid];\n    }\n    if (localDatasetClient[uid]) {\n      delete localDatasetClient[uid];\n    }\n  });\n}",
  "function timeOutput(difference, timeValue, pluralTimeName) {\n    let result = '';\n    if (Math.round(difference / timeValue) === 1) {\n        result = `1 ${pluralTimeName.substring(0, pluralTimeName.length - 1)} ago`;\n    } else {\n        result = `${Math.round(difference / timeValue)} ${pluralTimeName} ago`;\n    }\n    return result;\n}",
  "function () {\n                        self.log(\"enumerate\");\n                        var result = [], keys, i, name, desc;\n                        stm.recordRead(self);\n                        keys = handler.getPropertyNames();\n                        for (i = 0; i < keys.length; i += 1) {\n                            name = keys[i];\n                            desc = handler.getPropertyDescriptor(name);\n                            if (undefined !== desc && desc.enumerable) {\n                                result.push(name);\n                            }\n                        }\n                        return result;\n                    }",
  "function(id, url) {\n            var ss;\n            CSS.removeStyleSheet(id);\n            ss = doc.createElement(\"link\");\n            ss.setAttribute(\"rel\", \"stylesheet\");\n            ss.setAttribute(\"type\", \"text/css\");\n            ss.setAttribute(\"id\", id);\n            ss.setAttribute(\"href\", url);\n            doc.getElementsByTagName(\"head\")[0].appendChild(ss);\n        }",
  "function (path, body, contentType, options) {\n    const fullPath = googleDrivePath(path);\n\n    function putDone(response) {\n      if (response.status >= 200 && response.status < 300) {\n        const meta = JSON.parse(response.responseText);\n        const etagWithoutQuotes = removeQuotes(meta.etag);\n        return Promise.resolve({statusCode: 200, contentType: meta.mimeType, revision: etagWithoutQuotes});\n      } else if (response.status === 412) {\n        return Promise.resolve({statusCode: 412, revision: 'conflict'});\n      } else {\n        return Promise.reject(\"PUT failed with status \" + response.status + \" (\" + response.responseText + \")\");\n      }\n    }\n\n    return this._getFileId(fullPath).then((id) => {\n      if (id) {\n        if (options && (options.ifNoneMatch === '*')) {\n          return putDone({ status: 412 });\n        }\n        return this._updateFile(id, fullPath, body, contentType, options).then(putDone);\n      } else {\n        return this._createFile(fullPath, body, contentType, options).then(putDone);\n      }\n    });\n  }",
  "function TcolorCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 3) throw new SyntaxError('TCOLOR command requires 3 arguments');\n    this.red = parsed.args[0];\n    this.green = parsed.args[1];\n    this.blue = parsed.args[2];\n}",
  "function delaunayRefine(points, triangulation) {\n  var stack = []\n\n  var numPoints = points.length\n  var stars = triangulation.stars\n  for(var a=0; a<numPoints; ++a) {\n    var star = stars[a]\n    for(var j=1; j<star.length; j+=2) {\n      var b = star[j]\n\n      //If order is not consistent, then skip edge\n      if(b < a) {\n        continue\n      }\n\n      //Check if edge is constrained\n      if(triangulation.isConstraint(a, b)) {\n        continue\n      }\n\n      //Find opposite edge\n      var x = star[j-1], y = -1\n      for(var k=1; k<star.length; k+=2) {\n        if(star[k-1] === b) {\n          y = star[k]\n          break\n        }\n      }\n\n      //If this is a boundary edge, don't flip it\n      if(y < 0) {\n        continue\n      }\n\n      //If edge is in circle, flip it\n      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {\n        stack.push(a, b)\n      }\n    }\n  }\n\n  while(stack.length > 0) {\n    var b = stack.pop()\n    var a = stack.pop()\n\n    //Find opposite pairs\n    var x = -1, y = -1\n    var star = stars[a]\n    for(var i=1; i<star.length; i+=2) {\n      var s = star[i-1]\n      var t = star[i]\n      if(s === b) {\n        y = t\n      } else if(t === b) {\n        x = s\n      }\n    }\n\n    //If x/y are both valid then skip edge\n    if(x < 0 || y < 0) {\n      continue\n    }\n\n    //If edge is now delaunay, then don't flip it\n    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {\n      continue\n    }\n\n    //Flip the edge\n    triangulation.flip(a, b)\n\n    //Test flipping neighboring edges\n    testFlip(points, triangulation, stack, x, a, y)\n    testFlip(points, triangulation, stack, a, y, x)\n    testFlip(points, triangulation, stack, y, b, x)\n    testFlip(points, triangulation, stack, b, x, y)\n  }\n}",
  "function(str, gsv) {\n\n      if (gsv.length % 4 % 3 === 0) {\n        throw new Error('Invalid GSV length: ' + str);\n      }\n\n      /*\n       $GPGSV,1,1,13,02,02,213,,03,-3,000,,11,00,121,,14,13,172,05*67\n       \n       1    = Total number of messages of this type in this cycle\n       2    = Message number\n       3    = Total number of SVs in view\n       repeat [\n       4    = SV PRN number\n       5    = Elevation in degrees, 90 maximum\n       6    = Azimuth, degrees from true north, 000 to 359\n       7    = SNR (signal to noise ratio), 00-99 dB (null when not tracking, higher is better)\n       ]\n       N+1   = signalID NMEA 4.10\n       N+2   = Checksum\n       */\n\n      var sats = [];\n\n      for (var i = 4; i < gsv.length - 3; i += 4) {\n\n        var prn = parseNumber(gsv[i]);\n        var snr = parseNumber(gsv[i + 3]);\n        /*\n         Plot satellites in Radar chart with north on top\n         by linear map elevation from 0\u00b0 to 90\u00b0 into r to 0\n         \n         centerX + cos(azimuth - 90) * (1 - elevation / 90) * radius\n         centerY + sin(azimuth - 90) * (1 - elevation / 90) * radius\n         */\n        sats.push({\n          'prn': prn,\n          'elevation': parseNumber(gsv[i + 1]),\n          'azimuth': parseNumber(gsv[i + 2]),\n          'snr': snr,\n          'status': prn !== null ? (snr !== null ? 'tracking' : 'in view') : null\n        });\n      }\n\n      return {\n        'msgNumber': parseNumber(gsv[2]),\n        'msgsTotal': parseNumber(gsv[1]),\n        //'satsInView'  : parseNumber(gsv[3]), // Can be obtained by satellites.length\n        'satellites': sats,\n        'signalId': gsv.length % 4 === 2 ? parseNumber(gsv[gsv.length - 2]) : null // NMEA 4.10 addition\n      };\n    }",
  "function(arr, methodName){\n            var ret  = [],\n                args = Array.prototype.slice.call(arguments, 2),\n                a, v,\n                aLen = arr.length;\n\n            for (a = 0; a < aLen; a++) {\n                v = arr[a];\n\n                if (v && typeof v[methodName] == 'function') {\n                    ret.push(v[methodName].apply(v, args));\n                } else {\n                    ret.push(undefined);\n                }\n            }\n\n            return ret;\n        }",
  "function( sentence, transitionWords ) {\n\tsentence = normalizeSingleQuotes( sentence );\n\treturn transitionWords.filter( word => matchWordInSentence( word, sentence ) );\n}",
  "function makePropsObservable(ctx) {\n    let props = ctx.$rawProps;\n    if (typeof props === 'function') {\n        props = ctx.$rawProps = props();\n    }\n\n    if (!props) {\n        return;\n    }\n\n    let observer = new Observer(\n        ctx,\n        ctx[propDataKey] || /* istanbul ignore next */ {},\n        null,\n        true\n    );\n    let propsObj = {};\n\n    Object.keys(props).reduce((last, item) => {\n        last[item] = true;\n        return last;\n    }, propsObj);\n    Object.defineProperties(ctx, proxyObject(observer, propsObj));\n\n    return observer;\n}",
  "function getCustomComponentTags(config) {\n    let {usingComponents} = config || {};\n    if (!usingComponents) {\n        return;\n    }\n\n    return Object.keys(usingComponents).map(k => toHyphen(k));\n}",
  "function Vessel(dispatcher, target, config) {\n  var _this = this;\n\n  _classCallCheck(this, Vessel);\n\n  this.__dispatcher = dispatcher;\n  this.__target = target;\n  ['width', 'height', 'position', 'display'].forEach(function (key) {\n    _Object$defineProperty(_this, key, {\n      get: function get() {\n        return this.__dispatcher.dom.getStyle(this.__target, key);\n      },\n      set: function set(value) {\n        if (isNumber(value)) {\n          value = value + 'px';\n        }\n        if (!isString(value)) {\n          throw new Error('The value of ' + key + ' in ' + this.__target + 'Config must be string, but not ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '.');\n        }\n        this.__dispatcher.dom.setStyle(this.__target, key, value);\n        // return value;\n      },\n\n      configurable: true,\n      enumerable: true\n    });\n  });\n  deepAssign(this, config);\n}",
  "function (astList, context, callback) {\n\tvar retval = new Array(2);\n\tvar i = 0;\n\tvar getOpArgs2_callback = function (err, val) {\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t} else {\n\t\t\tretval[i] = val;\n\t\t\ti++;\n\t\t\tif (i >= 2) callback(null, retval);\n\t\t}\n\t};\n\trun(astList[1], context, getOpArgs2_callback);\n\trun(astList[2], context, getOpArgs2_callback);\n}",
  "function ial(app, opts) {\n\n  /**\n   * Lazily creates an i18n.\n   *\n   * @api public\n   */\n\n  Object.defineProperty(app.context, 'i18n', {\n    get: function () {\n      if (this._i18n) {\n        return this._i18n\n      }\n\n      const i18n = new I18n(opts)\n      i18n.request = this.request\n      this._i18n = i18n\n\n      // merge into ctx.state\n      this.state.i18n = i18n\n      registerMethods(this.state, i18n)\n\n      debug('app.ctx.i18n %j', i18n)\n      return i18n\n    }\n  })\n\n  Object.defineProperty(app.request, 'i18n', {\n    get: function () {\n      return this.ctx.i18n\n    }\n  })\n\n  return function i18nMiddleware(ctx, next) {\n    ctx.i18n.whitelist.some(key => {\n      const customLocaleMethod = typeof key === 'function'\n        && ctx.i18n.setLocale(key.apply(ctx))\n      if (customLocaleMethod || ctx.i18n[SET_PREFIX + key]()) return true\n    })\n    return next()\n  }\n}",
  "function (req, cb) {\n        if (req.soajs && req.soajs.tenantOauth && req.soajs.tenantOauth.secret && req.soajs.tenant && req.soajs.tenant.id) {\n            let secret = req.soajs.tenantOauth.secret;\n            let tenantId = req.soajs.tenant.id.toString();\n\n            let basic = Auth.generate(tenantId, secret);\n            return cb(null, basic);\n        }\n        else\n            return cb({\"code\": 406, \"msg\": req.soajs.config.errors[406]});\n    }",
  "function(objs) {\n        var me = this,\n            key;\n\n        if (arguments.length > 1 || Ext.isArray(objs)) {\n            me.insert(me.length, arguments.length > 1 ? arguments : objs);\n        } else {\n            for (key in objs) {\n                if (objs.hasOwnProperty(key)) {\n                    if (me.allowFunctions || typeof objs[key] != 'function') {\n                        me.add(key, objs[key]);\n                    }\n                }\n            }\n        }\n    }",
  "function end() {\n  this.writeBuffer(this.crc.value());\n  fs.closeSync(this.fd);\n\n  this.fd = null;\n  this.crc = null;\n  this.converter = null;\n}",
  "function() {\n      return path.join(process.cwd(), qx.tool.cli.ConfigSchemas.lockfile.filename);\n    }",
  "function _contextSet(contextNodeOrId, set) {\n        var contextNode = this._nodesById ? _contextGet.call(this, contextNodeOrId) : contextNodeOrId;\n        if (contextNode) {\n            var node = contextNode.node;\n            if (!node) {\n                if (contextNode.next) {\n                     if (contextNode.index < this._contextState.nextSetIndex) {\n                        LayoutUtility.error('Nodes must be layed out in the same order as they were requested!');\n                     }\n                     this._contextState.nextSetIndex = contextNode.index;\n                }\n                else if (contextNode.prev) {\n                     if (contextNode.index > this._contextState.prevSetIndex) {\n                        LayoutUtility.error('Nodes must be layed out in the same order as they were requested!');\n                     }\n                     this._contextState.prevSetIndex = contextNode.index;\n                }\n                node = _contextGetCreateAndOrderNodes.call(this, contextNode.renderNode, contextNode.prev);\n                node._viewSequence = contextNode.viewSequence;\n                node._layoutCount++;\n                if (node._layoutCount === 1) {\n                    this._contextState.addCount++;\n                }\n                contextNode.node = node;\n            }\n            node.usesTrueSize = contextNode.usesTrueSize;\n            node.trueSizeRequested = contextNode.trueSizeRequested;\n            node.set(set, this._context.size);\n            contextNode.set = set;\n        }\n        return set;\n    }",
  "function mergeModels(value, model) {\n    const newModel = Object.assign({}, model);\n    tools_1.deepExtend(newModel, value);\n    return { model: newModel, isChanged: deepEqual(model, newModel) };\n}",
  "function research( paper, researcher ) {\n\tconst language = getLanguage( paper.getLocale() );\n\n\tconst morphologyData = get( researcher.getData( \"morphology\" ), [ language ], false );\n\n\treturn collectForms( paper.getKeyword(), paper.getSynonyms(), language, morphologyData );\n}",
  "function(e, target) {\n        var me = this,\n            item, record;\n\n        if (Ext.fly(target).hasCls(me.labelSelector) && !me.editing && !e.ctrlKey && !e.shiftKey) {\n            e.stopEvent();\n            item = me.view.findItemByChild(target);\n            record = me.view.store.getAt(me.view.indexOf(item));\n            me.startEdit(target, record.data[me.dataIndex]);\n            me.activeRecord = record;\n        } else if (me.editing) {\n            me.field.blur();\n            e.preventDefault();\n        }\n    }",
  "function (el, ordinal, func) {\r\n        var options = $(el).data('popupoptions');\r\n        var openelement;\r\n        var elementclicked;\r\n        if (typeof options === 'undefined') return;\r\n        openelement =  options.openelement ? options.openelement : ('.' + el.id + opensuffix);\r\n        elementclicked = $(openelement + '[data-popup-ordinal=\"' + ordinal + '\"]');\r\n        if (typeof func == 'function') {\r\n            func.call($(el), el, elementclicked);\r\n        }\r\n    }",
  "function sortDefaultProcessors(processorNames, processors) {\n    if (Array.isArray(processorNames)) {\n        processorNames.sort((a, b) => {\n            a = processors[a];\n            b = processors[b];\n            return (a.order || 0) - (b.order || 0);\n        });\n    }\n}",
  "function string(obj, vonly) {\n  var vtype = this.type(0)\n    , key = !vonly ? this.getStringBuffer(obj.key) : new Buffer(0)\n    , value = this.getStringBuffer(obj.value);\n  return Buffer.concat(\n    [\n      vtype,\n      key,\n      value\n    ],\n    vtype.length + key.length + value.length\n  )\n}",
  "function existsOrCreateSync(filePath, opts){\n    opts = opts || {};\n    opts.encoding = opts.encoding || 'utf8';\n    opts.data = opts.data || opts.content || '';\n    opts.mode = opts.mode || '0777';\n    \n    var fp = resolve(filePath);\n    var isFile = opts.hasOwnProperty('isFile') ? opts.isFile : !!fp.extName;\n    \n    var exists = fs.existsSync(fp.fullPath);\n    if(!exists || opts.replace){\n        mkdir((isFile ? fp.dirName : fp.fullPath));\n        if(isFile || opts.replace) fs.writeFileSync(fp.fullPath, opts.data, opts.encoding);\n    }\n    \n    function mkdir(fullPath){\n        if(fs.existsSync(fullPath)) return;\n        else {\n            var parentPath = fullPath.split('/');\n            parentPath.pop();\n            mkdir(parentPath.join('/'));\n            fs.mkdirSync(fullPath, opts.mode);\n        }\n    }\n    \n    return exists;\n}",
  "function(criteria, limit, cb) {\n        if (_.isFunction(limit)) { cb = limit; limit = undefined; }\n        var self = this;\n        var query = buildQuery(criteria, limit);\n        client.createCollection(options(self, query), translateSDKCallback(function (err, collection) {\n          if (err) { return cb(err); }\n          cb(null, wrapCollection(self, collection));\n        }));\n      }",
  "function mapArrayBufferViews(ary) {\n    return ary.map(function(chunk) {\n      if (chunk.buffer instanceof ArrayBuffer) {\n        var buf = chunk.buffer;\n\n        // if this is a subarray, make a copy so we only\n        // include the subarray region from the underlying buffer\n        if (chunk.byteLength !== buf.byteLength) {\n          var copy = new Uint8Array(chunk.byteLength);\n          copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n          buf = copy.buffer;\n        }\n\n        return buf;\n      }\n\n      return chunk;\n    });\n  }",
  "function( word, locale ) {\n\tvar syllableCount = 0;\n\n\tvar fullWordExclusion = countFullWordDeviations( word, locale );\n\tif ( fullWordExclusion !== 0 ) {\n\t\treturn fullWordExclusion;\n\t}\n\n\tvar partialExclusions = countPartialWordDeviations( word, locale );\n\tword = partialExclusions.word;\n\tsyllableCount += partialExclusions.syllableCount;\n\tsyllableCount += countUsingVowels( word, locale );\n\n\treturn syllableCount;\n}",
  "function _scrollUpdate(event) {\n        if (!this.options.enabled) {\n            return;\n        }\n        var offset = Array.isArray(event.delta) ? event.delta[this._direction] : event.delta;\n        this.scroll(offset);\n    }",
  "function(callback, scope, args, delay){\n        if(Ext.isFunction(callback)){\n            args = args || [];\n            scope = scope || window;\n            if (delay) {\n                Ext.defer(callback, delay, scope, args);\n            } else {\n                callback.apply(scope, args);\n            }\n        }\n    }",
  "function(file) {\n    var xml = file.contents;\n    var xmlDoc = libxmljs.parseXml(xml);\n    var rootNode = xmlDoc.root();\n\n    var resourceObject = {};\n    var valueNodes = rootNode.find(\"data\");\n    valueNodes.forEach(function(element) {\n      var name = element.attr(\"name\").value();\n      var value = element.get(\"value\").text();\n      resourceObject[name] = value;\n    });\n\n    return JSON.stringify(resourceObject);\n  }",
  "function requireModel(filePath, cb) {\n            //check if file exist. if not return error\n            fs.exists(filePath, function (exists) {\n                if (!exists) {\n                    return cb(new Error(\"Requested Model Not Found!\"));\n                }\n\n                libProduct.model = require(filePath);\n                return cb(null, libProduct);\n            });\n        }",
  "function (runState, done) {\n    if (runState.static) {\n      trap(ERROR.STATIC_STATE_CHANGE)\n    }\n\n    const [value, offset, length] = runState.stack.popN(3)\n\n    subMemUsage(runState, offset, length)\n    let data = Buffer.alloc(0)\n    if (!length.isZero()) {\n      data = runState.memory.read(offset.toNumber(), length.toNumber())\n    }\n\n    // set up config\n    var options = {\n      value: value,\n      data: data\n    }\n\n    var localOpts = {\n      inOffset: offset,\n      inLength: length,\n      outOffset: new BN(0),\n      outLength: new BN(0)\n    }\n\n    checkCallMemCost(runState, options, localOpts)\n    checkOutOfGas(runState, options)\n    makeCall(runState, options, localOpts, done)\n  }",
  "function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createBound(object[key], 1, null, null, object);\n      }\n      return object;\n    }",
  "function() {\n      return {\n        command: \"list [repository]\",\n        describe:\n          \"if no repository name is given, lists all available contribs that are compatible with the project's qooxdoo version (\\\"--all\\\" lists incompatible ones as well). Otherwise, list all compatible contrib libraries.\",\n        builder: {\n          all: {\n            alias: \"a\",\n            describe: \"Show all versions, including incompatible ones\"\n          },\n          verbose: {\n            alias: \"v\",\n            describe: \"Verbose logging\"\n          },\n          quiet: {\n            alias: \"q\",\n            describe: \"No output\"\n          },\n          json: {\n            alias: \"j\",\n            describe: \"Output list as JSON literal\"\n          },\n          installed: {\n            alias: \"i\",\n            describe: \"Show only installed libraries\"\n          },\n          namespace: {\n            alias: \"n\",\n            describe: \"Display library namespace\"\n          },\n          match: {\n            alias: \"m\",\n            describe: \"Filter by regular expression (case-insensitive)\"\n          },\n          \"libraries\": {\n            alias: \"l\",\n            describe: \"List libraries only (no repositories)\"\n          },\n          \"short\": {\n            alias: \"s\",\n            describe: \"Omit title and description to make list more compact\"\n          },\n          \"noheaders\": {\n            alias: \"H\",\n            describe: \"Omit header and footer\"\n          }\n\n        },\n        handler: function(argv) {\n          return new qx.tool.cli.commands.contrib.List(argv)\n            .process()\n            .catch(e => {\n              console.error(e.stack || e.message);\n              process.exit(1);\n            });\n        }\n      };\n    }",
  "function() {\n    var retVal, parsedOptions;\n\n    if (this.model) {\n      retVal = this.model.toJSON();\n    } else if (this.collection) {\n      retVal = {\n        models: this.collection.toJSON(),\n        meta: this.collection.meta,\n        params: this.collection.params\n      };\n    }\n\n    // Remove options that are duplicates in the templates\n    parsedOptions = _.omit(this.options, ['model', 'collection', 'app']);\n    return _.extend({}, retVal, parsedOptions);\n  }",
  "function syncStatusRequest( state = false, { type } ) {\n\tswitch ( type ) {\n\t\tcase WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST:\n\t\tcase WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_FAILURE:\n\t\t\treturn WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST === type;\n\t}\n\n\treturn state;\n}",
  "function(str, gga) {\n\n      if (gga.length !== 16) {\n        throw new Error('Invalid GGA length: ' + str);\n      }\n\n      /*\n       11\n       1         2       3 4        5 6 7  8   9  10 |  12 13  14  15\n       |         |       | |        | | |  |   |   | |   | |   |   |\n       $--GGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh\n       \n       1) Time (UTC)\n       2) Latitude\n       3) N or S (North or South)\n       4) Longitude\n       5) E or W (East or West)\n       6) GPS Quality Indicator,\n       0 = Invalid, 1 = Valid SPS, 2 = Valid DGPS, 3 = Valid PPS\n       7) Number of satellites in view, 00 - 12\n       8) Horizontal Dilution of precision, lower is better\n       9) Antenna Altitude above/below mean-sea-level (geoid)\n       10) Units of antenna altitude, meters\n       11) Geoidal separation, the difference between the WGS-84 earth\n       ellipsoid and mean-sea-level (geoid), '-' means mean-sea-level below ellipsoid\n       12) Units of geoidal separation, meters\n       13) Age of differential GPS data, time in seconds since last SC104\n       type 1 or 9 update, null field when DGPS is not used\n       14) Differential reference station ID, 0000-1023\n       15) Checksum\n       */\n\n      return {\n        'time': parseTime(gga[1]),\n        'lat': parseCoord(gga[2], gga[3]),\n        'lon': parseCoord(gga[4], gga[5]),\n        'alt': parseDist(gga[9], gga[10]),\n        'quality': parseGGAFix(gga[6]),\n        'satellites': parseNumber(gga[7]),\n        'hdop': parseNumber(gga[8]), // dilution\n        'geoidal': parseDist(gga[11], gga[12]), // aboveGeoid\n        'age': parseNumber(gga[13]), // dgps time since update\n        'stationID': parseNumber(gga[14]) // dgpsReference??\n      };\n    }",
  "function _updateState() {\n        var prevItem;\n        var invalidated = false;\n        var hiddenViewCount = 0;\n        var i = 0;\n        while (i < this._viewStack.length) {\n            if (this._viewStack[i].state === ItemState.HIDDEN) {\n                hiddenViewCount++;\n                for (var j = 0; j < this._viewStack.length; j++) {\n                    if ((this._viewStack[j].state !== ItemState.HIDDEN) &&\n                        (this._viewStack[j].view === this._viewStack[i].view)) {\n                        this._viewStack[i].view = undefined;\n                        this._renderables.views.splice(i, 1);\n                        this._viewStack.splice(i, 1);\n                        i--;\n                        hiddenViewCount--;\n                        break;\n                    }\n                }\n            }\n            i++;\n        }\n        while (hiddenViewCount > this.options.keepHiddenViewsInDOMCount) {\n            this._viewStack[0].view = undefined;\n            this._renderables.views.splice(0, 1);\n            this._viewStack.splice(0, 1);\n            hiddenViewCount--;\n        }\n        for (i = hiddenViewCount; i < (Math.min(this._viewStack.length - hiddenViewCount, 2) + hiddenViewCount); i++) {\n            var item = this._viewStack[i];\n            if (item.state === ItemState.QUEUED) {\n                if (!prevItem ||\n                    (prevItem.state === ItemState.VISIBLE) ||\n                    (prevItem.state === ItemState.HIDING)) {\n                    if (prevItem && (prevItem.state === ItemState.VISIBLE)) {\n                        prevItem.state = ItemState.HIDE;\n                        prevItem.wait = item.wait;\n                    }\n                    item.state = ItemState.SHOW;\n                    invalidated = true;\n                }\n                break;\n            }\n            else if ((item.state === ItemState.VISIBLE) && item.hide) {\n                item.state = ItemState.HIDE;\n            }\n            if ((item.state === ItemState.SHOW) || (item.state === ItemState.HIDE)) {\n                this.layout.reflowLayout();\n            }\n            prevItem = item;\n        }\n        if (invalidated) {\n            _updateState.call(this);\n            this.layout.reflowLayout();\n        }\n    }",
  "function (cb) {\n    var i;\n    log('[Caching] Setting activate handler', cb, this.pendingActivations);\n    this.activateHandler = cb;\n    for (i=0; i<this.pendingActivations.length; i++) {\n      cb(this.pendingActivations[i]);\n    }\n    delete this.pendingActivations;\n  }",
  "function writeFile(modified, data, file) {\n\n\treturn !modified ? Promise.resolve(false) : new Promise((resolve, reject) => {\n\n\t\tfs.writeFile(file, data, (error) => {\n\n\t\t\terror ? reject(error) : resolve(true);\n\n\t\t});\n\n\t});\n\n}",
  "function getPlugins(opts) {\n    var batterRootDir = __dirname.replace(delim + 'lib', '');\n    var batterTasks = { rootDir: batterRootDir };\n    var currentProject = { rootDir: opts.rootDir };\n    var plugins = opts.plugins || [];\n\n    // tasks in batter go to the front of the list; current project at the end (i.e. most important)\n    plugins.unshift(batterTasks);\n\n    if (batterRootDir !== opts.rootDir) {\n        plugins.push(currentProject);\n    }\n\n    return plugins;\n}",
  "function hasFakeRuleset(atRuleNode) {\n            var bodyRules = atRuleNode.rules;\n            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);\n        }",
  "function(fn) {\n        var me = this;\n        fn = fn || me.sorterFn || me.defaultSorterFn;\n        me.sort = me.createSortFunction(fn);\n    }",
  "function(str) {\n      if (str === null) {\n        return null;\n      }\n      str = str.trim();\n      if (!str) {\n        return null;\n      }\n      var ast = JsonToAst.parseToAst(str);\n      var json = JsonToAst.astToObject(ast);\n      return json;\n    }",
  "function writeRamdaFunctionAsGlobalStub(ctx) {\n    ctx.newLineTop()\n    ctx.newLineTop()\n\n    Object.keys(ctx.usedRamdaFns).forEach(function(key) {\n        ctx.newLineTop()\n        ctx.writeTop('var ' + key + ' = R.' + key)\n    })\n}",
  "function parseAsShortcode( node, _parsed ) {\n\t// Attempt to convert string element into DOM node. If successful, recurse\n\t// to trigger the shortcode strategy\n\tconst shortcode = parse( node );\n\tif ( shortcode ) {\n\t\treturn _recurse( shortcode, _parsed );\n\t}\n\n\treturn _parsed;\n}",
  "function mkdir(units, name) {\n        if (name !== \"\") {\n            var parts = name.split(\".\");\n            var path = \"\";\n            for (var i = 0, len = parts.length; i < len; i++) {\n                var part = parts[i];\n                path += part;\n                if (units[part] == null) {\n                    units[part] = {};\n                } else if (typeof units[part] !== \"object\") {\n                    error(\"Cann't init unit '\" + name\n                            + \"' because path element '\" + path\n                            + \"' isn't an object\");\n                }\n                units = units[part];\n                path += \".\";\n            }\n        }\n        return units;\n    }",
  "function init(files, options, callback) {\n\n    if (_.isFunction(options)) {\n        /* There were no options, this argument is actually the callback */\n        callback = options;\n        options = {};\n    } else if (!_.isFunction(callback)) {\n        throw new TypeError('UnCSS: expected a callback');\n    }\n\n    /* Try and read options from the specified uncssrc file */\n    if (options.uncssrc) {\n        try {\n            /* Manually-specified options take precedence over uncssrc options */\n            options = _.merge(utility.parseUncssrc(options.uncssrc), options);\n        } catch (err) {\n            if (err instanceof SyntaxError) {\n                callback(new SyntaxError('UnCSS: uncssrc file is invalid JSON.'));\n                return;\n            }\n            callback(err);\n            return;\n        }\n    }\n\n    /* Assign default values to options, unless specified */\n    options = _.defaults(options, {\n        csspath: '',\n        ignore: [],\n        media: [],\n        timeout: 0,\n        report: false,\n        ignoreSheets: [],\n        html: files,\n        banner: true,\n        // gulp-uncss parameters:\n        raw: null,\n        userAgent: 'uncss',\n        inject: null\n    });\n\n    process(options).then(([css, report]) => callback(null, css, report), callback);\n}",
  "function errorHandler(response, error) {\n    response\n      .status(500)\n      .send(error !== undefined && error !== null ? error.toString() : '')\n  }",
  "function camelize () {\n                    var ret = [];\n                    libs.object.every(arguments, function (s) {\n                        if(s) {\n                            if(typeof s === 'function') s = fixFirefoxFunctionString(s.toString());\n                            s = s.toString().replace(/[^a-z0-9$]/gi, '_').replace(/\\$(\\w)/g, '$_$1').split(/[\\s_]+/g);\n                            libs.object.each(s, 1, s.length, function (i, k) {\n                                this[k] = libs.string.ucFirst(i);\n                            });\n                            s = libs.string.lcFirst(s.join(''));\n                        }\n                        ret.push(s);\n                    });\n                    return ret.length === 1 ? ret[0] : ret;\n                }",
  "function pipe() {\n    var _this = this;\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    var _done = false;\n    var targets = items.map(wrap_async_iterable_iterator_1.wrapAsyncIterableIterator);\n    var call = function (methodName, value) {\n        return new Promise(function (resolve, reject) {\n            var remaining = targets.concat();\n            var next = function (_a) {\n                var value = _a.value, done = _a.done;\n                if (!_done) {\n                    _done = done;\n                }\n                // if one piped item finishes, then we need to finish\n                if (!remaining.length || _done) {\n                    if (methodName === \"next\") {\n                        while (remaining.length) {\n                            (remaining.shift().return || (function () { }))();\n                        }\n                    }\n                    return resolve({ value: value, done: done });\n                }\n                var fn = remaining.shift()[methodName];\n                return fn ? fn(value).then(next, reject) : next(value);\n            };\n            next({ value: value, done: false });\n        });\n    };\n    return _a = {},\n        _a[Symbol.asyncIterator] = function () { return _this; },\n        _a.next = call.bind(this, \"next\"),\n        _a.return = call.bind(this, \"return\"),\n        _a.throw = call.bind(this, \"throw\"),\n        _a;\n    var _a;\n}",
  "function updateIndent(info, dict, whitespaceNode) {\n    var item = dict[info.id];\n    if (!item)\n        return whitespaceNode;\n\n    var crPos = whitespaceNode.lastIndexOf('\\n');\n    var tabPos = whitespaceNode.lastIndexOf('\\t');\n    if (tabPos > crPos) crPos = tabPos;\n\n    var firstPart = whitespaceNode.substr(0, crPos + 1);\n    var extraIndent = new Array(\n        (item.prefixLength - info.prefixLength) +\n        (item.extra - info.extra) +\n        whitespaceNode.length - firstPart.length +\n        1).join(' ');\n\n    return firstPart.concat(extraIndent);\n  }",
  "function generateSite() {\n  return new Promise((resolve, reject) => {\n    Metalsmith(__dirname)\n      .metadata({\n        site: {\n          title: \"Qooxdoo Application Server\",\n          description: \"Mini website used by \\\"qx serve\\\"\",\n          email: \"info@qooxdoo.org\",\n          twitter_username: \"qooxdoo\",\n          github_username: \"qooxdoo\",\n          pages: [ \"/\", \"/about/\" ]\n        },\n        baseurl: \"\",\n        url: \"\",\n        lang: \"en\",\n        partials: {}\n      })\n      .source('./src')\n      .destination('./build')\n      .clean(true)\n      .use(loadPartials)\n      .use(markdown())\n      .use(getPages)\n      .use(layouts({\n        engine: 'dot'\n      }))\n      .build(function(err) {\n        if (err)\n          reject(err);\n        else\n          resolve();\n      });\n  });\n}",
  "function getAuthorizationHeader(realm, parameters) {\n        var header = 'OAuth realm=\"' + OAuth.percentEncode(realm) + '\"';\n        var list = OAuth.getParameterList(parameters);\n        for (var p = 0; p < list.length; ++p) {\n            var parameter = list[p];\n            var name = parameter[0];\n            if (name.indexOf(\"oauth_\") == 0) {\n                header += ',' + OAuth.percentEncode(name) + '=\"' + OAuth.percentEncode(parameter[1]) + '\"';\n            }\n        }\n        return header;\n    }",
  "function(endpoint, all) {\n      if (!_.isNil(endpoint)) {\n        all = _.assignIn(\n          _.clone(allEndpointParameters(endpoint.parent, endpoint.parameters)),\n          all || {})\n      }\n      return all\n    }",
  "function (path) {\n    var url = 'https://api.dropbox.com/2/sharing/list_shared_links';\n    var options = {\n      body: {\n        path: getDropboxPath(path),\n        direct_only: true\n      }\n    };\n\n    return this._request('POST', url, options).then((response) => {\n      if (response.status !== 200 && response.status !== 409) {\n        return Promise.reject(new Error('Invalid response status: ' + response.status));\n      }\n\n      var body;\n\n      try {\n        body = JSON.parse(response.responseText);\n      } catch (e) {\n        return Promise.reject(new Error('Invalid response body: ' + response.responseText));\n      }\n\n      if (response.status === 409) {\n        return Promise.reject(new Error('API error: ' + response.error_summary));\n      }\n\n      if (!body.links.length) {\n        return Promise.reject(new Error('No links returned'));\n      }\n\n      return Promise.resolve(body.links[0].url);\n    }, (error) => {\n      error.message = 'Could not get link to a shared file or folder (\"' + path + '\"): ' + error.message;\n      return Promise.reject(error);\n    });\n  }",
  "function expectedCaseIndent(node, switchIndent) {\n\t\tvar switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n\t\tvar caseIndent;\n\n\t\tif (caseIndentStore[switchNode.loc.start.line]) {\n\t\t\treturn caseIndentStore[switchNode.loc.start.line];\n\t\t} else {\n\t\t\tif (typeof switchIndent === \"undefined\") {\n\t\t\t\tswitchIndent = getNodeIndent(switchNode);\n\t\t\t}\n\n\t\t\tif (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n\t\t\t\tcaseIndent = switchIndent;\n\t\t\t} else {\n\t\t\t\tcaseIndent = switchIndent + (indentSize * options.SwitchCase);\n\t\t\t}\n\n\t\t\tcaseIndentStore[switchNode.loc.start.line] = caseIndent;\n\t\t\treturn caseIndent;\n\t\t}\n\t}",
  "function getWorkflowGuids(callback) {\n        return self.apos.docs.db.findWithProjection(\n          { _id: { $in: _.pluck(related, '_id') } },\n          { _id: 1, workflowGuid: 1, type: 1 }\n        ).toArray(function(err, guidDocs) {\n          if (err) {\n            return fail(err);\n          }\n          _.each(guidDocs, function(guidDoc) {\n            var relatedOne = _.find(related, { _id: guidDoc._id });\n            if (relatedOne) {\n              relatedOne.workflowGuid = guidDoc.workflowGuid;\n              idsByGuid[relatedOne.workflowGuid] = relatedOne._id;\n              relatedOne.type = guidDoc.type;\n            }\n          });\n          // Discard unless the type is known, the type is subject to\n          // workflow and we have the workflowGuid\n          related = _.filter(related, function(relatedOne) {\n            return relatedOne.type && relatedOne.workflowGuid && self.includeType(relatedOne.type);\n          });\n          return callback(null);\n        });\n      }",
  "function hilbertIndexInverse(dim, index, options) { // :: Int -> Int -> [Int, Int, ..]\n    options = options || {}\n    var entry = options.entry || 0,\n        direction = options.direction || 0,\n        m = curvePrecision(index, dim),\n        p = Array.apply(null, new Array(dim)).map(Number.prototype.valueOf, 0)\n\n    for (var i = m - 1; i >= 0; i--) {\n        var mask = 1 << (i * dim), bits = 0, code\n\n        for (var k = dim - 1; k >= 0; k--) {\n            if (index & (mask << k)) {\n                bits |= (1 << k)\n            }\n        }\n\n        code = grayInverseTransform(entry, direction, grayCode(bits), dim)\n        for (var k = 0; k < dim; k++) {\n            if (code & (1 << k)) {\n                p[k] |= (1 << i)\n            }\n        }\n\n        entry = entry ^ bitwise.rotateLeft(entrySequence(bits), dim, 0, direction + 1)\n        direction = (direction + directionSequence(bits, dim) + 1) % dim\n    }\n    return p\n}",
  "function(store) {\n        var me = this;\n\n        // Unbind from the old Store\n        if (me.store && me.storeListeners) {\n            me.store.un(me.storeListeners);\n        }\n\n        // Set up correct listeners\n        if (store) {\n            me.storeListeners = {\n                scope: me\n            };\n            if (me.local) {\n                me.storeListeners.load = me.onLoad;\n            } else {\n                me.storeListeners['before' + (store.buffered ? 'prefetch' : 'load')] = me.onBeforeLoad;\n            }\n            store.on(me.storeListeners);\n        } else {\n            delete me.storeListeners;\n        }\n        me.store = store;\n    }",
  "function applyIndent( indent, content ) {\n\t\t\tif ( ! indent || indent.length < 1 ) {\n\t\t\t\treturn content;\n\t\t\t}\n\n\t\t\treturn content\n\t\t\t\t.split( \"\\n\" )\n\t\t\t\t.map( function( line ) {\n\t\t\t\t\t// do not indent empty lines\n\t\t\t\t\treturn line.trim() !== \"\" ? ( indent + line ) : \"\";\n\t\t\t\t} )\n\t\t\t\t.join( \"\\n\" );\n\t\t}",
  "function process (rawXLSX, options) {\n  // if no options are passed, set an empty Object as default\n  options = options || {}\n\n  // check for errors in the options, and clean up if needed\n  options = validateOptions(options)\n\n  // if no processor is set, assume `keyvalue`\n  const defaultProcessor = options.processor || 'keyvalue'\n\n  // if no overrides were set, assume there are none\n  const overrides = options.overrides || {}\n\n  // if the XLSX file came over as a Buffer, read it differently\n  const workbook = rawXLSX instanceof Buffer ? XLSX.read(rawXLSX, {type: 'buffer'}) : XLSX.readFile(rawXLSX)\n\n  // get the names of all the sheets in an Array\n  let sheets = workbook.SheetNames\n\n  if (options.includeSheets) {\n    sheets = sheets.filter((s) => options.includeSheets.indexOf(s) !== -1)\n  }\n\n  if (options.excludeSheets) {\n    sheets = sheets.filter((s) => options.excludeSheets.indexOf(s) === -1)\n  }\n\n  // the eventual payload returned to the callback\n  let payload = {}\n\n  // for each sheet in the workbook process its contents\n  sheets.forEach(function (sheet) {\n    // determine the appropriate processor, using the override if it exists\n    const processor = overrides.hasOwnProperty(sheet) ? overrides[sheet] : defaultProcessor\n\n    // pass pass the sheet on to the process script with the correct processor\n    payload[sheet] = getProcessor(processor)(workbook.Sheets[sheet])\n  })\n\n  // return the processed data\n  return payload\n}",
  "function isType (type, val) {\n  return (type == Any)\n      || (type == Object && is.object(val))\n      || (type == Function && is.function(val))\n      || (type == String && is.string(val))\n      || (type == Error && is.error(val))\n      || (type == Number && is.number(val))\n      || (type == Array && is.array(val))\n      || (type == Boolean && is.boolean(val))\n      || (type == RegExp && is.regExp(val))\n      || (type == Date && is.date(val))\n      || (type == null && is.nullOrUndefined(val))\n      || (val instanceof type)\n}",
  "function spawnCommandWithKill(...args) {\n  const child = spawnCommand(...args)\n  child.kill = kill.bind(child)\n  return child\n}",
  "function filterFunctionWordsAtEnding( wordCombinations, functionWords ) {\n\treturn wordCombinations.filter( function( combination ) {\n\t\tconst words = combination.getWords();\n\t\tconst lastWordIndex = words.length - 1;\n\t\treturn ! includes( functionWords, words[ lastWordIndex ] );\n\t} );\n}",
  "function isDomainComponent(component) {\n  const getRole = (child) => {\n    return child && child.type ? child.type.role : \"\";\n  };\n  let role = getRole(component);\n  if (role === \"portal\") {\n    const children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  const whitelist = [\n    \"area\",\n    \"axis\",\n    \"bar\",\n    \"boxplot\",\n    \"candlestick\",\n    \"errorbar\",\n    \"group\",\n    \"line\",\n    \"pie\",\n    \"scatter\",\n    \"stack\",\n    \"voronoi\"\n  ];\n  return includes(whitelist, role);\n}",
  "function NewRelic(license_key, options, log) {\n  this.url = \"https://api.newrelic.com\";\n  this._options = options;\n  this.license_key = license_key;\n\n  if (!this._options.hasOwnProperty('user')) {\n    this._options['user'] = 'dreadnot';\n  }\n\n  this.log = log || logmagic.local('sensu');\n}",
  "function getTracks() {\n\t    var _this2 = this;\n\n\t    var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t    // Handle media or textTracks missing or null\n\t    var tracks = Array.from((this.media || {}).textTracks || []); // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)\n\t    // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)\n\n\t    return tracks.filter(function (track) {\n\t      return !_this2.isHTML5 || update || _this2.captions.meta.has(track);\n\t    }).filter(function (track) {\n\t      return ['captions', 'subtitles'].includes(track.kind);\n\t    });\n\t  }",
  "function detach(node) {\n            if (node.placeholder instanceof HTMLElement === false) {\n                node.placeholder = createPlaceholder(node.data.tag || node.el.tagName);\n            }\n            if (node && node.el && node.el.parentNode) {\n                node.el.parentNode.replaceChild(node.placeholder, node.el);\n            }\n        }",
  "function nextSiblings(element) {\n  var next = element.nextSibling;\n  var siblings = [];\n\n  while (next) {\n    siblings.push(next);\n    next = next.nextSibling;\n  }\n\n  return siblings;\n}",
  "function checkTile(tile) {\n        // No tile, ignore\n        if (!tile) return false;\n        // If an array of indices was provided, tile's index must be in that array\n        if (tileIndices && tileIndices.includes(tile.index)) return true;\n        // If a tile property was provided, the tile must have a truthy value for that property\n        if (tileProperty && tile.properties[tileProperty]) return true;\n        // If we only care about colliding tiles, make sure the tile collides\n        if (checkCollide && tile.collides) return true;\n        // Tile didn't pass any checks, ignore\n        return false;\n    }",
  "function (array, begin, end) {\n                // After tested for IE 6, the one below is of the best performance\n                // see http://jsperf.com/slice-fix\n                if (typeof begin === 'undefined') {\n                    return slice.call(array);\n                }\n                if (typeof end === 'undefined') {\n                    return slice.call(array, begin);\n                }\n                return slice.call(array, begin, end);\n            }",
  "async function disposable() {\n  const name = \"tmp\" + Math.floor(Math.random() * 10000);\n  await connection.dbCreate(name).run();\n\n  const r = Object.create(connection);\n\n  r.dispose = async function() {\n    await this.dbDrop(name).run();\n  };\n\n  r._poolMaster._options.db = name;\n\n  return r;\n}",
  "function calculateLineHeight(model, columnWidths) {\n        var padding = this.internal.__cell__.padding;\n        var fontSize = this.internal.__cell__.table_font_size;\n        var scaleFactor = this.internal.scaleFactor;\n\n        return Object.keys(model)\n            .map(function (value) {return typeof value === 'object' ? value.text : value})\n            .map(function (value) { return this.splitTextToSize(value, columnWidths[value] - padding - padding) }, this)\n            .map(function (value) { return this.getLineHeightFactor() * value.length * fontSize / scaleFactor + padding + padding }, this)\n            .reduce(function (pv, cv) { return Math.max(pv, cv) }, 0);\n    }",
  "function _resolveNodeSize(node) {\n        var localItemSize = itemSize;\n        if (getItemSize) {\n            localItemSize = getItemSize(node.renderNode, size);\n        }\n        if ((localItemSize[0] === true) || (localItemSize[1] === true)) {\n            var result = context.resolveSize(node, size);\n            if (localItemSize[0] !== true) {\n                result[0] = itemSize[0];\n            }\n            if (localItemSize[1] !== true) {\n                result[1] = itemSize[1];\n            }\n            return result;\n        }\n        else {\n            return localItemSize;\n        }\n    }",
  "function(){\n        var me = this,\n            current = me.store.currentPage;\n\n        if (me.fireEvent('beforechange', me, current) !== false) {\n            me.store.loadPage(current);\n        }\n    }",
  "function startBuild(buildConf, clear) {\n    // init build manager\n    let buildManager = BuildManager.create(buildConf.appType, buildConf);\n\n    if (clear) {\n        buildManager.clear();\n    }\n\n    startDevServer(buildConf, buildManager);\n    let doneHandler = function () {\n        startFileChangeMonitor(buildConf, buildManager);\n    };\n\n    // run build\n    return runBuild(buildConf, buildManager).then(\n        doneHandler,\n        doneHandler\n    );\n}",
  "function () {\n                var entities = this.entities, negate;\n\n                if (parserInput.peek(/^-[@\\$\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n\n                var o = this.sub() || entities.dimension() ||\n                        entities.color() || entities.variable() ||\n                        entities.property() || entities.call() ||\n                        entities.quoted(true) || entities.colorKeyword() ||\n                        entities.mixinLookup();\n\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new(tree.Negative)(o);\n                }\n\n                return o;\n            }",
  "function(options) {\n        return options && options.tid ? Ext.direct.Manager.getTransaction(options.tid) : null;\n    }",
  "function cartToCriteoItems( cart ) {\n\treturn cart.products.map( product => {\n\t\treturn {\n\t\t\tid: product.product_id,\n\t\t\tprice: product.cost,\n\t\t\tquantity: product.volume,\n\t\t};\n\t} );\n}",
  "function changeAddrFromMnemonic(walletInfo, index, BITBOX) {\n  // root seed buffer\n  const rootSeed = BITBOX.Mnemonic.toSeed(walletInfo.mnemonic)\n\n  // master HDNode\n  if (walletInfo.network === \"testnet\")\n    var masterHDNode = BITBOX.HDNode.fromSeed(rootSeed, \"testnet\")\n  else var masterHDNode = BITBOX.HDNode.fromSeed(rootSeed)\n\n  // HDNode of BIP44 account\n  const account = BITBOX.HDNode.derivePath(masterHDNode, \"m/44'/145'/0'\")\n\n  // derive the first external change address HDNode which is going to spend utxo\n  const change = BITBOX.HDNode.derivePath(account, `0/${index}`)\n\n  return change\n}",
  "function getElementServices (app, name) {\r\n  let forecasts = app.get('forecasts')\r\n  if (name) {\r\n    forecasts = forecasts.filter(forecast => forecast.name === name)\r\n  }\r\n\r\n  // Iterate over configured forecast models\r\n  let services = []\r\n  for (let forecast of forecasts) {\r\n    for (let element of forecast.elements) {\r\n      let service = app.getService(forecast.name + '/' + element.name)\r\n      if (service) {\r\n        services.push(service)\r\n      }\r\n    }\r\n  }\r\n  return services\r\n}",
  "function(){\n        var requests = this.requests,\n            id;\n        \n        for (id in requests) {\n            if (requests.hasOwnProperty(id)) {\n                this.abort(requests[id]);\n            }\n        }\n    }",
  "function togglePlay(input) {\n\t      // Toggle based on current state if nothing passed\n\t      var toggle = is$1.boolean(input) ? input : !this.playing;\n\n\t      if (toggle) {\n\t        this.play();\n\t      } else {\n\t        this.pause();\n\t      }\n\t    }",
  "function check(type, provider, playsinline) {\n\t    var canPlayInline = browser.isIPhone && playsinline && support.playsinline;\n\t    var api = support[type] || provider !== 'html5';\n\t    var ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);\n\t    return {\n\t      api: api,\n\t      ui: ui\n\t    };\n\t  }",
  "function() {\n        var me = this,\n            i = 0,\n            items = me.items,\n            surface = me.getSurface(),\n            len = me.length;\n        \n        if (surface) {\n            for (; i < len; i++) {\n                surface.renderItem(items[i]);\n            }\n        }\n        return me;\n    }",
  "function getSentenceBeginning( sentence, firstWordExceptions ) {\n\tconst words = getWords( stripTags( stripSpaces( sentence ) ) );\n\n\tif ( words.length === 0 ) {\n\t\treturn \"\";\n\t}\n\n\tlet firstWord = words[ 0 ].toLocaleLowerCase();\n\n\tif ( firstWordExceptions.indexOf( firstWord ) > -1 && words.length > 1 ) {\n\t\tfirstWord += \" \" + words[ 1 ];\n\t}\n\n\treturn firstWord;\n}",
  "function(snippet) {\n\t\t\tvar utils = require('utils');\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar pair = snippet.split(':');\n\t\t\t\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t}",
  "function _tr_stored_block(buf, // input block\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tsend_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\n\t\t\tcopy_block(buf, stored_len, true); // with header\n\t\t}",
  "function(o) {\n        var me = this,\n            key;\n\n        if (o != null) {\n            // If\n            //     We have not been forced into using linear lookup by a usage of the 2 arg form of add\n            // and\n            //     The key extraction function yields a key\n            // Then use the map to determine object presence.\n            if (!me.useLinearSearch && (key = me.getKey(o))) {\n                return this.map[key] != null;\n            }\n\n            // Fallback: Use linear search\n            return Ext.Array.indexOf(this.items, o) !== -1;\n        }\n        \n        return false;\n    }",
  "function getRequireExpressionModuleId(node, t) {\n    if (t.isCallExpression(node)) {\n        let {arguments: args, callee} = node;\n        if (t.isIdentifier(callee)\n            && callee.name === 'require'\n            && args.length === 1\n            && t.isLiteral(args[0])\n        ) {\n            let id = args[0].value;\n            return id;\n        }\n    }\n}",
  "function formatDate(date, format, relative, localeCode) {\n    var adu, loc = getLocalization(localeCode), caps = regexp(/^[A-Z]/), value, shortcut;\n    if(!date.isValid()) {\n      return 'Invalid Date';\n    } else if(Date[format]) {\n      format = Date[format];\n    } else if(isFunction(format)) {\n      adu = getAdjustedUnitWithMonthFallback(date);\n      format = format.apply(date, adu.concat(loc));\n    }\n    if(!format && relative) {\n      adu = adu || getAdjustedUnitWithMonthFallback(date);\n      // Adjust up if time is in ms, as this doesn't\n      // look very good for a standard relative date.\n      if(adu[1] === 0) {\n        adu[1] = 1;\n        adu[0] = 1;\n      }\n      return loc.getRelativeFormat(adu);\n    }\n\n    format = format || 'long';\n    format = loc[format] || format;\n\n    DateOutputFormats.forEach(function(dof) {\n      format = format.replace(regexp('\\\\{('+dof.token+')(\\\\d)?\\\\}', dof.word ? 'i' : ''), function(m,t,d) {\n        var val = dof.format(date, loc, d || 1, t), l = t.length, one = t.match(/^(.)\\1+$/);\n        if(dof.word) {\n          if(l === 3) val = val.slice(0,3);\n          if(one || t.match(caps)) val = simpleCapitalize(val);\n        } else if(one && !dof.text) {\n          val = (isNumber(val) ? padNumber(val, l) : val.toString()).slice(-l);\n        }\n        return val;\n      });\n    });\n    return format;\n  }",
  "function advanceDays (d, daysInTheFuture, adjustForWeekend) {\n                    if(!(d instanceof Date)) return d;\n                    daysInTheFuture = daysInTheFuture && libs.generic.isNumeric(daysInTheFuture) ? daysInTheFuture : 1;\n                    d.setTime(d.getTime() + (daysInTheFuture * 86400000));\n\n                    if(adjustForWeekend && (d.getDay() === 0 || d.getDay() === 6)) {\n                        while(d.getDay() === 0 || d.getDay() === 6) d.setTime(d.getTime() + 86400000);\n                    }\n                    return d;\n                }",
  "function modulesCommand(shell, args, data, evaluationId) {\n  var names = [];\n  for (var n in shell.installedModules) {\n    names.push(n);\n  }\n\n  console.log(names.join('\\n'));\n}",
  "function setContextValue(setChainContext, chainId, name, value) {\n    if (value instanceof Function) {\n        throw new FunctionAsValueException();\n    }\n    setChainContext(chainId, name, value);\n}",
  "function Flow(limit) {\n  this.limit = limit;\n  Object.defineProperty(this, \"futureStack_\", {\n    enumerable: false,\n    writable: true,\n    value: []\n  });\n  Object.defineProperty(this, \"runningNum_\", {\n    enumerable: false,\n    writable: true,\n    value: 0\n  });\n}",
  "function checkFlags(flags) {\n  const seen = new Set();\n\n  for (const flag of flags) {\n    if (seen.has(flag) || !validFlags.includes(flag)) {\n      throw new SyntaxError(`Invalid flags: ${flags}`);\n    }\n    seen.add(flag);\n  }\n\n  return flags.split('').sort().join('');\n}",
  "function create(props) {\n    var slider = Object.create(this);\n\n    // apply Widget defaults, then overwrite (if applicable) with Slider defaults\n    _canvasWidget2.default.create.call(slider);\n\n    // ...and then finally override with user defaults\n    Object.assign(slider, Slider.defaults, props);\n\n    // set underlying value if necessary... TODO: how should this be set given min/max?\n    if (props.value) slider.__value = props.value;\n\n    // inherits from Widget\n    slider.init();\n\n    return slider;\n  }",
  "function setup (cb) {\n  // the address we are sending from\n  var publicKeyBuf = Buffer.from(keyPair.publicKey, 'hex')\n  var address = utils.pubToAddress(publicKeyBuf, true)\n\n  // create a new account\n  var account = new Account()\n\n  // give the account some wei.\n  //    Note: this needs to be a `Buffer` or a string. All\n  //      strings need to be in hex.\n  account.balance = '0xf00000000000000001'\n\n  // store in the trie\n  stateTrie.put(address, account.serialize(), cb)\n}",
  "function(o, angle) {\n            angle = (angle + 360) % 360;\n            this.toPolar(o);\n            this.y += toRad(angle);\n            var p = point.fromPolar(this.x, this.y, o);\n            this.x = p.x;\n            this.y = p.y;\n            return this;\n        }",
  "function genEntityDescription(data, kind, entityName) {\n    return data({kind: kind, name: entityName}).select('description').join('\\n\\n');\n}",
  "function() {\n        var me = this,\n            actions = me.actions,\n            namespace = me.namespace,\n            action, cls, methods, i, len, method;\n            \n        for (action in actions) {\n            if (actions.hasOwnProperty(action)) {\n                if (me.disableNestedActions) {\n                    cls = namespace[action];\n                    \n                    if (!cls) {\n                        cls = namespace[action] = {};\n                    }\n                }\n                else {\n                    cls = me.getNamespace(namespace, action);\n\n                    if (!cls) {\n                        cls = me.createNamespaces(namespace, action);\n                    }\n                }\n\n                methods = actions[action];\n\n                for (i = 0, len = methods.length; i < len; ++i) {\n                    method = new Ext.direct.RemotingMethod(methods[i]);\n                    cls[method.name] = me.createHandler(action, method);\n                }\n            }\n        }\n    }",
  "function actionCall(action, params) {\n    action.call(router, params, router.getRenderCallback(route));\n  }",
  "function Future(f, args) {\n  var self = this;\n\n  function run() {\n    args[args.length] = function cb() {\n      switch (arguments.length) {\n      case 0:\n        self.result = null;\n        break;\n      case 1:\n        if (arguments[0] instanceof Error) {\n          self.err = arguments[0];\n        } else {\n          self.result = arguments[0];\n        }\n        break;\n      default:\n        self.err = arguments[0];\n        if (arguments.length === 2) {\n          self.result = arguments[1];\n        } else {\n          self.result = Array.prototype.slice.call(arguments, 1);\n        }\n        break;\n      }\n      if (self.flow_) self.flow_.futureFinished();\n      var caller = self.caller;\n      if (caller) caller.run();\n    };\n    args.length++;\n    f.apply(undefined, args);\n  }\n  this.run = run;\n\n  var flow = Fiber.current.flow;\n  if (flow) {\n    Object.defineProperty(this, \"flow_\", {\n      enumerable: false,\n      writable: true,\n      value: flow\n    });\n    flow.registerFuture(this);\n  } else {\n    run();\n  }\n}",
  "function(className) {\n      var library = this.getLibraryFromClassname(className);\n      if (!library) {\n        return null; \n      }\n      var path = library.getRootDir() + \"/\" + library.getSourcePath() + \"/\" + className.replace(/\\./g, \"/\") + \".js\";\n      return path;\n    }",
  "function finishLoad(loader, load) {\n      // if not anonymous, add to the module table\n      if (load.name) {\n        console.assert(!loader.modules[load.name], 'load not in module table');\n        loader.modules[load.name] = load.module;\n      }\n      var loadIndex = indexOf.call(loader.loads, load);\n      if (loadIndex != -1)\n        loader.loads.splice(loadIndex, 1);\n      for (var i = 0, l = load.linkSets.length; i < l; i++) {\n        loadIndex = indexOf.call(load.linkSets[i].loads, load);\n        if (loadIndex != -1)\n          load.linkSets[i].loads.splice(loadIndex, 1);\n      }\n      load.linkSets.splice(0, load.linkSets.length);\n    }",
  "function() {\n        var args = {};\n        this.getAssignments().forEach(function(assignment) {\n            args[assignment.param.name] = assignment.value;\n        }, this);\n        return args;\n    }",
  "function() {\n    var html = this.getInnerHtml(),\n        attributes = this.getAttributes(),\n        tagName = _.result(this, \"tagName\"),\n        attrString;\n\n    attrString = _.inject(attributes, function(memo, value, key) {\n      return memo += \" \" + key + \"=\\\"\" + _.escape(value) + \"\\\"\";\n    }, '');\n\n    return \"<\" + tagName + attrString + \">\" + html + \"</\" + tagName + \">\";\n  }",
  "function listLocalDatasetClientData(datasetClient, cb) {\n  syncStorage.readDatasetClientWithRecords(datasetClient.getId(), function(err, datasetClientsWithRecords) {\n    if (err) {\n      return cb(err);\n    }\n    //no one sync loop has completed yet, return null\n    if (!datasetClientsWithRecords || !datasetClientsWithRecords.syncCompleted) {\n      return cb(null, null);\n    } else {\n      return cb(null, datasetClientsWithRecords);\n    }\n  });\n}",
  "function(text) {\n        if (text == null) {\n            throw new Error('Illegal text for Argument: ' + text);\n        }\n        var ev = { argument: this, oldText: this.text, text: text };\n        this.text = text;\n        this.emitter._dispatchEvent('argumentChange', ev);\n    }",
  "function closest(element, test) {\n  var el = element;\n\n  while (el) {\n    if (test(el)) {\n      return el;\n    }\n    el = el.parentNode;\n  }\n\n  return null;\n}",
  "function filterNeverIgnoredFiles(p) {\n    const basedir = path.dirname(p.filePath)\n    const mainFilePath =\n        typeof p.main === \"string\" ? path.join(basedir, p.main) : null\n\n    return filePath =>\n        path.join(basedir, filePath) !== mainFilePath &&\n        filePath !== \"package.json\" &&\n        !NEVER_IGNORED.test(path.relative(basedir, filePath))\n}",
  "function YearMonthForm({ date, localeUtils, onChange, fromMonth, toMonth }) {\n    const months = localeUtils.getMonths();\n\n    const years = [];\n    for (let i = fromMonth.getFullYear(); i <= toMonth.getFullYear(); i += 1) {\n        years.push(i);\n    }\n\n    const handleChange = function handleChange(e) {\n        const { year, month } = e.target.form;\n        onChange(new Date(year.value, month.value));\n    };\n\n    return (\n        <form className=\"DayPicker-Caption\">\n            <select name=\"month\" onChange={handleChange} value={date.getMonth()}>\n                {months.map((month, i) => <option key={i} value={i}>{month}</option>)}\n            </select>\n            <select name=\"year\" onChange={handleChange} value={date.getFullYear()}>\n                {years.map((year, i) =>\n                    <option key={i} value={year}>\n                        {year}\n                    </option>\n                )}\n            </select>\n        </form>\n    );\n}",
  "function removeData(element, name) {\n  if (isObject(element[name])) {\n    try {\n      delete element[name];\n    } catch (error) {\n      element[name] = undefined;\n    }\n  } else if (element.dataset) {\n    // #128 Safari not allows to delete dataset property\n    try {\n      delete element.dataset[name];\n    } catch (error) {\n      element.dataset[name] = undefined;\n    }\n  } else {\n    element.removeAttribute(\"data-\".concat(toParamCase(name)));\n  }\n}",
  "function (x, event, selected) {\n      if (selected) {\n        currentSubject = x\n      } else {\n        currentSubject = null\n        if (currentMode === 1) deselectObject()\n      } // If all are displayed, refresh would just annoy:\n      if (currentMode !== 0) showFiltered(currentMode) // Refresh the objects\n    }",
  "function updateLocalizer(refObj, targetLocalizersHelpers) {\n        let refHelper = refObj.stackHelper;\n        let localizerHelper = refObj.localizerHelper;\n        let plane = refHelper.slice.cartesianEquation();\n        localizerHelper.referencePlane = plane;\n\n        // bit of a hack... works fine for this application\n        for (let i = 0; i < targetLocalizersHelpers.length; i++) {\n          for (let j = 0; j < 3; j++) {\n            let targetPlane = targetLocalizersHelpers[i]['plane' + (j + 1)];\n            if (\n              targetPlane &&\n              plane.x.toFixed(6) === targetPlane.x.toFixed(6) &&\n              plane.y.toFixed(6) === targetPlane.y.toFixed(6) &&\n              plane.z.toFixed(6) === targetPlane.z.toFixed(6)\n            ) {\n              targetLocalizersHelpers[i]['plane' + (j + 1)] = plane;\n            }\n          }\n        }\n\n        // update the geometry will create a new mesh\n        localizerHelper.geometry = refHelper.slice.geometry;\n      }",
  "function (d){\n    if (!arguments.length) {\n      if (typeof _i === 'object'){\n        var o = {};\n        for (var prop in _i){\n          o[prop] = _i[prop]();\n        }\n        return o;\n      } else {\n        return _i;\n      }\n    }\n    _i = validate(d);\n    // if _i is an object we expose the getter/setter methods of its attributes\n    if (typeof _i === 'object'){\n      for (var prop_object in _i){\n        me[prop_object] = _i[prop_object];\n      }\n    }\n  }",
  "function parse_scan_results(block) {\n    var match;\n    var results = [];\n    var lines;\n    \n    lines = block.split('\\n').map(function(item) { return item + \"\\n\"; });\n    lines.forEach(function(entry){\n        var parsed = {};\n        if ((match = entry.match(/([A-Fa-f0-9:]{17})\\t/))) {\n            parsed.bssid = match[1].toLowerCase();\n        }\n\n        if ((match = entry.match(/\\t([\\d]+)\\t+/))) {\n            parsed.frequency = parseInt(match[1], 10);\n        }\n\n        if ((match = entry.match(/([-][0-9]+)\\t/))) {\n            parsed.signalLevel = parseInt(match[1], 10);\n        }\n\n        if ((match = entry.match(/\\t(\\[.+\\])\\t/))) {\n            parsed.flags = match[1];\n        }\n\n        if ((match = entry.match(/\\t([^\\t]{1,32}(?=\\n))/))) {\n            parsed.ssid = match[1];\n        }\n\n        if(!(Object.keys(parsed).length === 0 && parsed.constructor === Object)){\n            results.push(parsed);\n        }\n    });\n\n    return results;\n}",
  "function() {\n\t\treturn flatten(\n\t\t\tcompact(\n\t\t\t\tmap( this._flow.steps, function( step ) {\n\t\t\t\t\treturn steps[ step ].providesDependencies;\n\t\t\t\t} )\n\t\t\t)\n\t\t).concat( this._flow.providesDependenciesInQuery );\n\t}",
  "function checkPlaying(event) {\n\t    var _this3 = this;\n\n\t    // Class hooks\n\t    toggleClass(this.elements.container, this.config.classNames.playing, this.playing);\n\t    toggleClass(this.elements.container, this.config.classNames.paused, this.paused);\n\t    toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped); // Set state\n\n\t    Array.from(this.elements.buttons.play || []).forEach(function (target) {\n\t      target.pressed = _this3.playing;\n\t    }); // Only update controls on non timeupdate events\n\n\t    if (is$1.event(event) && event.type === 'timeupdate') {\n\t      return;\n\t    } // Toggle controls\n\n\n\t    ui.toggleControls.call(this);\n\t  }",
  "function(filterInput, uri) {\n    var _url = new URL(uri);\n    var _filterValueFromURL = _url.searchParams.get('filter');\n    if (typeof _filterValueFromURL !== 'undefined' && _filterValueFromURL !== null) {\n      _filterValue = _filterValueFromURL;\n      filterInput.value = _filterValue; // eslint-disable-line\n    }\n  }",
  "function (filters) {\n        if (filters) {\n            var me = this,\n                i, filtersLength;\n            for (i = 0, filtersLength = filters.length; i < filtersLength; i++) {\n                me.addFilter(filters[i]);\n            }\n        }\n    }",
  "function CreateStringIterator(string) {\n  CHECK_OBJECT_COERCIBLE(string, 'String.prototype[Symbol.iterator]');\n  var s = TO_STRING(string);\n  var iterator = new StringIterator;\n  SET_PRIVATE(iterator, stringIteratorIteratedStringSymbol, s);\n  SET_PRIVATE(iterator, stringIteratorNextIndexSymbol, 0);\n  return iterator;\n}",
  "function yyyymmdd (d, delim) {\n                    if(!(d instanceof Date)) return d;\n                    delim = typeof delim !== 'string' ? '-' : delim ;\n\n                    var dd   = d.getDate(),\n                        mm   = d.getMonth() + 1,\n                        yyyy = d.getFullYear();\n\n                    if(dd < 10) dd = '0' + dd;\n                    if(mm < 10) mm = '0' + mm;\n                    return yyyy + delim + mm + delim + dd;\n                }",
  "function(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0, il = input.length, b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t}",
  "function () {\n    var configString = JSON.stringify(config, null, 2);\n    fs.writeFileSync(configHelpers.getConfigPath(), configString);\n  }",
  "function GedcomXDate(str) {\n\n  if(str == '') {\n    throw new Error('Invalid Date');\n  }\n\n  if(str.charAt(0) == 'R') {\n    return new Recurring(str);\n  } else if(/\\//.test(str)) {\n    return new Range(str);\n  } else if(str.charAt(0) == 'A') {\n    return new Approximate(str);\n  } else {\n    return new Simple(str);\n  }\n}",
  "function findNextOutside(data, items, index, exclude) {\n    var result, positionResult = {start: 0, end: index ? index - 1 : -1};\n\n    do {\n        result = findNext(data, items, positionResult.end + 1);\n    } while (result.index !== -1 && (positionResult = inPosition(result.index, exclude)));\n    return result;\n}",
  "function form(context, value, all) {\n  var dict = context.data\n  var flags = context.flags\n  var alternative\n\n  value = trim(value)\n\n  if (!value) {\n    return null\n  }\n\n  value = normalize(value, context.conversion.in)\n\n  if (exact(context, value)) {\n    if (!all && flag(flags, 'FORBIDDENWORD', dict[value])) {\n      return null\n    }\n\n    return value\n  }\n\n  // Try sentence-case if the value is upper-case.\n  if (value.toUpperCase() === value) {\n    alternative = value.charAt(0) + value.slice(1).toLowerCase()\n\n    if (ignore(flags, dict[alternative], all)) {\n      return null\n    }\n\n    if (exact(context, alternative)) {\n      return alternative\n    }\n  }\n\n  // Try lower-case.\n  alternative = value.toLowerCase()\n\n  if (alternative !== value) {\n    if (ignore(flags, dict[alternative], all)) {\n      return null\n    }\n\n    if (exact(context, alternative)) {\n      return alternative\n    }\n  }\n\n  return null\n}",
  "function(knots) {\n            var firstControlPoints = [];\n            var secondControlPoints = [];\n            var n = knots.length - 1;\n            var i;\n\n            // Special case: Bezier curve should be a straight line.\n            if (n == 1) { \n\t        // 3P1 = 2P0 + P3\n\t        firstControlPoints[0] = point((2 * knots[0].x + knots[1].x) / 3,\n\t                                      (2 * knots[0].y + knots[1].y) / 3);\n\t        // P2 = 2P1 \u2013 P0\n\t        secondControlPoints[0] = point(2 * firstControlPoints[0].x - knots[0].x,\n\t                                       2 * firstControlPoints[0].y - knots[0].y);\n\t        return [firstControlPoints, secondControlPoints];\n            }\n            \n                // Calculate first Bezier control points.\n            // Right hand side vector.\n            var rhs = [];\n            \n            // Set right hand side X values.\n            for (i = 1; i < n - 1; i++) {\n                rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n            }\n            rhs[0] = knots[0].x + 2 * knots[1].x;\n            rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n            // Get first control points X-values.\n            var x = this.getFirstControlPoints(rhs);\n            \n            // Set right hand side Y values.\n            for (i = 1; i < n - 1; ++i) {\n\t        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n            }\n            rhs[0] = knots[0].y + 2 * knots[1].y;\n            rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n            // Get first control points Y-values.\n            var y = this.getFirstControlPoints(rhs);\n            \n            // Fill output arrays.\n            for (i = 0; i < n; i++) {\n\t        // First control point.\n\t        firstControlPoints.push(point(x[i], y[i]));\n\t        // Second control point.\n\t        if (i < n - 1) {\n\t            secondControlPoints.push(point(2 * knots [i + 1].x - x[i + 1],\n                                                   2 * knots[i + 1].y - y[i + 1]));\n\t        } else {\n\t            secondControlPoints.push(point((knots[n].x + x[n - 1]) / 2,\n\t\t\t\t\t           (knots[n].y + y[n - 1]) / 2));\n\t        }\n            }\n            return [firstControlPoints, secondControlPoints];\n        }",
  "function TreeWalker(ast, recv) {\n        var self = this;\n        this.ast = ast;\n        this.recv = recv;\n        this.stack =\n            [{traverse: ast, parent: undefined, name: undefined},\n             {fun: function () {\n                 if (self.hasProp(self.recv, 'finished') &&\n                     Function === self.recv.finished.constructor) {\n                     return self.recv.finished();\n                 }\n             }}];\n        this.current = undefined;\n    }",
  "function getInfoSync(dir) {\r\n  var fullname = path.join(dir, '.epm/CONFIG');\r\n  if (!fs.existsSync(fullname)) {\r\n    return {\r\n      name: 'unknown',\r\n      engine: 'unknown',\r\n      path: dir\r\n    };\r\n  }\r\n\r\n  var info = JSON.parse(fs.readFileSync(fullname, 'utf-8'));\r\n\r\n  return {\r\n      name: info.name || 'unknown',\r\n      engine: info.engine || 'unknown',\r\n      path: dir\r\n    };\r\n}",
  "function(args)\n    {\n      var opts;\n      for (var i=0, l=args.length; i<l; i++) {\n        if (args[i].indexOf(\"settings=\") == 0) {\n          opts = args[i].substr(9);\n          break;\n        }\n        else if (args[i].indexOf(\"'settings=\") == 0) {\n          opts = /'settings\\=(.*?)'/.exec(args[i])[1];\n          break;\n        }\n      }\n      if (opts) {\n        opts = opts.replace(/\\\\\\{/g, \"{\").replace(/\\\\\\}/g, \"}\");\n        opts = qx.lang.Json.parse(opts);\n        for (var prop in opts) {\n          var value = opts[prop];\n          if (typeof value == \"string\") {\n            value = value.replace(/\\$$/g, \" \");\n          }\n          try {\n            qx.core.Environment.add(prop, value);\n          } catch(ex) {\n            this.error(\"Unable to define command-line setting \" + prop + \": \" + ex);\n          }\n        }\n      }\n    }",
  "function openWallet(filename) {\n  try {\n    // Delete the cached copy of the wallet. This allows testing of list-wallets.\n    delete require.cache[require.resolve(filename)]\n\n    const walletInfo = require(filename)\n    return walletInfo\n  } catch (err) {\n    throw new Error(`Could not open ${filename}`)\n  }\n}",
  "function sizeIt(gridSize, sizeEle, sizeScreen = 'xs') {\n  // determine outer size\n  let outerSize = _getOuterSize(gridSize, sizeScreen);\n  // subtract outer from this size\n  let size = sizeEle * grid/outerSize;\n\n  if (size > grid) size = grid;\n  else if (size < 1) size = 1;\n  return Math.round(size);\n}",
  "function nextLine(context, ast, prompt, oldPrompt, forceCursor, eval) {\n    rl.question(prompt, function(answer) {\n        eval(answer, context, ast, forceCursor === -1 ? ast.root.length : forceCursor, function(newPrompt, newCursor) {\n            nextLine(context, ast, newPrompt || oldPrompt, oldPrompt, typeof newCursor === 'undefined' ? -1 : newCursor, eval);\n        });\n    });\n}",
  "function histogram () {\n                    var histogram = {};\n                    libs.object.every(arguments, function (o) {\n                        if(typeof o === 'boolean') {\n                            if(!histogram[o]) histogram[o] = 1; else histogram[o]++;\n                        }\n                        else if(typeof o === 'function') {\n                            if(!histogram['function']) histogram['function'] = 1; else histogram[o]++;\n                        }\n                        else {\n                            libs.object.every(o, function (val) {\n                                switch(true) {\n                                    case typeof val === 'function':\n                                    case typeof val === 'undefined':\n                                        val = typeof val;\n                                        break;\n                                    case typeof val === 'object' && val === null:\n                                        val = 'null';\n                                        break;\n                                    case typeof val === 'object' && val instanceof Array:\n                                        val = 'array';\n                                        break;\n                                    case typeof val === 'object':\n                                        val = 'object';\n                                        break;\n                                    default:\n                                        val = val.toString();\n                                }\n\n                                if(typeof histogram[val] !== 'number') histogram[val] = 0;\n                                histogram[val]++;\n                            });\n                        }\n                    });\n                    return histogram;\n                }",
  "function renderCallback(req, res, template) {\n    return function(err, data) {\n      if (err) {\n        handleError(req, res, err);\n      } else {\n        render(req, res, template, data);\n      }\n    };\n  }",
  "function replacePlaceHolders (array, args) {\n        var out = array.map(function (element) {\n            return ! (element instanceof PlaceHolder) ? element :\n                (args.length > 0 ? args.shift() : element);\n        });\n        return args.length > 0 ? out.concat(args) : out;\n    }",
  "function stdCall(options, call, args, cb) {\n  var val = '';\n\n  for (var key in args) {\n    val += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(args[key]);\n  }\n\n  if (call !== undefined) {\n    call = '?command=' + call;\n  }\n\n  if (call === undefined) {\n    call = '';\n  }\n\n  if (val === undefined) {\n    val = '';\n  }\n\n  http.get({\n    hostname: 'localhost',\n    port: options.httpPort,\n    path: '/requests/status.json' + call + val,\n    auth: ':' + options.httpPassword,\n    agent: false\n  }, function(res) {\n    if (cb !== undefined) {\n      cb(res);\n    }\n  });\n}",
  "function payOmmersAndMiner (cb) {\n    var ommers = block.uncleHeaders\n\n    // pay each ommer\n    async.series([\n      rewardOmmers,\n      rewardMiner\n    ], cb)\n\n    function rewardOmmers (done) {\n      async.each(block.uncleHeaders, function (ommer, next) {\n        // calculate reward\n        var minerReward = new BN(self._common.param('pow', 'minerReward'))\n        var heightDiff = new BN(block.header.number).sub(new BN(ommer.number))\n        var reward = ((new BN(8)).sub(heightDiff)).mul(minerReward.divn(8))\n\n        if (reward.ltn(0)) {\n          reward = new BN(0)\n        }\n\n        rewardAccount(ommer.coinbase, reward, next)\n      }, done)\n    }\n\n    function rewardMiner (done) {\n      // calculate nibling reward\n      var minerReward = new BN(self._common.param('pow', 'minerReward'))\n      var niblingReward = minerReward.divn(32)\n      var totalNiblingReward = niblingReward.muln(ommers.length)\n      var reward = minerReward.add(totalNiblingReward)\n      rewardAccount(block.header.coinbase, reward, done)\n    }\n\n    function rewardAccount (address, reward, done) {\n      self.stateManager.getAccount(address, function (err, account) {\n        if (err) return done(err)\n        // give miner the block reward\n        account.balance = new BN(account.balance).add(reward)\n        self.stateManager.putAccount(address, account, done)\n      })\n    }\n  }",
  "async function(path) {\n      return fs.writeFileAsync(path, JSON.stringify(this.__cache, null, 2), \"UTF-8\")\n        .catch(e => console.error(`Error exporting cache to ${path}:` + e.message));\n    }",
  "function(value) {\r\n\t\t\tvar i, values, typeItem;\r\n\r\n\t\t\t// Find type by checking the classes\r\n\t\t\tvalues = tinymce.explode(value, ' ');\r\n\t\t\tfor (i = 0; i < values.length; i++) {\r\n\t\t\t\ttypeItem = this.lookup[values[i]];\r\n\r\n\t\t\t\tif (typeItem)\r\n\t\t\t\t\treturn typeItem;\r\n\t\t\t}\r\n\t\t}",
  "function processCondition(template, variables, matcher) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matchedCondition = template.match(matcher);\n    if (!matchedCondition) {\n      break;\n    }\n\n    let fragment = matchedCondition[0];\n    let conditionCode = matchedCondition[1];\n\n    let testResult = evaluateCondition(conditionCode, variables);\n    let replaceWith = testResult\n      ? matchedCondition[2]\n      : matchedCondition[3] || '';\n\n    template = template.replace(fragment, replaceWith);\n  }\n\n  return template;\n}",
  "function ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._totalQueuedBytes > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableStreamClose(stream);\n}",
  "function(scores) {\n        var completion = '';\n        // Create mark-up\n        var i = 0;\n        var lastStatus = -1;\n        while (true) {\n            if (lastStatus !== scores[i]) {\n                completion += '<span class=' + scores[i].toString() + '>';\n                lastStatus = scores[i];\n            }\n            completion += this.element.value[i];\n            i++;\n            if (i === this.element.value.length) {\n                completion += '</span>';\n                break;\n            }\n            if (lastStatus !== scores[i]) {\n                completion += '</span>';\n            }\n        }\n\n        return completion;\n    }",
  "function directory_path () {\n      pending++\n      readdir(entry, (err, children) => {\n        if (err) return done(err)\n\n        // Push children into pipeline, order is not important\n        for (var i = children.length; i--;) {\n          if (path !== null && base !== null) {\n            files.push({ base, path: join(path, children[i]) })\n          } else if (path !== null) {\n            files.push({ base: null, path: join(path, children[i]) })\n          } else {\n            files.push({ base, path: children[i] })\n          }\n        }\n\n        // Filter directory out of pipeline after adding children files\n        pending--\n        done(null, null)\n      })\n    }",
  "function (subject, myDocument) {\n    function alternativeRendering () {\n      var sz = UI.rdf.Serializer(UI.store)\n      var res = sz.rootSubjects(sts)\n      var roots = res.roots\n      var p = {}\n      p.render = function (s2) {\n        var div = myDocument.createElement('div')\n        div.setAttribute('class', 'withinDocumentPane')\n        var plist = kb.statementsMatching(s2, undefined, undefined, subject)\n        outliner.appendPropertyTRs(div, plist, false, function (pred, inverse) { return true })\n        return div\n      }\n      for (var i = 0; i < roots.length; i++) {\n        var tr = myDocument.createElement('TR')\n        var root = roots[i]\n        tr.style.verticalAlign = 'top'\n        var td = outliner.outlineObjectTD(root, undefined, tr)\n        tr.appendChild(td)\n        div.appendChild(tr)\n        outliner.outlineExpand(td, root, {'pane': p})\n      }\n    }\n\n    function mainRendering () {\n      var initialRoots = [] // Ordering: start with stuff about this doc\n      if (kb.holds(subject, undefined, undefined, subject)) initialRoots.push(subject)\n      // Then about the primary topic of the document if any\n      var ps = kb.any(subject, UI.ns.foaf('primaryTopic'), undefined, subject)\n      if (ps) initialRoots.push(ps)\n      div.appendChild(panes.dataContents.statementsAsTables(sts, myDocument, initialRoots))\n    }\n\n    var outliner = panes.getOutliner(myDocument)\n    var kb = UI.store\n    var div = myDocument.createElement('div')\n    div.setAttribute('class', 'dataContentPane')\n    // Because of smushing etc, this will not be a copy of the original source\n    // We could instead either fetch and re-parse the source,\n    // or we could keep all the pre-smushed triples.\n    var sts = kb.statementsMatching(undefined, undefined, undefined, subject) // @@ slow with current store!\n\n    if ($rdf.keepThisCodeForLaterButDisableFerossConstantConditionPolice) {\n      alternativeRendering()\n    } else {\n      mainRendering()\n    }\n    return div\n  }",
  "function isBinFile(filePath, binField, basedir) {\n    if (!binField) {\n        return false\n    }\n    if (typeof binField === \"string\") {\n        return filePath === path.resolve(basedir, binField)\n    }\n    return Object.keys(binField).some(\n        key => filePath === path.resolve(basedir, binField[key])\n    )\n}",
  "function(value){\n\t\t/*#if BROWSER*/ if(this._label) this._label.text(value); else /*#/if*/\n\t\tthis._label=$.create('label').attr('for',this.getAttr('id'))/*#if BROWSER*/.prependTo(this._container)/*#/if*/.text(value);\n\t\treturn this;\n\t}",
  "function resetStyles(stack) {\n    var stackClone = stack.slice(0);\n\n    stack.length = 0;\n\n    return stackClone.reverse().map(function (tag) {\n        return '</' + tag + '>';\n    }).join('');\n}",
  "function baseGetTag$1(value) {\n\t  if (value == null) {\n\t    return value === undefined ? undefinedTag$1 : nullTag$1;\n\t  }\n\t  return (symToStringTag$2 && symToStringTag$2 in Object(value))\n\t    ? _getRawTag(value)\n\t    : _objectToString(value);\n\t}",
  "function invokeConfigFn(tasks) {\n    for (var taskName in tasks) {\n      if (tasks.hasOwnProperty(taskName)) {\n        tasks[taskName](grunt);\n      }\n    }\n  }",
  "function getMaxZoomRatio(pointers) {\n  var pointers2 = assign({}, pointers);\n  var ratios = [];\n  forEach(pointers, function (pointer, pointerId) {\n    delete pointers2[pointerId];\n    forEach(pointers2, function (pointer2) {\n      var x1 = Math.abs(pointer.startX - pointer2.startX);\n      var y1 = Math.abs(pointer.startY - pointer2.startY);\n      var x2 = Math.abs(pointer.endX - pointer2.endX);\n      var y2 = Math.abs(pointer.endY - pointer2.endY);\n      var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n      var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n      var ratio = (z2 - z1) / z1;\n      ratios.push(ratio);\n    });\n  });\n  ratios.sort(function (a, b) {\n    return Math.abs(a) < Math.abs(b);\n  });\n  return ratios[0];\n}",
  "async function(repo_name, library_name) {\n      let library = (await this.getContribData()).libraries.find(lib => lib.repo_name === repo_name && lib.library_name === library_name);\n      return library ? library.repo_tag : false;\n    }",
  "function(data, merges) {\n      var ws = {};\n      var range = { s: { c: 10000000, r: 10000000 }, e: { c: 0, r: 0 } };\n      var types = this.typeConfig;\n      for (var R = 0; R !== data.length; ++R) {\n        for (var C = 0; C !== data[R].length; ++C) {\n          if (range.s.r > R) range.s.r = R;\n          if (range.s.c > C) range.s.c = C;\n          if (range.e.r < R) range.e.r = R;\n          if (range.e.c < C) range.e.c = C;\n          var cell = data[R][C];\n          if (!cell || !cell.v) continue;\n          var cell_ref = XLSX.utils.encode_cell({ c: C, r: R });\n\n          if (!cell.t) {\n            if (types.number.assert(cell.v)) cell.t = _TYPE.NUMBER;\n            else if (types.boolean.assert(cell.v)) cell.t = _TYPE.BOOLEAN;\n            else if (types.date.assert(cell.v)) cell.t = _TYPE.DATE;\n            else cell.t = _TYPE.STRING;\n          }\n          if (cell.t === _TYPE.DATE) {\n            cell.t = _TYPE.NUMBER;\n            cell.z = XLSX.SSF._table[14];\n            cell.v = this.dateNum(cell.v);\n          }\n          ws[cell_ref] = cell;\n        }\n      }\n      ws[\"!merges\"] = merges;\n      if (range.s.c < 10000000) ws[\"!ref\"] = XLSX.utils.encode_range(range);\n      return ws;\n    }",
  "function initProcessor(options = {}, defaultBabelProcessorName) {\n    let {js, css, tpl, wxs} = options;\n\n    if (tpl !== false) {\n        initTplProcessor(tpl);\n    }\n\n    if (css !== false) {\n        initStyleProcessor(css);\n    }\n\n    if (js !== false) {\n        initJsProcessor(js, defaultBabelProcessorName);\n    }\n\n    if (wxs !== false) {\n        initWxsProcessor(js, defaultBabelProcessorName);\n    }\n}",
  "function splitParagraphIntoLines(text, maxlen, options) {\n    // at this time works only on Western scripts, ones with space char\n    // separating the words. Feel free to expand.\n    if (!options) {\n      options = {};\n    }\n\n    var line = [],\n        lines = [line],\n        line_length = options.textIndent || 0,\n        separator_length = 0,\n        current_word_length = 0,\n        word,\n        widths_array,\n        words = text.split(' '),\n        spaceCharWidth = getCharWidthsArray.apply(this, [' ', options])[0],\n        i,\n        l,\n        tmp,\n        lineIndent;\n\n    if (options.lineIndent === -1) {\n      lineIndent = words[0].length + 2;\n    } else {\n      lineIndent = options.lineIndent || 0;\n    }\n\n    if (lineIndent) {\n      var pad = Array(lineIndent).join(\" \"),\n          wrds = [];\n      words.map(function (wrd) {\n        wrd = wrd.split(/\\s*\\n/);\n\n        if (wrd.length > 1) {\n          wrds = wrds.concat(wrd.map(function (wrd, idx) {\n            return (idx && wrd.length ? \"\\n\" : \"\") + wrd;\n          }));\n        } else {\n          wrds.push(wrd[0]);\n        }\n      });\n      words = wrds;\n      lineIndent = getStringUnitWidth.apply(this, [pad, options]);\n    }\n\n    for (i = 0, l = words.length; i < l; i++) {\n      var force = 0;\n      word = words[i];\n\n      if (lineIndent && word[0] == \"\\n\") {\n        word = word.substr(1);\n        force = 1;\n      }\n\n      widths_array = getCharWidthsArray.apply(this, [word, options]);\n      current_word_length = getArraySum(widths_array);\n\n      if (line_length + separator_length + current_word_length > maxlen || force) {\n        if (current_word_length > maxlen) {\n          // this happens when you have space-less long URLs for example.\n          // we just chop these to size. We do NOT insert hiphens\n          tmp = splitLongWord.apply(this, [word, widths_array, maxlen - (line_length + separator_length), maxlen]); // first line we add to existing line object\n\n          line.push(tmp.shift()); // it's ok to have extra space indicator there\n          // last line we make into new line object\n\n          line = [tmp.pop()]; // lines in the middle we apped to lines object as whole lines\n\n          while (tmp.length) {\n            lines.push([tmp.shift()]); // single fragment occupies whole line\n          }\n\n          current_word_length = getArraySum(widths_array.slice(word.length - (line[0] ? line[0].length : 0)));\n        } else {\n          // just put it on a new line\n          line = [word];\n        } // now we attach new line to lines\n\n\n        lines.push(line);\n        line_length = current_word_length + lineIndent;\n        separator_length = spaceCharWidth;\n      } else {\n        line.push(word);\n        line_length += separator_length + current_word_length;\n        separator_length = spaceCharWidth;\n      }\n    }\n\n    if (lineIndent) {\n      var postProcess = function postProcess(ln, idx) {\n        return (idx ? pad : '') + ln.join(\" \");\n      };\n    } else {\n      var postProcess = function postProcess(ln) {\n        return ln.join(\" \");\n      };\n    }\n\n    return lines.map(postProcess);\n  }",
  "function loadPartials(files, metalsmith, done) {\n  var metadata = metalsmith.metadata();\n  \n  fs.readdirAsync(\"./partials\", \"utf8\")\n    .then(files => {\n      var promises = files.map(filename => {\n        var m = filename.match(/^(.+)\\.([^.]+)$/);\n        if (!m)\n          return;\n        var name = m[1];\n        var ext = m[2];\n        return fs.readFileAsync(\"partials/\" + filename, \"utf8\")\n          .then(data => {\n            var fn;\n            try {\n              fn = dot.template(data);\n            }catch(err) {\n              console.log(\"Failed to load partial \" + filename + \": \" + err);\n              return;\n            }\n            fn.name = filename;\n            metadata.partials[filename] = fn;\n            if (ext == \"html\")\n              metadata.partials[name] = fn; \n          });\n      });\n      return Promise.all(promises);\n    })\n    .then(() => done())\n    .catch(err => done(err));\n}",
  "function WordCombination( words, occurrences, functionWords ) {\n\tthis._words = words;\n\tthis._length = words.length;\n\tthis._occurrences = occurrences || 0;\n\tthis._functionWords = functionWords;\n}",
  "function replace (regex, replacement, fileFilter) {\n  if (fileFilter instanceof Array) {\n    fileFilter = fileFilter.reduce(pcomp);\n  } else if (!fileFilter) {\n    fileFilter = () => true;\n  }\n  return files => {\n    _.forEach(files, (file, path) => {\n      if (fileFilter(file, path)) {\n        file.contents = new Buffer(file.contents.toString().replace(regex, replacement));\n      }\n    });\n  }\n}",
  "function hookSync(rs) {\n  if (rs._dropboxOrigSync) { return; } // already hooked\n  rs._dropboxOrigSync = rs.sync.sync.bind(rs.sync);\n  rs.sync.sync = function () {\n    return this.dropbox.fetchDelta.apply(this.dropbox, arguments).\n      then(rs._dropboxOrigSync, function (err) {\n        rs._emit('error', new Sync.SyncError(err));\n        rs._emit('sync-done');\n      });\n  }.bind(rs);\n}",
  "function() {\n            var args = slice.call(arguments),\n                array = [],\n                i, ln;\n\n            for (i = 0, ln = args.length; i < ln; i++) {\n                array = array.concat(args[i]);\n            }\n\n            return ExtArray.unique(array);\n        }",
  "function flushDeferredPadding(blocks) {\n                if (!padding)\n                    return;\n                let prevBlock = blocks[blocks.length - 2];\n                prevBlock.text += padding;\n            }",
  "function (runState) {\n    const [offset, length] = runState.stack.popN(2)\n    subMemUsage(runState, offset, length)\n    let data = Buffer.alloc(0)\n    if (!length.isZero()) {\n      data = runState.memory.read(offset.toNumber(), length.toNumber())\n    }\n    // copy fee\n    subGas(runState, new BN(runState._common.param('gasPrices', 'sha3Word')).imul(length.divCeil(new BN(32))))\n    const r = new BN(utils.keccak256(data))\n    runState.stack.push(r)\n  }",
  "function insertBefore(parent, child, index) {\n            var parentEl = parent.el,\n                childEl = child.el;\n            if (parentEl !== undefined && childEl !== undefined) {\n                if (parentEl.childNodes[index] !== undefined) {\n                    parentEl.insertBefore(childEl, parentEl.childNodes[index]);\n                } else {\n                    parentEl.appendChild(childEl);\n                }\n            }\n        }",
  "function generate(context, memory, words, edits) {\n  var characters = context.flags.TRY\n  var characterLength = characters.length\n  var data = context.data\n  var flags = context.flags\n  var result = []\n  var upper\n  var length\n  var index\n  var word\n  var position\n  var count\n  var before\n  var after\n  var nextAfter\n  var nextNextAfter\n  var character\n  var nextCharacter\n  var inject\n  var offset\n\n  // Check the pre-generated edits.\n  length = edits && edits.length\n  index = -1\n\n  while (++index < length) {\n    check(edits[index], true)\n  }\n\n  // Iterate over given word.\n  length = words.length\n  index = -1\n\n  while (++index < length) {\n    word = words[index]\n\n    before = ''\n    character = ''\n    nextAfter = word\n    nextNextAfter = word.slice(1)\n    nextCharacter = word.charAt(0)\n    position = -1\n    count = word.length + 1\n\n    // Iterate over every character (including the end).\n    while (++position < count) {\n      before += character\n      after = nextAfter\n      nextAfter = nextNextAfter\n      nextNextAfter = nextAfter.slice(1)\n      character = nextCharacter\n      nextCharacter = word.charAt(position + 1)\n      upper = character.toLowerCase() !== character\n\n      // Remove.\n      check(before + nextAfter)\n\n      // Switch.\n      if (nextAfter) {\n        check(before + nextCharacter + character + nextNextAfter)\n      }\n\n      // Iterate over all possible letters.\n      offset = -1\n\n      while (++offset < characterLength) {\n        inject = characters[offset]\n\n        // Add and replace.\n        check(before + inject + after)\n        check(before + inject + nextAfter)\n\n        // Try upper-case if the original character was upper-cased.\n        if (upper) {\n          inject = inject.toUpperCase()\n\n          check(before + inject + after)\n          check(before + inject + nextAfter)\n        }\n      }\n    }\n  }\n\n  // Return the list of generated words.\n  return result\n\n  // Check and handle a generated value.\n  function check(value, double) {\n    var state = memory.state[value]\n    var corrected\n\n    if (state !== Boolean(state)) {\n      result.push(value)\n\n      corrected = form(context, value)\n      state = corrected && !flag(flags, noSuggestType, data[corrected])\n\n      memory.state[value] = state\n\n      if (state) {\n        memory.weighted[value] = double ? 10 : 0\n        memory.suggestions.push(value)\n      }\n    }\n\n    if (state) {\n      memory.weighted[value]++\n    }\n  }\n}",
  "function baseIsTypedArray(value) {\n  return isObjectLike$1(value) && isLength(value.length) && !!typedArrayTags[objectToString$1.call(value)];\n}",
  "function transformConstraintViolationMessages (input) {\n    return {\n        validationErrors: _.chain(input.details)\n    .mapKeys(function(v, k) {\n\t  // Use '.' as the key if the entire object is erroneous\n      return (input.details.length == 1 && input.details[0].path === 'value' && input.details[0].type === 'object.base') ? '.' : v.path\n    })\n    .mapValues(function (v) {\n            return {\n        attributes: _.chain(v.context)\n        .pickBy(function(v, k) {\n          return typeof v !== 'undefined' && v !== null && k !== 'key'\n        })\n        .mapValues(function(i) {\n          return i.toString()\n        }),\n        constraintClassName: v.type,\n        invalidValue: v.context.value,\n                messageTemplate: v.type,\n            }\n        })\n    }\n}",
  "function createClass() {\n  var mixins, definition;\n  switch(arguments.length) {\n    case 0:\n      throw new Error('class definition required');\n      break;\n    case 1:\n      mixins = [];\n      definition = arguments[0];\n      break;\n    default:\n      mixins = arguments[0];\n      definition = arguments[1];\n      break;\n  }\n\n  var newclass = definition['constructor'];\n\n  if(typeof newclass !== 'function')\n    throw new Error('constructor function required');\n\n  if(typeof newclass.name === 'string' && newclass.name.length === 0)\n    throw new Error('constructor name required, it will be used as new class name');\n\n  newclass.prototype = definition;\n  newclass.prototype.instanceOf = instanceOf;\n  newclass.prototype.Super = superMethod;\n\n  // if no mixin given, just create a base class\n  if(!mixins) return newclass;\n\n  if(Array.isArray(mixins)) {\n    // multi inheritance, if mixins is an array of base classes\n    for(var i=mixins.length-1; i>=0; i--) {\n      newclass = mixin(newclass, mixins[i]);\n    }\n    return newclass;\n\n  } else {\n    // single inheritance\n    return mixin(newclass, mixins);\n  }\n}",
  "function() {\n         var me = this,\n             count = 0;\n\n         me.view.refresh();\n         // reset the statusbar\n         me.statusBar.setStatus({\n             text: me.defaultStatusText,\n             iconCls: ''\n         });\n\n         me.searchValue = me.getSearchValue();\n         me.indexes = [];\n         me.currentIndex = null;\n\n         if (me.searchValue !== null) {\n             me.searchRegExp = new RegExp(me.searchValue, 'g' + (me.caseSensitive ? '' : 'i'));\n             \n             \n             me.store.each(function(record, idx) {\n                 var td = Ext.fly(me.view.getNode(idx)).down('td'),\n                     cell, matches, cellHTML;\n                 while(td) {\n                     cell = td.down('.x-grid-cell-inner');\n                     matches = cell.dom.innerHTML.match(me.tagsRe);\n                     cellHTML = cell.dom.innerHTML.replace(me.tagsRe, me.tagsProtect);\n                     \n                     // populate indexes array, set currentIndex, and replace wrap matched string in a span\n                     cellHTML = cellHTML.replace(me.searchRegExp, function(m) {\n                        count += 1;\n                        if (Ext.Array.indexOf(me.indexes, idx) === -1) {\n                            me.indexes.push(idx);\n                        }\n                        if (me.currentIndex === null) {\n                            me.currentIndex = idx;\n                        }\n                        return '<span class=\"' + me.matchCls + '\">' + m + '</span>';\n                     });\n                     // restore protected tags\n                     Ext.each(matches, function(match) {\n                        cellHTML = cellHTML.replace(me.tagsProtect, match); \n                     });\n                     // update cell html\n                     cell.dom.innerHTML = cellHTML;\n                     td = td.next();\n                 }\n             }, me);\n\n             // results found\n             if (me.currentIndex !== null) {\n                 me.getSelectionModel().select(me.currentIndex);\n                 me.statusBar.setStatus({\n                     text: count + ' matche(s) found.',\n                     iconCls: 'x-status-valid'\n                 });\n             }\n         }\n\n         // no results found\n         if (me.currentIndex === null) {\n             me.getSelectionModel().deselectAll();\n         }\n\n         // force textfield focus\n         me.textField.focus();\n     }",
  "function floodlightUserParams() {\n\tconst params = {};\n\n\tconst currentUser = user.get();\n\tif ( currentUser ) {\n\t\tparams.u4 = hashPii( currentUser.ID );\n\t}\n\n\tconst anonymousUserId = tracksAnonymousUserId();\n\tif ( anonymousUserId ) {\n\t\tparams.u5 = anonymousUserId;\n\t}\n\n\treturn params;\n}",
  "function loadRcConfig(callback) {\n  const sync = typeof callback !== 'function';\n\n  if (sync) {\n    const fp = rcLoader.for(this.resourcePath);\n    if (typeof fp !== 'string') {\n      // no .jshintrc found\n      return {};\n    }\n    this.addDependency(fp);\n    const options = loadConfig(fp);\n    delete options.dirname;\n    return options;\n  }\n\n  // eslint-disable-next-line consistent-return\n  rcLoader.for(this.resourcePath, (err, fp) => {\n    if (typeof fp !== 'string') {\n      // no .jshintrc found\n      return callback(null, {});\n    }\n\n    this.addDependency(fp);\n    const options = loadConfig(fp);\n    delete options.dirname;\n    callback(err, options);\n  });\n}",
  "function(from, to) {\n      return new Promise((resolve, reject) => {\n        util.mkParentPath(to, function() {\n          var rs = fs.createReadStream(from, { flags: \"r\", encoding: \"binary\" });\n          var ws = fs.createWriteStream(to, { flags: \"w\", encoding: \"binary\" });\n          rs.on(\"end\", function() {\n            resolve();\n          });\n          rs.on(\"error\", reject);\n          ws.on(\"error\", reject);\n          rs.pipe(ws);\n        });\n      });\n    }",
  "function authenticate ({username, password, clientToken, agent}) {\n  return fetch(`${YGGDRASIL_API}/authenticate`, {\n    method: 'POST',\n    body: JSON.stringify({\n      agent,\n      username,\n      password,\n      clientToken,\n      requestUser: true\n    }),\n    headers: {\n      'user-agent': USER_AGENT,\n      'Content-Type': 'application/json',\n      'accept': 'application/json'\n    }\n  })\n    .then(handleErrors)\n    .then(res => res.json())\n}",
  "function filterNoticesBy( site, pluginSlug, log ) {\n\tif ( ! site && ! pluginSlug ) {\n\t\treturn true;\n\t}\n\tif ( isSameSiteNotice( site, log ) && isSamePluginNotice( pluginSlug, log ) ) {\n\t\treturn true;\n\t} else if ( ! pluginSlug && isSameSiteNotice( site, log ) ) {\n\t\treturn true;\n\t} else if ( ! site && isSamePluginNotice( pluginSlug, log ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}",
  "function parseForwarded(value) {\n  const forwarded = {}\n\n  value.trim().split(';').forEach((part) => {\n    const pair = part.trim().split('=');\n    forwarded[pair[0]] = pair[1];\n  });\n\n  return forwarded;\n}",
  "function orderBy(keySelector, comparison) {\r\n    const trueKeySelector = keySelector || defaultKeySelector;\r\n    const trueComparison = comparison || defaultComparison;\r\n    return function (item) {\r\n        return __asyncGenerator(this, arguments, function* () {\r\n            var e_25, _a;\r\n            const keyedMapper = map((item, index) => ({ item, key: trueKeySelector(item, index) }));\r\n            const keyed = keyedMapper(item);\r\n            const keyedArray = yield __await(toWriteableArray(keyed));\r\n            keyedArray.sort((a, b) => trueComparison(a.key, b.key));\r\n            try {\r\n                for (var keyedArray_1 = __asyncValues(keyedArray), keyedArray_1_1; keyedArray_1_1 = yield __await(keyedArray_1.next()), !keyedArray_1_1.done;) {\r\n                    const { item } = keyedArray_1_1.value;\r\n                    yield yield __await(item);\r\n                }\r\n            }\r\n            catch (e_25_1) { e_25 = { error: e_25_1 }; }\r\n            finally {\r\n                try {\r\n                    if (keyedArray_1_1 && !keyedArray_1_1.done && (_a = keyedArray_1.return)) yield __await(_a.call(keyedArray_1));\r\n                }\r\n                finally { if (e_25) throw e_25.error; }\r\n            }\r\n        });\r\n    };\r\n}",
  "function() {\n          if ((cachedWidth = element.offsetWidth) != lastWidth || (cachedHeight = element.offsetHeight) != lastHeight) {\n              dirty = true;\n\n              lastWidth = cachedWidth;\n              lastHeight = cachedHeight;\n          }\n          reset();\n        }",
  "function parseTplDataInfo(value) {\n    value = value.substring(1, value.length - 1);\n    let items = value.split(',');\n    let dataObjAttrs = {};\n    items.forEach(item => {\n        let colonIdx = item.indexOf(':');\n        if (colonIdx !== -1) {\n            let key = item.substring(0, colonIdx).trim();\n            let value = item.substr(colonIdx + 1).trim();\n\n            key === value || (dataObjAttrs[key] = value);\n        }\n    });\n\n    return Object.keys(dataObjAttrs).length ? dataObjAttrs : null;\n}",
  "function reportItem(node, name, info) {\n            context.report({\n                node,\n                loc: node.loc,\n                message:\n                    \"{{name}} was deprecated since v{{version}}{{replace}}.\",\n                data: {\n                    name,\n                    version: info.since,\n                    replace: toReplaceMessage(info.replacedBy),\n                },\n            })\n        }",
  "function _full_delete(hash, key1, key2){\n\t    if( key1 && key2 && hash &&\n\t\thash[key1] && hash[key1][key2] ){\n\t\t    delete hash[key1][key2];\n\t\t}\n\t    if( us.isEmpty(hash[key1]) ){\n\t\tdelete hash[key1];\n\t    }\n\t}",
  "function (req, cb) {\n        let criteria = {\n            \"clientId\": req.soajs.inputmaskData.clientId\n        };\n        let combo = {\n            collection: tokenCollectionName,\n            condition: criteria\n        };\n        libProduct.model.removeEntry(req.soajs, combo, function (error, result) {\n            let data = {config: req.soajs.config, error: error, code: 404};\n            checkIfError(req, cb, data, function () {\n                return cb(null, result.result);\n            });\n        });\n    }",
  "function _objectCopy(sourceRef, copyRef, rc) {\r\n    let origIndex = rc.xStack.indexOf(sourceRef);\r\n    if (origIndex === -1) {\r\n        rc.push(sourceRef, copyRef);\r\n        for (let [key, val] of _entries(sourceRef))\r\n            copyRef[key] = _clone(val, rc);\r\n        let symbols = Object.getOwnPropertySymbols(sourceRef);\r\n        for (let symbol of symbols)\r\n            copyRef[symbol] = _clone(sourceRef[symbol], rc);\r\n        rc.pop();\r\n        return copyRef;\r\n    }\r\n    else\r\n        return rc.yStack[origIndex];\r\n}",
  "function hashDelete$3(key) {\n\t  var result = this.has(key) && delete this.__data__[key];\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}",
  "function (docular_webapp_target) {\n        var ABS_SCRIPTS = __dirname;\n        var ABS_LIB = path.resolve(ABS_SCRIPTS + '/..');\n        var ABS_DEFAULT_GENERATED_WEBAPP = ABS_LIB + '/generated/';\n        return docular_webapp_target ? path.resolve(process.cwd() + '/' + docular_webapp_target) : path.relative(process.cwd(), ABS_DEFAULT_GENERATED_WEBAPP);\n    }",
  "function stdopts (opts) {\n  opts = opts || {}\n  opts.keys = opts.keys !== false // default keys to true\n  opts.values = opts.values !== false // default values to true\n  return opts\n}",
  "function compareDate(d, find, buffer, forceUTC) {\n    var p, t, min, max, minOffset, maxOffset, override, capitalized, accuracy = 0, loBuffer = 0, hiBuffer = 0;\n    p = getExtendedDate(find, null, null, forceUTC);\n    if(buffer > 0) {\n      loBuffer = hiBuffer = buffer;\n      override = true;\n    }\n    if(!p.date.isValid()) return false;\n    if(p.set && p.set.specificity) {\n      DateUnits.forEach(function(u, i) {\n        if(u.unit === p.set.specificity) {\n          accuracy = u.multiplier(p.date, d - p.date) - 1;\n        }\n      });\n      capitalized = simpleCapitalize(p.set.specificity);\n      if(p.set['edge'] || p.set['shift']) {\n        p.date['beginningOf' + capitalized]();\n      }\n      if(p.set.specificity === 'month') {\n        max = p.date.clone()['endOf' + capitalized]().getTime();\n      }\n      if(!override && p.set['sign'] && p.set.specificity != 'millisecond') {\n        // If the time is relative, there can occasionally be an disparity between the relative date\n        // and \"now\", which it is being compared to, so set an extra buffer to account for this.\n        loBuffer = 50;\n        hiBuffer = -50;\n      }\n    }\n    t   = d.getTime();\n    min = p.date.getTime();\n    max = max || (min + accuracy);\n    max = compensateForTimezoneTraversal(d, min, max);\n    return t >= (min - loBuffer) && t <= (max + hiBuffer);\n  }",
  "function getStacks(req, res) {\n    var data = {};\n    async.auto({\n      stacks: function(callback) {\n        dreadnot.getStackSummaries(function(err, stacks) {\n          data.stacks = stacks;\n          callback(err);\n        });\n      },\n\n      regions: ['stacks', function(callback) {\n        async.forEach(data.stacks, function(stack, callback) {\n          dreadnot.getRegionSummaries(stack.name, function(err, regions) {\n            if (err) {\n              callback(err);\n              return;\n            }\n\n            stack.regions = regions;\n            async.forEach(stack.regions, function(region, callback) {\n              // TODO: Should this go in dreadnot.js or stack.js maybe?\n              if (region.latest_deployment === '0') {\n                region.latest_deployment = null;\n                callback();\n                return;\n              }\n              dreadnot.getDeploymentSummary(stack.name, region.name, region.latest_deployment, function(err, deployment) {\n                region.latest_deployment = deployment;\n                callback(err);\n              });\n            }, callback);\n          });\n        }, callback);\n      }],\n    }, function(err) {\n      renderCallback(req, res, 'stacks.jade')(err, data);\n    });\n  }",
  "function jsonCommand(shell, args, data, evaluationId) {\n  return dataCommand(shell, args, data, evaluationId, function(value) {\n    return JSON.parse(value);\n  });\n}",
  "function readImports(imports, data) {\n\n\treturn (imports.length === 0) ? Promise.resolve([imports, data]) : new Promise((resolve, reject) => {\n\n\t\tlet i = 0;\n\n\t\t(function proceed(error, importData) {\n\n\t\t\tif(importData) {\n\n\t\t\t\timports[i++].data = importData;\n\n\t\t\t}\n\n\t\t\tif(error) {\n\n\t\t\t\treject(error);\n\n\t\t\t} else if(i === imports.length) {\n\n\t\t\t\tresolve([imports, data]);\n\n\t\t\t} else {\n\n\t\t\t\tfs.readFile(imports[i].path, imports[i].encoding, proceed);\n\n\t\t\t}\n\n\t\t}());\n\n\t});\n\n}",
  "function _getTransferable(item, view, id) {\n        // 1. If view supports getTransferable, use that\n        if (view.getTransferable) {\n            return view.getTransferable(id);\n        }\n        // 2. If view is derived from layoutcontroller, use that\n        if (view.getSpec && view.get && view.replace) {\n            if (view.get(id) !== undefined) {\n                return {\n                    get: function() {\n                        return view.get(id);\n                    },\n                    show: function(renderable) {\n                        view.replace(id, renderable);\n                    },\n                    getSpec: _getViewSpec.bind(this, item, view, id)\n                };\n            }\n        }\n        // 3. If view has an embedded layout, use that as fallback\n        if (view.layout) {\n            return _getTransferable.call(this, item, view.layout, id);\n        }\n    }",
  "function FontLoader(fontFamiliesArray, delegate, timeout) {\n\t\t// Public\n\t\tthis.delegate = delegate;\n\t\tthis.timeout = (typeof timeout !== \"undefined\") ? timeout : 3000;\n\n\t\t// Private\n\t\tthis._fontFamiliesArray = fontFamiliesArray.slice(0);\n\t\tthis._testContainer = null;\n\t\tthis._adobeBlankSizeWatcher = null;\n\t\tthis._timeoutId = null;\n\t\tthis._intervalId = null;\n\t\tthis._intervalDelay = 50;\n\t\tthis._numberOfLoadedFonts = 0;\n\t\tthis._numberOfFontFamilies = this._fontFamiliesArray.length;\n\t\tthis._fontsMap = {};\n\t\tthis._finished = false;\n\t}",
  "function processFile(file) {\n\t\tvar changed = true;\n\n\t\twhile(changed && !file.processed) {\n\t\t\tchanged = false;\n\t\t\tchanged = processWraps(file);\n\t\t\tchanged = processInserts(file);\n\t\t}\n\t\tfile.processed = true;\n\t}",
  "function processAppSpecifiedDeclaration(allAppTypes, appType, decl) {\n    let {prop, parent} = decl;\n    let result;\n    if ((result = SPECIFIED_APP_PROP_DECL_REGEXP.exec(prop))) {\n        let propApp = result[1];\n        let isMatchApp = appType === propApp;\n        if (allAppTypes.includes(propApp) && !isMatchApp) {\n            // remove not current app build type style declaration\n            decl.remove();\n        }\n        else if (isMatchApp) {\n            // remove the previous property style declaration that has same\n            // style property name declaration that ignore app type prefix\n            // and remove the specified app type prefix of the property\n            let newPropName = prop.replace(SPECIFIED_APP_PROP_DECL_REGEXP, '');\n            removeUnUseDecl(decl, newPropName);\n            decl.prop = newPropName;\n        }\n\n        // remove empty rule\n        if (!parent.nodes || !parent.nodes.length) {\n            parent.remove();\n        }\n    }\n}",
  "function parseAll (data) {\n  if (!data || !data[0]) {\n    return []\n  }\n\n  if (process.platform.includes('linux')) {\n    var rows = data[0].split('\\n')\n    return rows.map(function (row) {\n      return parseLinux(row, servers)\n    }).filter(Boolean)\n  } else if (process.platform.includes('win32')) {\n    var winRows = data[0].split('\\n').splice(1)\n    return winRows.map(function (row) {\n      return parseWin32(row, servers)\n    }).filter(Boolean)\n  }\n\n  return data[0]\n    .trim()\n    .split('\\n')\n    .map(function (row) {\n      return parseRow(row, servers)\n    })\n    .filter(Boolean)\n}",
  "function getTemplateName(data) {\n        for (var i = 0; i < templateAttribute.length; ++i) {\n            if (!data) return null;\n            data = data[templateAttribute[i]];\n        }\n        return data;\n    }",
  "function getServers () {\n  var interfaces = os.networkInterfaces()\n  var result = []\n\n  for (var key in interfaces) {\n    var addresses = interfaces[key]\n    for (var i = addresses.length; i--;) {\n      var address = addresses[i]\n      if (address.family === 'IPv4' && !address.internal) {\n        var subnet = ip.subnet(address.address, address.netmask)\n        var current = ip.toLong(subnet.firstAddress)\n        var last = ip.toLong(subnet.lastAddress) - 1\n        while (current++ < last) result.push(ip.fromLong(current))\n      }\n    }\n  }\n\n  return result\n}",
  "function moveSelection() {\r\n\t\t\tvar nonEditableStart, nonEditableEnd, isCollapsed, rng, element;\r\n\r\n\t\t\t// Checks if there is any contents to the left/right side of caret returns the noneditable element or any editable element if it finds one inside\r\n\t\t\tfunction hasSideContent(element, left) {\r\n\t\t\t\tvar container, offset, walker, node, len;\r\n\r\n\t\t\t\tcontainer = rng.startContainer;\r\n\t\t\t\toffset = rng.startOffset;\r\n\r\n\t\t\t\t// If endpoint is in middle of text node then expand to beginning/end of element\r\n\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\tlen = container.nodeValue.length;\r\n\t\t\t\t\tif ((offset > 0 && offset < len) || (left ? offset == len : offset == 0)) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Can we resolve the node by index\r\n\t\t\t\t\tif (offset < container.childNodes.length) {\r\n\t\t\t\t\t\t// Browser represents caret position as the offset at the start of an element. When moving right\r\n\t\t\t\t\t\t// this is the element we are moving into so we consider our container to be child node at offset-1\r\n\t\t\t\t\t\tvar pos = !left && offset > 0 ? offset-1 : offset;\r\n\t\t\t\t\t\tcontainer = container.childNodes[pos];\r\n\t\t\t\t\t\tif (container.hasChildNodes()) {\r\n\t\t\t\t\t\t\tcontainer = container.firstChild;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// If not then the caret is at the last position in it's container and the caret container should be inserted after the noneditable element\r\n\t\t\t\t\t\treturn !left ? element : null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Walk left/right to look for contents\r\n\t\t\t\twalker = new TreeWalker(container, element);\r\n\t\t\t\twhile (node = walker[left ? 'prev' : 'next']()) {\r\n\t\t\t\t\tif (node.nodeType === 3 && node.nodeValue.length > 0) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else if (getContentEditable(node) === \"true\") {\r\n\t\t\t\t\t\t// Found contentEditable=true element return this one to we can move the caret inside it\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn element;\r\n\t\t\t};\r\n\r\n\t\t\t// Remove any existing caret containers\r\n\t\t\tremoveCaretContainer();\r\n\r\n\t\t\t// Get noneditable start/end elements\r\n\t\t\tisCollapsed = selection.isCollapsed();\r\n\t\t\tnonEditableStart = getNonEditableParent(selection.getStart());\r\n\t\t\tnonEditableEnd = getNonEditableParent(selection.getEnd());\r\n\r\n\t\t\t// Is any fo the range endpoints noneditable\r\n\t\t\tif (nonEditableStart || nonEditableEnd) {\r\n\t\t\t\trng = selection.getRng(true);\r\n\r\n\t\t\t\t// If it's a caret selection then look left/right to see if we need to move the caret out side or expand\r\n\t\t\t\tif (isCollapsed) {\r\n\t\t\t\t\tnonEditableStart = nonEditableStart || nonEditableEnd;\r\n\t\t\t\t\tvar start = selection.getStart();\r\n\t\t\t\t\tif (element = hasSideContent(nonEditableStart, true)) {\r\n\t\t\t\t\t\t// We have no contents to the left of the caret then insert a caret container before the noneditable element\r\n\t\t\t\t\t\tinsertCaretContainerOrExpandToBlock(element, true);\r\n\t\t\t\t\t} else if (element = hasSideContent(nonEditableStart, false)) {\r\n\t\t\t\t\t\t// We have no contents to the right of the caret then insert a caret container after the noneditable element\r\n\t\t\t\t\t\tinsertCaretContainerOrExpandToBlock(element, false);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// We are in the middle of a noneditable so expand to select it\r\n\t\t\t\t\t\tselection.select(nonEditableStart);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng = selection.getRng(true);\r\n\r\n\t\t\t\t\t// Expand selection to include start non editable element\r\n\t\t\t\t\tif (nonEditableStart) {\r\n\t\t\t\t\t\trng.setStartBefore(nonEditableStart);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Expand selection to include end non editable element\r\n\t\t\t\t\tif (nonEditableEnd) {\r\n\t\t\t\t\t\trng.setEndAfter(nonEditableEnd);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
  "function parse(resource) {\n  if (typeof resource === 'object') return resource;\n\n  var config = url.parse(resource);\n\n  return {\n    port: config.port,\n    device: config.auth,\n    gateway: config.hostname\n  };\n}",
  "function scrollSpy() {\n            var scrollTop = $window.scrollTop(),\n                $anchors = $childMenu.find('a'),\n                activeIndex;\n            $anchors.each(function (index) {\n                var $target = $($(this).attr('href').replace(/\\./g, '\\\\.')),\n                    offsetTop = $target.offset().top,\n                    offsetBottom = offsetTop + $target.outerHeight(true);\n                if (offsetTop <= scrollTop && scrollTop < offsetBottom) {\n                    activeIndex = index;\n                    return false;\n                }\n            });\n            $childMenuItem.removeClass('kss-active');\n            if (typeof activeIndex !== 'undefined') {\n                $childMenuItem.eq(activeIndex).addClass('kss-active');\n            }\n        }",
  "function collateStrings(a, b) {\n    var aValue, bValue, aChar, bChar, aEquiv, bEquiv, index = 0, tiebreaker = 0;\n    a = getCollationReadyString(a);\n    b = getCollationReadyString(b);\n    do {\n      aChar  = getCollationCharacter(a, index);\n      bChar  = getCollationCharacter(b, index);\n      aValue = getCollationValue(aChar);\n      bValue = getCollationValue(bChar);\n      if(aValue === -1 || bValue === -1) {\n        aValue = a.charCodeAt(index) || null;\n        bValue = b.charCodeAt(index) || null;\n      }\n      aEquiv = aChar !== a.charAt(index);\n      bEquiv = bChar !== b.charAt(index);\n      if(aEquiv !== bEquiv && tiebreaker === 0) {\n        tiebreaker = aEquiv - bEquiv;\n      }\n      index += 1;\n    } while(aValue != null && bValue != null && aValue === bValue);\n    if(aValue === bValue) return tiebreaker;\n    return aValue < bValue ? -1 : 1;\n  }",
  "function destroy() {\n    var element = this.element;\n\n    if (!element[NAMESPACE]) {\n      return this;\n    }\n\n    element[NAMESPACE] = undefined;\n\n    if (this.isImg && this.replaced) {\n      element.src = this.originalUrl;\n    }\n\n    this.uncreate();\n    return this;\n  }",
  "function getFilePath(isModule, id, options) {\n    try {\n        return resolve.sync(id, options)\n    } catch (_err) {\n        if (isModule) {\n            return null\n        }\n        return path.resolve(options.basedir, id)\n    }\n}",
  "function WildCardButtons () {\n      var menuDiv = myDocument.getElementById(outline.UserInput.menuID)\n      var div = menuDiv.insertBefore(myDocument.createElement('div'), menuDiv.firstChild)\n      var input1 = div.appendChild(myDocument.createElement('input'))\n      var input2 = div.appendChild(myDocument.createElement('input'))\n      input1.type = 'button'; input1.value = 'New...'\n      input2.type = 'button'; input2.value = 'Know its URI'\n\n      function highlightInput (e) { // same as the one in newMenu()\n        var menu = myDocument.getElementById(outline.UserInput.menuID)\n        if (menu.lastHighlight) menu.lastHighlight.className = ''\n        menu.lastHighlight = UI.utils.ancestor(UI.utils.getTarget(e), 'INPUT')\n        if (!menu.lastHighlight) return // mouseover <TABLE>\n        menu.lastHighlight.className = 'activeItem'\n      }\n      div.addEventListener('mouseover', highlightInput, false)\n      input1.addEventListener('click', this.createNew, false)\n      input2.addEventListener('click', this.inputURI, false)\n    }",
  "function encrypt(publicKeyDataOrFile, data) {\n        const deferred = q.defer();\n        let publicKeyPromise;\n\n        const getPublicKey = function getPublicKey(publicKeyFile) {\n            const publicKeyDeferred = q.defer();\n            fs.readFile(publicKeyFile, (err, publicKey) => {\n                if (err) {\n                    logger.warn('Error reading public key:', err);\n                    publicKeyDeferred.reject(err);\n                } else {\n                    publicKeyDeferred.resolve(publicKey);\n                }\n            });\n\n            return publicKeyDeferred.promise;\n        };\n\n        if (typeof data !== 'string') {\n            deferred.reject(new Error('data must be a string'));\n            return deferred.promise;\n        }\n\n        if (publicKeyDataOrFile.startsWith('-----BEGIN PUBLIC KEY-----')) {\n            publicKeyPromise = q(publicKeyDataOrFile);\n        } else {\n            publicKeyPromise = getPublicKey(publicKeyDataOrFile);\n        }\n\n        publicKeyPromise\n            .then((publicKey) => {\n                let encrypted;\n\n                try {\n                    encrypted = crypto.publicEncrypt(publicKey, util.createBufferFrom(data));\n                    deferred.resolve(encrypted.toString('base64'));\n                } catch (err) {\n                    logger.warn('Error encrypting data:', err);\n                    deferred.reject(err);\n                }\n            })\n            .catch((err) => {\n                logger.warn('Unable to get public key:', err);\n                deferred.reject(err);\n            });\n\n        return deferred.promise;\n    }",
  "function defaults(targ, _defs) {\n    [].slice.call(arguments, 1).forEach(function (def) {\n        Object.keys(def).forEach(function (key) {\n            if (!targ.hasOwnProperty(key)) {\n                targ[key] = def[key];\n            }\n        });\n    });\n}",
  "function filterFunctionWords( combinations, functionWords ) {\n\tcombinations = filterFunctionWordsAnywhere( combinations, functionWords.filteredAnywhere );\n\tcombinations = filterFunctionWordsAtBeginningAndEnding( combinations, functionWords.filteredAtBeginningAndEnding );\n\tcombinations = filterFunctionWordsAtEnding( combinations, functionWords.filteredAtEnding );\n\tcombinations = filterFunctionWordsAtBeginning( combinations, functionWords.filteredAtBeginning );\n\treturn combinations;\n}",
  "function shuffle (s, splitter) {\n                    var a = s.split(typeof splitter === 'string' ? splitter : ''), n = a.length,\n                    replaceSplits = n - 1;\n\n                    for(var i = n - 1; i > 0; i--) {\n                        var j = Math.floor(Math.random() * (i + 1)),\n                            tmp = a[i];\n\n                        a[i] = a[j];\n                        a[j] = tmp;\n                    }\n\n                    for(var k = 0; k < replaceSplits; k++) a.splice(libs.number.randomIntInRange(0, a.length), 0, splitter);\n                    return a.join('');\n                }",
  "function() {\n\t\t\tvar self = this;\n\t\t\tvar idx = self.capture_idx;\n      self.w = (\n        (idx.end - idx.start) / 1000 * self.pix_per_sec) + \n        margin[1] + margin[3];\n      self.h = margin[0] + margin[2];\n      for (var s in idx.servers) {\n        self.h += (self.server_pad * 2);\n        self.h += ((idx.servers[s][1].length) * self.conn_pad);\n      }\n\t\t\tconsole.log(\"resizing to \" + self.w + \" x \" + self.h);\n\t\t\tpaper.setSize(self.w, self.h);\n\t\t\tlabels.setSize(self.label_w, self.h);\n\t\t}",
  "function updateEmailVariables(callback,id,email,variables){\n    if ((id===undefined) || (email === undefined) || (variables === undefined) || (! variables.length)) {\n        return callback(returnError(\"Empty email, variables or book id\"));\n    }\n    var data = {\n        email: email,\n        variables: variables\n    };\n    sendRequest( 'addressbooks/' + id + '/emails/variable', 'POST', data, true, callback );\n}",
  "function(str, rmc) {\n\n      if (rmc.length !== 13 && rmc.length !== 14 && rmc.length !== 15) {\n        throw new Error('Invalid RMC length: ' + str);\n      }\n\n      /*\n       $GPRMC,hhmmss.ss,A,llll.ll,a,yyyyy.yy,a,x.x,x.x,ddmmyy,x.x,a*hh\n       \n       RMC  = Recommended Minimum Specific GPS/TRANSIT Data\n       1    = UTC of position fix\n       2    = Data status (A-ok, V-invalid)\n       3    = Latitude of fix\n       4    = N or S\n       5    = Longitude of fix\n       6    = E or W\n       7    = Speed over ground in knots\n       8    = Track made good in degrees True\n       9    = UT date\n       10   = Magnetic variation degrees (Easterly var. subtracts from true course)\n       11   = E or W\n       (12) = NMEA 2.3 introduced FAA mode indicator (A=Autonomous, D=Differential, E=Estimated, N=Data not valid)\n       (13) = NMEA 4.10 introduced nav status\n       12   = Checksum\n       */\n\n      return {\n        'time': parseTime(rmc[1], rmc[9]),\n        'status': parseRMC_GLLStatus(rmc[2]),\n        'lat': parseCoord(rmc[3], rmc[4]),\n        'lon': parseCoord(rmc[5], rmc[6]),\n        'speed': parseKnots(rmc[7]),\n        'track': parseNumber(rmc[8]), // heading\n        'variation': parseRMCVariation(rmc[10], rmc[11]),\n        'faa': rmc.length > 13 ? parseFAA(rmc[12]) : null,\n        'navStatus': rmc.length > 14 ? rmc[13] : null\n      };\n    }",
  "function (string) { // string.check check sting type and size\n\n            return ((typeof string === 'string' || string instanceof String)\n                    && string.length >= this.min\n                    && string.length <= this.max\n                    && (!this.match || string.match(this.match))\n                   );\n          }",
  "function (priority) {\n            var retVal;\n            if (sjl.classOfIs(priority, Number)) {\n                retVal = priority;\n            }\n            else {\n                this._internalPriorities += 1;\n                retVal = +this._internalPriorities;\n            }\n            return retVal;\n        }",
  "function repeat(times) {\r\n    return function (it) {\r\n        return __asyncGenerator(this, arguments, function* () {\r\n            var e_26, _a;\r\n            const buffer = [];\r\n            try {\r\n                for (var it_6 = __asyncValues(it), it_6_1; it_6_1 = yield __await(it_6.next()), !it_6_1.done;) {\r\n                    const item = it_6_1.value;\r\n                    buffer.push(item);\r\n                    yield yield __await(item);\r\n                }\r\n            }\r\n            catch (e_26_1) { e_26 = { error: e_26_1 }; }\r\n            finally {\r\n                try {\r\n                    if (it_6_1 && !it_6_1.done && (_a = it_6.return)) yield __await(_a.call(it_6));\r\n                }\r\n                finally { if (e_26) throw e_26.error; }\r\n            }\r\n            for (let i = 0; i < times; ++i) {\r\n                yield __await(yield* __asyncDelegator(__asyncValues(buffer)));\r\n            }\r\n        });\r\n    };\r\n}",
  "function (key) {\n                if (this.has(key)) {\n                    var _index = this._keys.indexOf(key);\n                    this._values.splice(_index, 1);\n                    this._keys.splice(_index, 1);\n                }\n                return this;\n            }",
  "function $checksum(byte) {\n    checksum += toHex(byte);\n    if (++offset < 20) return $checksum;\n    var actual = sha1sum.digest();\n    if (checksum !== actual) throw new Error(\"Checksum mismatch: \" + actual + \" != \" + checksum);\n  }",
  "function(key) {\n        var value = this.loadVar(key);\n        if (typeof(value) =='undefined') {\n            exitProcess('the value of ' + key + ' is necessary , but now is undefined', this.alarm);\n            return false;\n        }\n        return value;\n    }",
  "function hasPattern(s, pattern) {\n    const m = pattern.exec(s)\n    return m != null && (m[1] || \"\").length % 2 === 0\n}",
  "function CompositeError(message, innerErrors) {\n  this.message = message;\n  this.name = 'CompositeError';\n  this.innerErrors = normalizeInnerErrors(innerErrors);\n  Error.captureStackTrace(this, this.constructor);\n  this.originalStackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');\n  // Override the stack property\n  Object.defineProperty(this, 'stack', {\n    get: function() { return this.formatStackTraces(); }\n  });\n}",
  "function settings( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE:\n\t\tcase WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_CAMPAIGN_DEFAULTS_SUBMIT_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS:\n\t\t\treturn Object.assign( {}, state, action.settings );\n\t\tcase WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS:\n\t\t\tconst data = { mailchimp_lists: action.lists };\n\t\t\tconst listKeys = keys( action.lists );\n\t\t\tif ( ! state.mailchimp_list && listKeys.length > 0 ) {\n\t\t\t\t// Just pick first that will be shown to the user in the dropdown\n\t\t\t\t// We are setting mailchimp_list just in case user likes it and clicks\n\t\t\t\t// Continue without actually sellecting something.\n\t\t\t\tdata.mailchimp_list = listKeys[ 0 ];\n\t\t\t}\n\t\t\treturn Object.assign( {}, state, data );\n\t}\n\n\treturn state;\n}",
  "function copyAssetToContext(src, dest, context) {\n    var sourceAsset = path.join(testDir, src);\n    var targetAsset = path.join(context.dir, dest);\n\n    if (!fs.existsSync(sourceAsset)) {\n        // The source asset requested is missing\n        throw new Error(\"The test asset is missing\");\n    }\n\n    // Attempt to copy the asset\n    fs.copySync(sourceAsset, targetAsset);\n\n    if (!fs.existsSync(targetAsset)) {\n        // The target asset was not copied successfully\n        throw new Error(\"The test asset could not be copied\");\n    }\n}",
  "function ConversionHint(conversion, arg) {\n    this.status = conversion.status;\n    this.message = conversion.message;\n    if (arg) {\n        this.start = arg.start;\n        this.end = arg.end;\n    }\n    else {\n        this.start = 0;\n        this.end = 0;\n    }\n    this.predictions = conversion.predictions;\n}",
  "function(connectionName, table, options, cb) {\n            if (LOG_DEBUG) {\n                console.log(\"BEGIN destroy\");\n            }\n            \n            var connectionObject = connections[connectionName];\n            var collection = connectionObject.collections[table];\n\n            var _schema = connectionObject.schema;\n\n            // Mixin WL Next connection overrides to sqlOptions\n            var overrides = connectionOverrides[connectionName] || {};\n            var _options = _.cloneDeep(sqlOptions);\n            if (hop(overrides, 'wlNext')) {\n                _options.wlNext = overrides.wlNext;\n            }\n\n            var sequel = new Sequel(_schema, _options);\n            var query;\n\n            // Build a query for the specific query strategy\n            try {\n                query = sequel.destroy(table, options);\n            } catch (e) {\n                return cb(e);\n            }\n\n            query.query = query.query.replace('RETURNING *', '');\n            query.query = query.query.replace( /\\$/g, ':');\n            query.query = query.query.replace(\" AS \", \" \");\n            \n\n            // Run Query\n            connectionObject.pool.getConnection(\n                    function (err, connection)\n                    {\n                        if (err) {\n                            handleQueryError(err, 'destroy');\n                            return;\n                        }\n                        if (LOG_QUERIES) {\n                            console.log('Executing query: ' + query.query);\n                            console.log('Data for query: ' + JSON.stringify(query.values));\n                        }\n                        connection.execute(query.query, query.values, {autoCommit: true, outFormat: oracledb.OBJECT}, function __DELETE__(err, result) {\n                            if (err) {\n                                /* Release the connection back to the connection pool */\n                                doRelease(connection);\n                                return cb(handleQueryError(err, 'destroy'));\n                            }\n\n                            /* Release the connection back to the connection pool */\n                            doRelease(connection);\n\n                            cb(null, result.rows);\n\n                        });\n                    });\n\n        }",
  "function processContent( content, values ) {\n\t\t\treturn mout.lang.isFunction( options.process ) ? options.process( content, values ) : content;\n\t\t}",
  "function pad (n, length) {\n                    return libs.string.pad(n.toString(), length, '0', true);\n                }",
  "function cache(app) {\n  if (app.locals.config.cacheDb && 'redis' === app.locals.config.cacheDb.connector) {\n    // use redis for cache\n    let redis = require(\"redis\").createClient(app.locals.config.cacheDb);\n    redis.on(\"error\", function (err) {\n      app.error(err);\n    });\n    // clear existing cache on startup\n    redis.del('zlSites', 'themeTrees', 'themesConfig');\n\n    return {\n      // for getting data\n      get: function () {\n        if (3 == arguments.length) {\n          // hash request\n          redis.hget(arguments[0], arguments[1], arguments[2]);\n        }\n        else if (2 == arguments.length) {\n          // key request\n          redis.get(arguments[0], arguments[1]);\n        }\n      },\n      // for setting data\n      set: function () {\n        if (4 == arguments.length) {\n          // hash request\n          redis.hset(arguments[0], arguments[1], arguments[2], arguments[3]);\n        }\n        else if (3 == arguments.length) {\n          // key request\n          redis.set(arguments[0], arguments[1], arguments[2]);\n        }\n      },\n      // for setting volatile data with an expiration date\n      setvol: function () {\n        if (4 == arguments.length) {\n          // key request\n          redis.set(arguments[0], arguments[1], () => {\n            redis.expire(arguments[0], arguments[2], arguments[3]);\n          });\n        }\n      },\n      // for deleting data\n      del: function () {\n        if (3 == arguments.length) {\n          // hash request\n          redis.hdel(arguments[0], arguments[1], arguments[2]);\n        }\n        else if (2 == arguments.length) {\n          // key request\n          redis.del(arguments[0], arguments[1]);\n        }\n      }\n    }\n  }\n  else {\n    // not using cache\n    app.error('No config.cacheDb provided. This may affect performance.');\n    let e = function() { arguments[arguments.length-1](); }\n    return { get: e, set: e, setvol: e, del: e }\n  }\n}",
  "function AbstractSyntaxTree(root, labels, manager) {\n    this.root = root;\n    this.labels = labels;\n    this.manager = manager;\n\n    manager.parse(this);\n}",
  "function TriangleCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 6) throw new SyntaxError('TRIANGLE command requires 6 arguments');\n    this.x1 = parsed.args[0];\n    this.y1 = parsed.args[1];\n    this.x2 = parsed.args[2];\n    this.y2 = parsed.args[3];\n    this.x3 = parsed.args[4];\n    this.y3 = parsed.args[5];\n    this.stroke = parsed.args.length > 6 ? parsed.args[6] : false;\n}",
  "function insertCountryAliases( data ) {\n\tObject.keys( aliases ).forEach( source => {\n\t\tdata[ source ] = data[ aliases[ source ] ];\n\t} );\n\treturn data;\n}",
  "function nodeWalkAll(node, predicate, matches, getChildNodes) {\n  if (getChildNodes === void 0) {\n    getChildNodes = module.exports.defaultChildNodes;\n  }\n  if (!matches) {\n    matches = [];\n  }\n  if (predicate(node)) {\n    matches.push(node);\n  }\n  var childNodes = getChildNodes(node);\n  if (childNodes) {\n    for (var i = 0; i < childNodes.length; i++) {\n      nodeWalkAll(childNodes[i], predicate, matches, getChildNodes);\n    }\n  }\n  return matches;\n}",
  "function(includeCommand) {\n        var args = [];\n        if (includeCommand === true) {\n            args.push(this.commandAssignment);\n        }\n        Object.keys(this._assignments).forEach(function(name) {\n            args.push(this.getAssignment(name));\n        }, this);\n        return args;\n    }",
  "function build_chunks( sub_text, sub_ranges, range_data, container, options ) {\n\tlet text_start = null,\n\t\ttext_stop = null,\n\t\ti,\n\t\tremove_r_id,\n\t\tr_id,\n\t\tsr_id,\n\t\trange_id,\n\t\trange_info,\n\t\tnew_i,\n\t\tnew_sub_text,\n\t\tnew_sub_range;\n\n\t// We use sub_ranges and not sub_text because we *can* have an empty string with a range\n\t// acting upon it. For example an a tag with just an alt-text-less image tag inside of it\n\tfor ( i = 0; i < sub_ranges.length; i++ ) {\n\t\tif ( sub_ranges[ i ].index.length == 0 ) {\n\t\t\t// This is a simple text element without applicable ranges\n\t\t\tif ( text_start == null ) {\n\t\t\t\t// This is the beginning of the text element\n\t\t\t\ttext_start = i;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( text_start != null ) {\n\t\t\t\ttext_stop = i;\n\t\t\t\t// We're in a range now, but, we were just in text,\n\t\t\t\t// so create the DOM elements for the just-finished text range\n\t\t\t\tcontainer.appendChild(\n\t\t\t\t\tdocument.createTextNode( sub_text.substring( text_start, text_stop ) )\n\t\t\t\t);\n\t\t\t\ttext_start = null;\n\t\t\t\ttext_stop = null;\n\t\t\t}\n\n\t\t\t// At this point we have one or more ranges we could be entering. We need to decide\n\t\t\t// which one. For recursion to work we must pick the longest range. If there are\n\t\t\t// ties for longest range from this position then it doesn't matter which one wins.\n\t\t\t// This may not be true for all cases forever. If we find a bug where a particular\n\t\t\t// range needs to win out over another then this is the place for that logic.\n\t\t\t//\n\t\t\t// sub_ranges[i].index looks like:\n\t\t\t// [ { id: [index of range in range_data], len: [span of range indices] }, { id: x, len: y }, ..., { id: n, len: m } ]\n\t\t\tremove_r_id = null;\n\t\t\tfor ( r_id in sub_ranges[ i ].index ) {\n\t\t\t\tif (\n\t\t\t\t\tnull === remove_r_id ||\n\t\t\t\t\tsub_ranges[ i ].index[ r_id ].len > sub_ranges[ i ].index[ remove_r_id ].len\n\t\t\t\t) {\n\t\t\t\t\tremove_r_id = r_id;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Since we've picked a range we'll record some information for future reference\n\t\t\trange_id = sub_ranges[ i ].index[ remove_r_id ].id; // To be able to reference thr origin range\n\t\t\trange_info = range_data[ range_id ]; // the origin range data\n\t\t\tnew_i = i + sub_ranges[ i ].index[ remove_r_id ].len - 1; // the position we will be jumping to after resursing\n\t\t\tnew_sub_text = sub_text.substring( i, i + sub_ranges[ i ].index[ remove_r_id ].len ); // the text we will be recursing with\n\t\t\tnew_sub_range = sub_ranges.slice( i, 1 + i + sub_ranges[ i ].index[ remove_r_id ].len ); // the new ranges we'll be recursing with\n\n\t\t\t// Remove the range we are recursing into from the ranges we're recursing with.\n\t\t\t// Otherwise we will end up in an infinite loop and everybody will be mad at us.\n\t\t\tfor ( sr_id = 0; sr_id < new_sub_range.length; sr_id++ ) {\n\t\t\t\tnew_sub_range[ sr_id ].index.splice( remove_r_id, 1 );\n\t\t\t}\n\n\t\t\tcontainer.appendChild(\n\t\t\t\trender_range( new_sub_text, new_sub_range, range_info, range_data, options )\n\t\t\t);\n\t\t\ti = new_i;\n\t\t}\n\t}\n\tif ( text_start != null ) {\n\t\t// We're done, at and below this depth but we finished in a text range, so we need to\n\t\t// handle the last bit of text\n\t\tcontainer.appendChild(\n\t\t\tdocument.createTextNode( sub_text.substring( text_start, sub_text.length ) )\n\t\t);\n\t}\n\t// Just in case we have anything like a bunch of small Text() blocks together, etc, lets\n\t// normalize the document\n\tcontainer.normalize();\n}",
  "function(index, silent) {\n        var me = this;\n\n        if (!index) {\n            index = 0;\n        } else if (!Ext.isNumber(index)) {\n            index = Ext.Array.indexOf(me.items, index);\n        }\n        me.items[index].disabled = false;\n        me.up('tablepanel').el.select('.' + Ext.baseCSSPrefix + 'action-col-' + index).removeCls(me.disabledCls);\n        if (!silent) {\n            me.fireEvent('enable', me);\n        }\n    }",
  "function(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = range(start, _.isUndefined(end) ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\t\t\t\n\t\t\tvar update = function(obj) {\n\t\t\t\t_.each(obj, function(v, k) {\n\t\t\t\t\tif (v >= r.end)\n\t\t\t\t\t\tobj[k] += delta;\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\t\t\t\n\t\t\t// update affected positions of children\n\t\t\t_.each(this.list(), function(item) {\n\t\t\t\tupdate(item._positions);\n\t\t\t});\n\t\t\t\n\t\t\tthis.source = require('utils').replaceSubstring(this.source, value, r);\n\t\t}",
  "function Emitter(opts) {\n  Transform.call(this);\n  this._writableState.objectMode = true;\n  this._readableState.objectMode = true;\n  opts = opts || {};\n  // emit a fixed event name\n  // rather than the default type\n  this.name = opts.name;\n\n  this.passthrough = opts.passthrough;\n}",
  "function(store, initial){\n        var me = this;\n        me.mixins.bindable.bindStore.apply(me, arguments);\n        if(me.store && !initial) {\n            me.refresh();\n        }\n    }",
  "function bootstrap () {\n  var server = RPC.apply(null, arguments)\n  var io = server.io\n\n  var allQueries = []\n\n  Object.keys(models).forEach(function (modelName) {\n    var model = models[modelName]\n    model._exposeCallback(server)\n  })\n\n  io.use(function (socket, next) {\n    const registeredLQs = {}\n    socket.moonridge = {\n      registeredLQs: registeredLQs,\n      user: {privilege_level: 0}\n    } // default privilege level for any connected client\n\n    socket.on('disconnect', function () {\n      // clearing out liveQueries listeners\n      debug(socket.id, ' socket disconnected, cleaning up LQ listeners')\n      for (var LQId in registeredLQs) {\n        var LQ = registeredLQs[LQId]\n        LQ.removeListener(socket)\n      }\n    })\n\n    next()\n  })\n\n  server.expose({\n    MR: {\n      getModels: function () {\n        return Object.keys(models)\n      },\n      deAuthorize: function () {\n        this.moonridge.user = {privilege_level: 0}\t// for logging users out\n      }\n    }\n  })\n\n  if (process.env.MOONRIDGE_HEALTH === '1') {\n    // this reveals any data that you use in queries to the public, so it should not be used in production when dealing with sensitive data\n\n    server.expose({\n      MR: {\n        getHealth: function () {\n          var allModels = {}\n          var index = allQueries.length\n          while (index--) {\n            var modelQueriesForSerialization = {}\n            var model = allQueries[index]\n            for (var LQ in model.queries) {\n              modelQueriesForSerialization[LQ] = Object.keys(model.queries[LQ].listeners).length\n            }\n            allModels[model.modelName] = modelQueriesForSerialization\n          }\n          return {\n            pid: process.pid,\n            memory: process.memoryUsage(),\n            uptime: process.uptime(),   // in seconds\n            liveQueries: allModels  // key is LQ.clientQuery and value is number of listening clients\n          }\n        }\n      }\n    })\n  }\n\n  return server\n}",
  "function loadjs(paths, arg1, arg2) {\n\t      var bundleId, args; // bundleId (if string)\n\n\t      if (arg1 && arg1.trim) bundleId = arg1; // args (default is {})\n\n\t      args = (bundleId ? arg2 : arg1) || {}; // throw error if bundle is already defined\n\n\t      if (bundleId) {\n\t        if (bundleId in bundleIdCache) {\n\t          throw \"LoadJS\";\n\t        } else {\n\t          bundleIdCache[bundleId] = true;\n\t        }\n\t      }\n\n\t      function loadFn(resolve, reject) {\n\t        loadFiles(paths, function (pathsNotFound) {\n\t          // execute callbacks\n\t          executeCallbacks(args, pathsNotFound); // resolve Promise\n\n\t          if (resolve) {\n\t            executeCallbacks({\n\t              success: resolve,\n\t              error: reject\n\t            }, pathsNotFound);\n\t          } // publish bundle load event\n\n\n\t          publish(bundleId, pathsNotFound);\n\t        }, args);\n\t      }\n\n\t      if (args.returnPromise) return new Promise(loadFn);else loadFn();\n\t    }",
  "function(walk) {\n        if (this.emitText(walk)) return;\n        if (this.tryInputText(walk)) return;\n        if (this.tryInputRegex(walk)) return;\n        if (this.tryInputTextWithDefault(walk)) return;\n        if (this.trySelectMenu(walk)) return;\n        var _super = InlineCompiler.prototype.emitNormal.bind(this);\n        return _super(walk);\n      }",
  "function removeCaretContainer(node, move_caret) {\r\n\t\t\t\tvar child, rng;\r\n\r\n\t\t\t\tif (!node) {\r\n\t\t\t\t\tnode = getParentCaretContainer(selection.getStart());\r\n\r\n\t\t\t\t\tif (!node) {\r\n\t\t\t\t\t\twhile (node = dom.get(caretContainerId)) {\r\n\t\t\t\t\t\t\tremoveCaretContainer(node, false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng = selection.getRng(true);\r\n\r\n\t\t\t\t\tif (isCaretContainerEmpty(node)) {\r\n\t\t\t\t\t\tif (move_caret !== false) {\r\n\t\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\t\trng.setEndBefore(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdom.remove(node);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchild = findFirstTextNode(node);\r\n\r\n\t\t\t\t\t\tif (child.nodeValue.charAt(0) === INVISIBLE_CHAR) {\r\n\t\t\t\t\t\t\tchild = child.deleteData(0, 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t}\r\n\t\t\t}",
  "function getOffset(cursor, defaultOffset) {\n    if (typeof cursor === 'undefined' || cursor === null) {\n        return defaultOffset;\n    }\n\n    let offset = cursorToOffset(cursor);\n    if (isNaN(offset)) {\n        return defaultOffset;\n    }\n\n    return offset;\n}",
  "function(path) {\n    var p = path;\n    const ar = p.indexOf('->');\n    if (ar >= 0) {\n      p = p.substring(ar + 2);\n    }\n    const cu = p.indexOf('/{');\n    if (cu > 0) {\n      p = p.substring(0, cu);\n    }\n    return p;\n  }",
  "function request(url){\n  return new Promise(function(resolve, reject) {\n    _request(url, function (error, response, body) {\n      if(error) return reject(error);\n      resolve({response, body})\n    });\n  });\n}",
  "function createBadge(text) {\n\t    if (is$1.empty(text)) {\n\t      return null;\n\t    }\n\n\t    var badge = createElement('span', {\n\t      class: this.config.classNames.menu.value\n\t    });\n\t    badge.appendChild(createElement('span', {\n\t      class: this.config.classNames.menu.badge\n\t    }, text));\n\t    return badge;\n\t  }",
  "function stripTokens(val, negate, variadic) {\n    variadic = escape(variadic || constants_1.VARIADIC_CHAR);\n    negate = escape(negate || constants_1.NEGATE_CHAR);\n    var argExp = new RegExp(['<', '>', '\\\\[', '\\\\]'].join('|'), 'g');\n    var noExp = new RegExp('^' + negate);\n    var variExp = new RegExp(variadic + '$');\n    return expandArgs(val)\n        .map(function (v) {\n        v = v\n            .replace(constants_1.FLAG_EXP, '')\n            .replace(noExp, '')\n            .replace(argExp, '')\n            .replace(variExp, '');\n        return v;\n    }).join(' ');\n}",
  "function F(type, term) {\n  let original = term;\n  if (term && !term.__meta) {\n    term = type.wrap ? type.wrap(term) : term;\n    term.__meta = {};\n    term.__name = function(name) {\n      term.__meta.name = name;\n      return term;\n    };\n    term.__desc = function(desc) {\n      term.__meta.desc = desc;\n      return term;\n    };\n    if (term.__meta) {\n      term.__meta.term = original;\n      term.__meta.name = \"anon\";\n      term.__meta.desc = \"no description\";\n    };\n  };\n  F.check(type, term);\n  return term;\n}",
  "function() {\r\n\t\t\tvar t = this, ed = t.editor;\r\n\r\n\t\t\t// Register command(s) for backwards compatibility\r\n\t\t\ted.addCommand(\"mcePasteWord\", function() {\r\n\t\t\t\ted.windowManager.open({\r\n\t\t\t\t\tfile: t.url + \"/pasteword.htm\",\r\n\t\t\t\t\twidth: parseInt(getParam(ed, \"paste_dialog_width\")),\r\n\t\t\t\t\theight: parseInt(getParam(ed, \"paste_dialog_height\")),\r\n\t\t\t\t\tinline: 1\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\tif (getParam(ed, \"paste_text_use_dialog\")) {\r\n\t\t\t\ted.addCommand(\"mcePasteText\", function() {\r\n\t\t\t\t\ted.windowManager.open({\r\n\t\t\t\t\t\tfile : t.url + \"/pastetext.htm\",\r\n\t\t\t\t\t\twidth: parseInt(getParam(ed, \"paste_dialog_width\")),\r\n\t\t\t\t\t\theight: parseInt(getParam(ed, \"paste_dialog_height\")),\r\n\t\t\t\t\t\tinline : 1\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Register button for backwards compatibility\r\n\t\t\ted.addButton(\"pasteword\", {title : \"paste.paste_word_desc\", cmd : \"mcePasteWord\"});\r\n\t\t}",
  "function(){\n        var me = this,\n            prev = me.store.currentPage - 1;\n\n        if (prev > 0) {\n            if (me.fireEvent('beforechange', me, prev) !== false) {\n                me.store.previousPage();\n            }\n        }\n    }",
  "function getHTML(element) {\n\t  var wrapper = document.createElement('div');\n\t  wrapper.appendChild(element);\n\t  return wrapper.innerHTML;\n\t}",
  "function(cssText, id) {\n            var ss,\n                head = doc.getElementsByTagName(\"head\")[0],\n                styleEl = doc.createElement(\"style\");\n\n            styleEl.setAttribute(\"type\", \"text/css\");\n            if (id) {\n               styleEl.setAttribute(\"id\", id);\n            }\n\n            if (Ext.isIE) {\n               head.appendChild(styleEl);\n               ss = styleEl.styleSheet;\n               ss.cssText = cssText;\n            } else {\n                try{\n                    styleEl.appendChild(doc.createTextNode(cssText));\n                } catch(e) {\n                   styleEl.cssText = cssText;\n                }\n                head.appendChild(styleEl);\n                ss = styleEl.styleSheet ? styleEl.styleSheet : (styleEl.sheet || doc.styleSheets[doc.styleSheets.length-1]);\n            }\n            CSS.cacheStyleSheet(ss);\n            return ss;\n        }",
  "function DrawtextCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 3) throw new SyntaxError('DRAWTEXT command requires 3 arguments');\n    else if (parsed.args.length > 3 && parsed.args.length < 5) throw new SyntaxError('DRAWTEXT command requires 5 arguments');\n\n    this.text = parsed.args[0];\n    this.x1 = parsed.args[1];\n    this.y1 = parsed.args[2];\n    if (parsed.args.length > 3) {\n        this.x2 = parsed.args[3];\n        this.y2 = parsed.args[4];\n    } else {\n        this.x2 = false;\n        this.y2 = false;\n    }\n}",
  "function beforeEach(test, context, done) {\n    context.dir = tmp.dirSync().name;\n    process.chdir(context.dir);\n    done && done();\n}",
  "function copy_block(buf, // the input data\n\t\tlen, // its length\n\t\theader // true if block header must be written\n\t\t) {\n\t\t\tbi_windup(); // align on byte boundary\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\tif (header) {\n\t\t\t\tput_short(len);\n\t\t\t\tput_short(~len);\n\t\t\t}\n\n\t\t\tthat.pending_buf.set(window.subarray(buf, buf + len), that.pending);\n\t\t\tthat.pending += len;\n\t\t}",
  "function applyPendingChange(pendingChange, tries, callback) {\n  var datasetId = pendingChange.datasetId;\n  if (!datasetId || !pendingChange.action || !pendingChange.uid || !pendingChange.cuid || !pendingChange.hash) {\n    debugError(\"[%s] invalid pendingChange request dropped :: item = %j\", datasetId, pendingChange);\n    return callback();\n  }\n  debug('[%s] processPending :: item = %j', datasetId, pendingChange);\n  if (tries > retryLimit) {\n    //the pendingChange has been processed before. Mark it as failed\n    debugError('[%s] processPending failed :: tries = %d  :: item = %j', datasetId, tries, pendingChange);\n    return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.FAILED, \"crashed\", callback);\n  }\n\n  pendingChange.tries = tries;\n\n  var action = pendingChange.action.toLowerCase();\n\n  var timer = metrics.startTimer();\n\n  function onComplete(err) {\n    metricsClient.gauge(metrics.KEYS.PENDING_CHANGE_PROCESS_TIME, {success: !err, action: action}, timer.stop());\n    return callback(err);\n  }\n\n  switch (action) {\n    case \"create\":\n      doCreate(datasetId, pendingChange, onComplete);\n      break;\n    case \"update\":\n      doUpdate(datasetId, pendingChange, onComplete);\n      break;\n    case \"delete\":\n      doDelete(datasetId, pendingChange, onComplete);\n      break;\n    default:\n      debugError(\"[%s] invalid pendingChange request dropped :: item = %j\", datasetId, pendingChange);\n      return onComplete();\n  }\n}",
  "function(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].search(pad) == 0)\n\t\t\t\t\tlines[i] = lines[i].substr(pad.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines.join(this.getNewline());\n\t\t}",
  "function RrectCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 5) throw new SyntaxError('RRECT command requires 5 arguments');\n    this.x1 = parsed.args[0];\n    this.y1 = parsed.args[1];\n    this.x2 = parsed.args[2];\n    this.y2 = parsed.args[3];\n    this.radius = parsed.args[4];\n    this.stroke = parsed.args.length > 5 ? parsed.args[5] : false;\n}",
  "function() {\n            var oldVisible = this.isButtonCurrentlyVisible();\n            var newVisible = this.shouldButtonBeVisible();\n\n            var clearButtonEl = this.clearButtonEl;\n            if (oldVisible != newVisible) {\n                if(this.animateClearButton && this.animateWithCss3) {\n                    this.clearButtonEl.removeCls(this.clearButtonCls + (oldVisible ? '-on' : '-off'));\n                    clearButtonEl.addCls(this.clearButtonCls + (newVisible ? '-on' : '-off'));\n                }\n                else {\n                    clearButtonEl.stopAnimation();\n                    clearButtonEl.setVisible(newVisible, this.animateClearButton);\n                }\n\n                // Set background-color of clearButton to same as field's background-color (for those browsers/cases\n                // where the padding-right (see below) does not work)\n                clearButtonEl.setStyle('background-color', this.textField.inputEl.getStyle('background-color'));\n\n                // Adjust padding-right of the input tag to make room for the button\n                // IE (up to v9) just ignores this and Gecko handles padding incorrectly with  textarea scrollbars\n                if (!(this.isTextArea && Ext.isGecko) && !Ext.isIE) {\n                    // See https://bugzilla.mozilla.org/show_bug.cgi?id=157846\n                    var deltaPaddingRight = clearButtonEl.getWidth() - this.clearButtonEl.getMargin('l');\n                    var currentPaddingRight = this.textField.inputEl.getPadding('r');\n                    var factor = (newVisible ? +1 : -1);\n                    this.textField.inputEl.dom.style.paddingRight = (currentPaddingRight + factor * deltaPaddingRight) + 'px';\n                }\n            }\n        }",
  "function start() {\n        if (router.useHashbang == null && router.useHistoryApi == null) {\n            if (window.location.host  && window.history.pushState) {\n                //web access\n                router.useHistoryApi = true;\n            } else {\n                // local access\n                router.useHashbang = true;\n            }\n        }\n\n        var initPath = \"\";\n\n        if (router.useHistoryApi) {\n            initPath = window.location.pathname;\n            if (_baseUrl === undefined) {\n                _baseUrl = initPath.replace(/\\/$/, \"\");\n            }\n            initPath = initPath.replace(_baseUrl, \"\") || _homePath || \"/\";\n        } else if (router.useHashbang) {\n            initPath = window.location.hash.replace(\"#!\", \"\") || _homePath || \"/\";\n        } else {\n            initPath = \"/\";\n        }\n\n        if (!initPath.startsWith(\"/\")) {\n            initPath = \"/\" + initPath;\n        }\n        /*\n        eventer.on(document.body, \"click\", \"a[href]\", function(e) {\n            var elm = e.currentTarget,\n                url = elm.getAttribute(\"href\");\n\n            if (url == \"#\") {\n                return;\n            }\n            if (url && langx.isSameOrigin(elm.href)) {\n                if (url.indexOf(_baseUrl) === 0) {\n                    url = url.substr(_baseUrl.length);\n                    eventer.stop(e);\n                    url = url.replace('#!', '');\n                    go(url);\n                }\n            }\n        });\n        */\n        if (router.useHistoryApi) {\n            window.addEventListener(\"popstate\", function(e) {\n                if(e.state) dispatch(e.state);\n                e.preventDefault();\n            });\n        } else if (router.useHashbang) {\n            window.addEventListener(\"hashchange\", function(e) {\n                dispatch({\n                    path: window.location.hash.replace(/^#!/, \"\")\n                });\n                e.preventDefault();\n            });\n        }\n\n        go(initPath);\n    }",
  "function isValid ({accessToken, clientToken}) {\n  return fetch(`${YGGDRASIL_API}/validate`, {\n    method: 'POST',\n    body: JSON.stringify({\n      accessToken,\n      clientToken\n    }),\n    headers: {\n      'user-agent': USER_AGENT,\n      'content-type': 'application/json'\n    }\n  })\n    .then(handleErrors)\n    .then(res => true)\n    .catch(err => {\n      if (err.message === 'Invalid token') return false\n      throw err\n    })\n}",
  "function(readOnly) {\n        var me = this,\n            inputEl = me.inputEl;\n        readOnly = !!readOnly;\n        me[readOnly ? 'addCls' : 'removeCls'](me.readOnlyCls);\n        me.readOnly = readOnly;\n        if (inputEl) {\n            inputEl.dom.readOnly = readOnly;\n        } else if (me.rendering) {\n            me.setReadOnlyOnBoxReady = true;\n        }\n        me.fireEvent('writeablechange', me, readOnly);\n    }",
  "function _safelyCall(isCatch, fn, ctx) {\n    if (!fn) return\n\n    if (isCatch) {\n        try {\n            fn.call(ctx)\n        } catch(e) {\n            consoler.errorTrace(e)\n        }\n    } else {\n        fn.call(ctx)\n    }\n}",
  "function render(req, res, next)  {\n    if (!req.session[sessionName].length) {\n      next();\n    } else {\n      const resultHTML = [];\n      async.each(\n        req.session[sessionName],\n        function(item, next) {\n          beforeSingleRender(item, function(error, item) {\n            if (error) return next(error);\n            app.render(viewName, item, function(error, html) {\n              if (error) return next(error);\n              resultHTML.push(html);\n              next(null);\n            })\n          })\n        },\n        function(error) {\n          if (error) return next(error);\n          req.session[sessionName].length = 0;\n          afterAllRender(resultHTML, function(error, html) {\n            if (error) return next(error);\n            res.locals[localsName] = html;\n            next();\n          })\n        }\n      )\n    }\n  }",
  "function generatePublicApiTs() {\n  const configFile = path.resolve(__dirname, '../src/ng5-slider/lib/public_api.json');\n  const tsFile = path.resolve(__dirname, '../src/ng5-slider/lib/public_api.ts');\n\n  const config = JSON.parse(fs.readFileSync(configFile, { encoding: 'utf8' }));\n\n  let tsFileContent = '';\n\n  for (let exportDef of config.exports) {\n    if (exportDef.what instanceof Array) {\n      const whats = exportDef.what.join(', ');\n      tsFileContent += `export { ${whats} } from '${exportDef.file}';\\n`;\n    } else {\n      tsFileContent += `export ${exportDef.what} from '${exportDef.file}';\\n`;\n    }\n  }\n\n  fs.writeFileSync(tsFile, tsFileContent, {encoding: 'utf8'});\n}",
  "function() {\n        var me = this,\n            view = me.view;\n\n        view.on({\n            scope: me,\n            groupclick: me.onGroupClick\n        });\n\n        if (me.enableGroupingMenu) {\n            me.injectGroupingMenu();\n        }\n\n        me.pruneGroupedHeader();\n\n        me.lastGroupField = me.getGroupField();\n        me.block();\n        me.onGroupChange();\n        me.unblock();\n    }",
  "function(vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n\n      return this;\n    }",
  "function(key) {\n        var str = this.loadVar(key);\n        if (typeof (str) != 'string') {\n            exitProcess('the value of ' + key + ' is a necessary string, but get ' + str, this.alarm);\n            return false;\n        }\n        return str;\n    }",
  "function flattenMixins(mixins, target, opts) {\n    mixins.forEach(item => {\n        if (typeof item === 'function') {\n            item = item(true, opts); // return okam mixin definition\n        }\n\n        if (!item || typeof item !== 'object') {\n            return;\n        }\n\n        let submixins = item.mixins;\n        if (Array.isArray(submixins) && submixins.length) {\n            item = Object.assign({}, item);\n            flattenMixins(submixins, item, opts);\n        }\n\n        Object.keys(item).forEach(\n            k => doMixin(target, item, k, opts)\n        );\n    });\n}",
  "function getWordCombinations( text, combinationSize, functionWords ) {\n\tconst sentences = getSentences( text );\n\n\tlet words, combination;\n\n\treturn flatMap( sentences, function( sentence ) {\n\t\tsentence = sentence.toLocaleLowerCase();\n\t\tsentence = normalizeQuotes( sentence );\n\t\twords = getWords( sentence );\n\n\t\treturn filter( map( words, function( word, i ) {\n\t\t\t// If there are still enough words in the sentence to slice of.\n\t\t\tif ( i + combinationSize - 1 < words.length ) {\n\t\t\t\tcombination = words.slice( i, i + combinationSize );\n\t\t\t\treturn new WordCombination( combination, 0, functionWords );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t} ) );\n\t} );\n}",
  "function getBoundaries(popper, reference, padding, boundariesElement) {\n    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here\n\n    var boundaries = {\n      top: 0,\n      left: 0\n    };\n    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); // Handle viewport case\n\n    if (boundariesElement === 'viewport') {\n      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    } else {\n      // Handle other cases based on DOM element used as boundaries\n      var boundariesNode = void 0;\n\n      if (boundariesElement === 'scrollParent') {\n        boundariesNode = getScrollParent(getParentNode(reference));\n\n        if (boundariesNode.nodeName === 'BODY') {\n          boundariesNode = popper.ownerDocument.documentElement;\n        }\n      } else if (boundariesElement === 'window') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      } else {\n        boundariesNode = boundariesElement;\n      }\n\n      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n        var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n            height = _getWindowSizes.height,\n            width = _getWindowSizes.width;\n\n        boundaries.top += offsets.top - offsets.marginTop;\n        boundaries.bottom = height + offsets.top;\n        boundaries.left += offsets.left - offsets.marginLeft;\n        boundaries.right = width + offsets.left;\n      } else {\n        // for all the other DOM elements, this one is good\n        boundaries = offsets;\n      }\n    } // Add paddings\n\n\n    padding = padding || 0;\n    var isPaddingNumber = typeof padding === 'number';\n    boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n    boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n    return boundaries;\n  }",
  "function rtrim (s, what) {\n                    what = typeof what === 'string' ? what : '\\\\s+';\n                    return s.replace(new RegExp(what + '$'), '');\n                }",
  "async function(library_name) {\n      return (await this.getContribData()).libraries.find(lib => lib.library_name === library_name);\n    }",
  "function ArrayFindIndex(predicate, thisArg) {\n  CHECK_OBJECT_COERCIBLE(this, \"Array.prototype.findIndex\");\n\n  var array = TO_OBJECT(this);\n  var length = TO_INTEGER(array.length);\n\n  return InnerArrayFindIndex(predicate, thisArg, array, length);\n}",
  "function isArgVariadic(val, variadic) {\n    variadic = variadic || constants_1.VARIADIC_CHAR;\n    return isArg(val)\n        && (val.endsWith(variadic + ']')\n            || val.endsWith(variadic + '>'));\n}",
  "function (app) {\n    var ret = false;\n    if (config.apps[app] !== undefined) {\n      delete config.apps[app];\n      configHelpers.saveConfig();\n      ret = true;\n    }\n    return ret;\n  }",
  "function protect_split(separator, str) {\n\t\tvar sep = '######';\n\n\t\tvar string = false;\n\t\tvar nb_brackets = 0;\n\t\tvar new_str = \"\";\n\t\tfor (var i = 0 ; i < str.length ; i++) {\n\t\t\tif (!string && /['\"`]/.test(str[i])) string = str[i];\n\t\t\telse if (string && str[i] == string) string = false;\n\t\t\telse if (!string && str[i] == '(') nb_brackets ++;\n\t\t\telse if (!string && str[i] == ')') nb_brackets --;\n\n\t\t\tif (str[i] == separator && (nb_brackets > 0 || string)) new_str += sep;\n\t\t\telse new_str += str[i];\n\t\t}\n\t\tstr = new_str;\n\n\t\tstr = str.split(separator);\n\t\tstr = str.map(function (item) {\n\t\t\treturn trim(item.replace(new RegExp(sep, 'g'), separator));\n\t\t});\n\n\t\treturn str;\n\t}",
  "function BigIq54LicenseProvider(bigIp, options) {\n    const injectedLogger = options ? options.logger : undefined;\n    let loggerOptions = options ? options.loggerOptions : undefined;\n\n    this.constructorOptions = {};\n    if (options) {\n        Object.keys(options).forEach((option) => {\n            this.constructorOptions[option] = options[option];\n        });\n    }\n\n    if (injectedLogger) {\n        this.logger = injectedLogger;\n        util.setLogger(injectedLogger);\n    } else {\n        loggerOptions = loggerOptions || { logLevel: 'none' };\n        loggerOptions.module = module;\n        this.logger = Logger.getLogger(loggerOptions);\n        util.setLoggerOptions(loggerOptions);\n    }\n\n    this.bigIp = bigIp;\n}",
  "function clientReadyMessage (cookies, user, pass) {\n  return {\n    type: 'connected',\n    user: user,\n    sessionID: cookies.sessionID,\n    pass: pass\n  }\n}",
  "function(table, config) {\n        config = Ext.apply({}, config);\n        table = this.table = Ext.get(table);\n\n        var configFields = config.fields || [],\n            configColumns = config.columns || [],\n            fields = [],\n            cols = [],\n            headers = table.query(\"thead th\"),\n            i = 0,\n            len = headers.length,\n            data = table.dom,\n            width,\n            height,\n            store,\n            col,\n            text,\n            name;\n\n        for (; i < len; ++i) {\n            col = headers[i];\n\n            text = col.innerHTML;\n            name = 'tcol-' + i;\n\n            fields.push(Ext.applyIf(configFields[i] || {}, {\n                name: name,\n                mapping: 'td:nth(' + (i + 1) + ')/@innerHTML'\n            }));\n\n            cols.push(Ext.applyIf(configColumns[i] || {}, {\n                text: text,\n                dataIndex: name,\n                width: col.offsetWidth,\n                tooltip: col.title,\n                sortable: true\n            }));\n        }\n\n        if (config.width) {\n            width = config.width;\n        } else {\n            width = table.getWidth() + 1;\n        }\n\n        if (config.height) {\n            height = config.height;\n        }\n\n        Ext.applyIf(config, {\n            store: {\n                data: data,\n                fields: fields,\n                proxy: {\n                    type: 'memory',\n                    reader: {\n                        record: 'tbody tr',\n                        type: 'xml'\n                    }\n                }\n            },\n            columns: cols,\n            width: width,\n            height: height\n        });\n        this.callParent([config]);\n        \n        if (config.remove !== false) {\n            // Don't use table.remove() as that destroys the row/cell data in the table in\n            // IE6-7 so it cannot be read by the data reader.\n            data.parentNode.removeChild(data);\n        }\n    }",
  "function PreviewThumbnails(player) {\n\t    _classCallCheck(this, PreviewThumbnails);\n\n\t    this.player = player;\n\t    this.thumbnails = [];\n\t    this.loaded = false;\n\t    this.lastMouseMoveTime = Date.now();\n\t    this.mouseDown = false;\n\t    this.loadedImages = [];\n\t    this.elements = {\n\t      thumb: {},\n\t      scrubbing: {}\n\t    };\n\t    this.load();\n\t  }",
  "function( options = {} ) {\n\t\tconst { search, page, number } = options;\n\t\tconst query = {\n\t\t\taction: 'query_themes',\n\t\t\t// Return an `author` object containing `user_nicename` and `display_name` attrs.\n\t\t\t// This is for consistency with WP.com, which always returns the display name as `author`.\n\t\t\t'request[fields][extended_author]': true,\n\t\t\t'request[search]': search,\n\t\t\t'request[page]': page,\n\t\t\t'request[per_page]:': number,\n\t\t};\n\n\t\treturn superagent\n\t\t\t.get( WPORG_THEMES_ENDPOINT )\n\t\t\t.set( 'Accept', 'application/json' )\n\t\t\t.query( query )\n\t\t\t.then( ( { body } ) => body );\n\t}",
  "function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  }",
  "function log(ctx, start, len, err, event) {\n  // get the status code of the response\n  const status = err ? (err.status || 500) : (ctx.status || 404);\n\n  // set the color of the status code;\n  const s = status / 100 | 0;\n  const color = colorCodes[s];\n\n  // get the human readable response length\n  let length;\n  if (~[204, 205, 304].indexOf(status)) {\n    length = \"\";\n  } else if (null == len) {\n    length = \"-\";\n  } else {\n    length = bytes(len);\n  }\n\n  const upstream = err ? chalk.red(\"xxx\")\n    : event === \"end\" ? chalk.yellow(\"-x-\")\n      : chalk.gray(\"-->\");\n\n  logger.debug(`${upstream} ${chalk.bold(ctx.method)} ${chalk.gray(ctx.originalUrl)} ${chalk[color](status)} ${chalk.gray(time(start))} ${chalk.gray(length)}`);\n}",
  "function filterQueryParams (baseClause, request) {\n\t_.forEach(request.query, function(v, k) {\n\t\taddWhereClause(baseClause, k, v)\n\t})\n    return baseClause\n}",
  "function getMailtoUrl(to, fields){\n    this.form.action.match(/mailto:([^\\?&]+)/);\n\n    to = to || RegExp.$1 || '';\n    fields = fields || {\n      subject: this.form.getAttribute('data-subject') || '',\n      body: this.getBody()\n    };\n\n    if (!to && !fields.to){\n      throw new Error('Could not find any person to send an email to.');\n    }\n\n    return 'mailto:'+to+'?'+Object.keys(fields).reduce(function(a, b, i){\n      return a +\n        (i > 0 ? '&' : '') +\n        encodeURIComponent(b) + '=' +\n        encodeURIComponent(fields[b]).replace(/%0A(?!%)/g, '%0D%0A') +    // fixing *nix line break encoding to follow RFC spec\n        (b === 'body' ? '%0D%0A' : '')\n    }, '');\n  }",
  "function(values) {\n        var me = this,\n            v, vLen, val, field;\n\n        function setVal(fieldId, val) {\n            var field = me.findField(fieldId);\n            if (field) {\n                field.setValue(val);\n                if (me.trackResetOnLoad) {\n                    field.resetOriginalValue();\n                }\n            }\n        }\n\n        // Suspend here because setting the value on a field could trigger\n        // a layout, for example if an error gets set, or it's a display field\n        Ext.suspendLayouts();\n        if (Ext.isArray(values)) {\n            // array of objects\n            vLen = values.length;\n\n            for (v = 0; v < vLen; v++) {\n                val = values[v];\n\n                setVal(val.id, val.value);\n            }\n        } else {\n            // object hash\n            Ext.iterate(values, setVal);\n        }\n        Ext.resumeLayouts(true);\n        return this;\n    }",
  "function (propName, state, stateName) {\n        var me = this,\n            value = me[propName],\n            config = me.initialConfig;\n\n        if (me.hasOwnProperty(propName)) {\n            if (!config || config[propName] !== value) {\n                if (state) {\n                    state[stateName || propName] = value;\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
  "function inPosition(index, items) {\n    for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        if (index >= item.start && index <= item.end) return item;\n    }\n    return false;\n}",
  "function errorHandler(err) {\n        // eslint-disable-next-line no-console\n        const logErr = logger ? logger.error.bind(logger) : console.log;\n        if (cluster.isMaster) {\n            logErr(`Error in master with pid: ${process.pid}`);\n        } else {\n            logErr(`Error in worker: ${cluster.worker.id} pid: ${process.pid}`);\n        }\n\n        if (err.message) {\n            logErr(err.message);\n        } else {\n            logErr(err);\n        }\n\n        if (err.stack) {\n            logErr(err.stack);\n        }\n\n        // log saving to disk is async, using hack to give time to flush\n        setTimeout(() => {\n            process.exit(-1);\n        }, 600);\n    }",
  "function(options, code) {\n    var rst = JSON.parse(JSON.stringify(options)); // Let's clone options\n\n    // In the case were source maps are activated, we need to make some verifications\n\n    if (rst.sourceMaps) {\n\n        // 1. If we're processing a block of code, we need to ensure that the block will have a specific source name\n        if (code) {\n            rst.sourceFileName = processSourceFileName(rst.sourceFileName, code);\n        }\n\n        // 2. If the sourceMap options equals to \"inline\" or \"both\", we need to set it to true before processing babel transform\n        // otherwize, the sourceMapUrl will be added by babel to the generated code of each file / block of code.\n        // We will take care to handle the \"inline\" or \"both\" specification when the concatenated code has been fully generated\n        if (rst.sourceMaps === \"inline\" || rst.sourceMaps === \"both\") {\n            rst.sourceMaps = true;\n        }\n    }\n\n    return rst;\n}",
  "function removeImagesFromText( text ) {\n\tconst images = imageInText( text );\n\tconst imageTags = matchStringWithRegex( text, \"</img>\" );\n\n\tif ( images.length > 0 ) {\n\t\timages.forEach( function( image ) {\n\t\t\ttext = text.replace( image, \"\" );\n\t\t} );\n\n\t\timageTags.forEach( function( imageTag ) {\n\t\t\ttext = text.replace( imageTag, \"\" );\n\t\t} );\n\t}\n\n\treturn text;\n}",
  "function doRemoveDatasetClients(datasetClientsToRemove, cb) {\n  var removeIds = _.pluck(datasetClientsToRemove, 'id');\n  var datasetIds = _.uniq(_.pluck(datasetClientsToRemove, 'datasetId'));\n  debug('doRemoveDatasetClients: removed datasetClients = %d, datasets = %d', removeIds.length, datasetIds.length);\n  async.series([\n    function deleteDatasetClientAndRefs(callback) {\n      async.map(removeIds, doRemoveDatasetClientWithRecords, function(err, deleteResult) {\n        if (err) {\n          debug('Failed to delete datasetClients due to error %s', err);\n        }\n        return callback(err, deleteResult);\n      });\n    },\n    function removeUnusedRecords(callback) {\n      async.map(datasetIds, removeRecordsForDataset, function(err, deletedCount) {\n        if (err) {\n          debug('Error occured when delete records for dataset due to error %s', err);\n        }\n        return callback(err, deletedCount);\n      });\n    }\n  ], function(err, results){\n    if (err) {\n      return cb(err);\n    } else {\n      return cb(null, results[0]);\n    }\n  });\n}",
  "function SocketTransport(URL, options) {\n\t\tif (!URL) {\n\t\t\tthrow new Error('A WebSocket URL must be passed to the SocketTransport constructor!');\n\t\t}\n\t\tif (!(this instanceof SocketTransport)) {\n\t\t\treturn new SocketTransport(URL, options);\n\t\t}\n\t\t/**\n\t\t * The URL to use for connecting to the WebSocket server.\n\t\t * Typically, it looks like \"ws://host.tld/path\", where path may be empty.\n\t\t * @type {string}\n\t\t */\n\t\tthis._URL = URL;\n\t\t/**\n\t\t * A map of options to control the transport's behaviour.\n\t\t */\n\t\tthis._options = options || {};\n\t\t/**\n\t\t * The current socket object in use.\n\t\t * Since WebSockets can not be re-used after they have been closed,\n\t\t *  this reference points to the current (i.e. most recent) socket in use.\n\t\t * @type {?external:WebSocket}\n\t\t */\n\t\tthis._socket = null;\n\t\t/**\n\t\t * A descriptive state of the transport, for internal logic use.\n\t\t * This controls the various state transitions.\n\t\t * @type {string}\n\t\t */\n\t\tthis._state = 'unconnected';\n\t\t/**\n\t\t * Whether the transport is active.\n\t\t * True means that the user intends to be connected.\n\t\t * False is when the user has explicitly requested a connection shutdown.\n\t\t * Inactive transports do not attempt reconnection when closed or when an error occurs.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._active = false;\n\t\t/**\n\t\t * The reconnection timeout. Set when an unplanned disconnect occurs.\n\t\t * It is cleared when _deactivate() is called.\n\t\t */\n\t\tthis._reconnectTimeout = null;\n\t\tEventEmitter2.call(this);\n\t\t\n\t\t/**\n\t\t * We store a map of \"standard listeners\" - that is, functions that we are going\n\t\t *  to be adding as event listeners on WebSocket objects.\n\t\t * This way, we have a reference to them, so we can do .removeEventListener().\n\t\t * @type {Object.<string,function>}\n\t\t */\n\t\tvar self = this;\n\t\tvar listeners = {\n\t\t\topen: function() {\n\t\t\t\tself._handleOpen();\n\t\t\t},\n\t\t\terror: function(error) {\n\t\t\t\tself._handleError(error);\n\t\t\t},\n\t\t\tclose: function(closeEvent) {\n\t\t\t\tself._handleDisconnect();\n\t\t\t},\n\t\t\tmessage: function(messageEvent) {\n\t\t\t\tself.emit('message', messageEvent.data);\n\t\t\t}\n\t\t};\n\t\tthis._standardListeners = listeners;\n\t\t\n\t}",
  "function FBOAuth2(appId, appSecret, redirectURL){\n  this._appId = appId;\n  this._appSecret = appSecret;\n  this._redirectURL = redirectURL;\n  this._authURL = 'https://www.facebook.com/dialog/oauth';\n  this._graphAPIURL = 'https://graph.facebook.com';\n  this._accessTokenURI = '/oauth/access_token';\n  this._profileURI = '/me';\n}",
  "function replaceVariable(template, name, value) {\n  let key = `{${name}}`;\n  let reg = new RegExp(helper.escapeRegExp(key), 'g');\n  let encodedReg = new RegExp(helper.escapeRegExp(`{${name}|json}`), 'g');\n  let encodedValue = JSON.stringify(value).replace(/<\\/script/gi, '<\\\\/script');\n\n  return template.replace(reg, value).replace(encodedReg, encodedValue);\n}",
  "function navigate(n) {\n  var position = currentPosition();\n  var numSlides = document.getElementsByClassName('slide').length;\n\n  /* Positions are 1-indexed, so we need to add and subtract 1 */\n  var nextPosition = (position - 1 + n) % numSlides + 1;\n\n  /* Normalize nextPosition in-case of a negative modulo result */\n  nextPosition = (nextPosition - 1 + numSlides) % numSlides + 1;\n\n  document.getElementById('slide-' + position).classList.add('hidden');\n  document.getElementById('slide-' + nextPosition).classList.remove('hidden');\n\n  updateProgress();\n  updateURL();\n  updateTabIndex();\n}",
  "function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n      var $element = $(element);\n      var observable = valueAccessor();\n\n      if (ko.unwrap(observable)) {\n        $element.datepicker('update', observable.datePicker().format('DD.MM.YYYY')); // same as for .datepicker()));\n      }\n    }",
  "function forceResetUserPassword(user) {\n    const deferred = q.defer();\n\n    cryptoUtil.generateRandomBytes(24, 'hex')\n        .then((randomBytes) => {\n            util.runShellCommand(`echo -e \"${randomBytes}\\n${randomBytes}\" | passwd ${user}`);\n            deferred.resolve(randomBytes);\n        })\n        .catch((err) => {\n            deferred.reject(err);\n        });\n    return deferred.promise;\n}",
  "function setupIMA() {\n\t      // Create the container for our advertisements\n\t      this.elements.container = createElement('div', {\n\t        class: this.player.config.classNames.ads\n\t      });\n\t      this.player.elements.container.appendChild(this.elements.container); // So we can run VPAID2\n\n\t      google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED); // Set language\n\n\t      google.ima.settings.setLocale(this.player.config.ads.language); // Set playback for iOS10+\n\n\t      google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline); // We assume the adContainer is the video container of the plyr element that will house the ads\n\n\t      this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media); // Request video ads to be pre-loaded\n\n\t      this.requestAds();\n\t    }",
  "function parse(report, thread) {\n  var rows = [''];\n  var crashed = thread || Utils.get_crash_thread(report);\n\n  if (!crashed) {\n    return rows;\n  }\n\n  var index = crashed['index'];\n  var sys   = report['system'] || {};\n  var type  = sys['binary_cpu_type'];\n  var sub   = sys['binary_cpu_subtype'];\n\n  var arch;\n  if (!type && !sub) {\n    arch = sys['cpu_arch'];\n  } else {\n    arch = CPU.get_cpu_arch(type, sub);\n  }\n\n  var cpu = CPU.get_cpu_type(arch);\n\n  rows.push(`Thread ${index} crashed with ${cpu} Thread State:`);\n\n  var registers = (crashed['registers'] || {})['basic'] || {};\n  var reg_order = CPU.get_registers(cpu);\n\n  var line = '';\n\n  for (var i = 0, j = reg_order.length; i < j; i++) {\n    if (i % 4 === 0 && i !== 0) {\n      rows.push(line);\n      line = '';\n    }\n\n    var register      = reg_order[i];\n    var register_addr = registers[register] || 0;\n    var register_name = Utils.pad_left(register, ' ', 6);\n    var register_loc  = Utils.pad_hex(register_addr, '0', 8);\n    var register_pad  = Utils.pad_right(register_loc, ' ', 9);\n\n    line += `${register_name}: 0x${register_pad}`;\n  }\n\n  if (line) {\n    rows.push(line);\n  }\n\n  return rows;\n}",
  "function configure(pkg, env, target) {\n    const isModule = target === 'module';\n    const input = `src/index.js`;\n    const deps = []\n        .concat(pkg.dependencies ? Object.keys(pkg.dependencies) : [])\n        .concat(pkg.peerDependencies ? Object.keys(pkg.peerDependencies) : []);\n\n    const plugins = [\n        // Allow Rollup to resolve modules from `node_modules`, since it only\n        // resolves local modules by default.\n        resolve({\n            browser: true\n        }),\n\n        // Convert JSON imports to ES6 modules.\n        json(),\n\n        // Replace `process.env.NODE_ENV` with its value, which enables some modules\n        // like React and Slate to use their production variant.\n        replace({\n            'process.env.NODE_ENV': JSON.stringify(env)\n        }),\n\n        // Register Node.js builtins for browserify compatibility.\n        builtins(),\n\n        // Use Babel to transpile the result, limiting it to the source code.\n        babel({\n            include: [`src/**`]\n        }),\n\n        // Register Node.js globals for browserify compatibility.\n        globals()\n    ].filter(Boolean);\n\n    if (isModule) {\n        return {\n            plugins,\n            input,\n            output: [\n                {\n                    file: `${pkg.module}`,\n                    format: 'es',\n                    sourcemap: true\n                },\n                {\n                    file: `${pkg.main}`,\n                    format: 'cjs',\n                    exports: 'named',\n                    sourcemap: true\n                }\n            ],\n            // We need to explicitly state which modules are external, meaning that\n            // they are present at runtime. In the case of non-UMD configs, this means\n            // all non-Slate packages.\n            external: id =>\n                !!deps.find(dep => dep === id || id.startsWith(`${dep}/`))\n        };\n    }\n    return undefined;\n}",
  "function uninstall(name) {\n  if (typeof name !== 'string' || name === '') {\n    throw new TypeError('The algorithm name must be an non-empty string.');\n  }\n\n  const hashFunc = funcs[name];\n\n  if (!hashFunc) {\n    throw new TypeError(`The ${name} algorithm is not installed`);\n  }\n\n  delete funcs[name];\n  queue.splice(queue.indexOf(name), 1);\n}",
  "function UserSettings() {\n\tif ( ! ( this instanceof UserSettings ) ) {\n\t\treturn new UserSettings();\n\t}\n\n\tthis.settings = false;\n\tthis.initialized = false;\n\tthis.reAuthRequired = false;\n\tthis.fetchingSettings = false;\n\tthis.unsavedSettings = {};\n}",
  "function (success, fail, args, env) {\n\t\tvar result = new PluginResult(args, env);\n\t\tresult.ok(passwordCrypto.getInstance().ping(), false);\n\t}",
  "function configureGeojsonSource(glSource, mapView, baseUrl, wrapX, fetchOptions) {\n  const use_bbox = (typeof glSource.data === 'string' && glSource.data.indexOf(BBOX_STRING) >= 0);\n  const vector_src = new VectorSource({\n    strategy: use_bbox ? bboxStrategy : allStrategy,\n    loader: getLoaderFunction(glSource, mapView.getProjection(), baseUrl, fetchOptions),\n    useSpatialIndex: true,\n    wrapX: wrapX,\n  });\n\n  // GeoJson sources can be clustered but OpenLayers\n  // uses a special source type for that. This handles the\n  // \"switch\" of source-class.\n  let new_src = vector_src;\n  if (glSource.cluster) {\n    new_src = new ClusterSource({\n      source: vector_src,\n      // default the distance to 50 as that's what\n      //  is specified by Mapbox.\n      distance: glSource.clusterRadius ? glSource.clusterRadius : 50,\n    });\n  }\n\n  // seed the vector source with the first update\n  //  before returning it.\n  updateGeojsonSource(new_src, glSource, mapView, baseUrl, fetchOptions);\n  return new_src;\n}",
  "function(type) {\n      if (!type) {\n        return null;\n      }\n      if (type.$$type == \"Class\") {\n        return type;\n      }\n      if (type == \"build\") {\n        return qx.tool.compiler.targets.BuildTarget;\n      }\n      if (type == \"source\") {\n        return qx.tool.compiler.targets.SourceTarget;\n      }\n      if (type == \"typescript\") {\n        throw new qx.tool.cli.Utils.UserError(\"Typescript targets are no longer supported - please use `typescript: true` in source target instead\");\n      }\n      if (type) {\n        var targetClass;\n        if (type.indexOf(\".\") < 0) {\n          targetClass = qx.Class.getByName(\"qx.tool.compiler.targets.\" + type);\n        } else {\n          targetClass = qx.Class.getByName(type);\n        }\n        return targetClass;\n      }\n      return null;\n    }",
  "async function getImageDataFromSource(source) {\n  const isStringSource = typeof source === 'string'\n  const isURLSource = isStringSource ? isUrl(source) : false\n  const { tagName } = source\n\n  return new Promise((resolve, reject) => {\n    // String source\n    if (isStringSource) {\n      // Read file in Node.js\n      if (isNode) {\n        Jimp.read(\n          isURLSource ? { url: source, headers: {} } : source,\n          (err, image) => {\n            if (err) {\n              reject(err)\n            } else {\n              const { data, width, height } = image.bitmap\n              resolve({\n                data: data.toJSON().data,\n                width,\n                height,\n              })\n            }\n          }\n        )\n      } else if (isURLSource) {\n        // Load Image from source\n        const img = new Image()\n        img.onerror = reject\n        img.onload = () => resolve(createImageData(img))\n        img.src = source\n      } else {\n        // Find Elment by ID\n        const imgElem = document.getElementById(source)\n        if (imgElem) {\n          resolve(createImageData(imgElem))\n        }\n\n        reject(new Error('Invalid image source specified!'))\n      }\n    } else if (tagName) {\n      // HTML Image element\n      if (tagName === 'IMG') {\n        resolve(createImageData(source))\n      }\n      // HTML Canvas element\n      else if (tagName === 'CANVAS') {\n        resolve(\n          source\n            .getContext('2d')\n            .getImageData(0, 0, source.naturalWidth, source.naturalHeight)\n        )\n      }\n\n      reject(new Error('Invalid image source specified!'))\n    }\n    // Pixel Data\n    else if (source.data && source.width && source.height) {\n      resolve(source)\n    } else {\n      reject(new Error('Invalid image source specified!'))\n    }\n  })\n}",
  "function positionDropdown () {\n    if (!elements) {\n      return $mdUtil.nextTick(positionDropdown, false, $scope);\n    }\n\n    var dropdownHeight = ($scope.dropdownItems || MAX_ITEMS) * ITEM_HEIGHT;\n\n    var hrect  = elements.wrap.getBoundingClientRect(),\n        vrect  = elements.snap.getBoundingClientRect(),\n        root   = elements.root.getBoundingClientRect(),\n        top    = vrect.bottom - root.top,\n        bot    = root.bottom - vrect.top,\n        left   = hrect.left - root.left,\n        width  = hrect.width,\n        offset = getVerticalOffset(),\n        position = $scope.dropdownPosition,\n        styles;\n\n    // Automatically determine dropdown placement based on available space in viewport.\n    if (!position) {\n      position = (top > bot && root.height - top - MENU_PADDING < dropdownHeight) ? 'top' : 'bottom';\n    }\n    // Adjust the width to account for the padding provided by `md-input-container`\n    if ($attrs.mdFloatingLabel) {\n      left += INPUT_PADDING;\n      width -= INPUT_PADDING * 2;\n    }\n    styles = {\n      left:     left + 'px',\n      minWidth: width + 'px',\n      maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'\n    };\n\n    if (position === 'top') {\n      styles.top       = 'auto';\n      styles.bottom    = bot + 'px';\n      styles.maxHeight = Math.min(dropdownHeight, hrect.top - root.top - MENU_PADDING) + 'px';\n    } else {\n      var bottomSpace = root.bottom - hrect.bottom - MENU_PADDING + $mdUtil.getViewportTop();\n\n      styles.top       = (top - offset) + 'px';\n      styles.bottom    = 'auto';\n      styles.maxHeight = Math.min(dropdownHeight, bottomSpace) + 'px';\n    }\n\n    elements.$.scrollContainer.css(styles);\n    $mdUtil.nextTick(correctHorizontalAlignment, false);\n\n    /**\n     * Calculates the vertical offset for floating label examples to account for ngMessages\n     * @returns {number}\n     */\n    function getVerticalOffset () {\n      var offset = 0;\n      var inputContainer = $element.find('md-input-container');\n      if (inputContainer.length) {\n        var input = inputContainer.find('input');\n        offset = inputContainer.prop('offsetHeight');\n        offset -= input.prop('offsetTop');\n        offset -= input.prop('offsetHeight');\n        // add in the height left up top for the floating label text\n        offset += inputContainer.prop('offsetTop');\n      }\n      return offset;\n    }\n\n    /**\n     * Makes sure that the menu doesn't go off of the screen on either side.\n     */\n    function correctHorizontalAlignment () {\n      var dropdown = elements.scrollContainer.getBoundingClientRect(),\n          styles   = {};\n      if (dropdown.right > root.right - MENU_PADDING) {\n        styles.left = (hrect.right - dropdown.width) + 'px';\n      }\n      elements.$.scrollContainer.css(styles);\n    }\n  }",
  "function filterOnDensity( wordCombinations, wordCount, lowerLimit, upperLimit ) {\n\treturn wordCombinations.filter( function( combination ) {\n\t\treturn ( combination.getDensity( wordCount ) >= lowerLimit && combination.getDensity( wordCount ) < upperLimit\n\t\t);\n\t} );\n}",
  "function(cb) {\n              async.each(t.__libraries,\n                  function(library, cb) {\n                    library.scanForClasses(err => {\n                      log.debug(\"Finished scanning for \" + library.getNamespace());\n                      cb(err);\n                    });\n                  },\n                  err => {\n                    log.debug(\"Finished scanning for all libraries\");\n                    cb(err);\n                  });\n            }",
  "function(functionName, node, isClassMember) {\n      this.__scope = {\n        functionName: functionName,\n        parent: this.__scope,\n        vars: {},\n        unresolved: {},\n        isClassMember: !!isClassMember\n      };\n    }",
  "function factory(name, attrs, fn) {\n  if (arguments.length === 2) {\n    fn = attrs;\n    attrs = null;\n  }\n\n  factories.get(name).create(attrs, fn);\n}",
  "function initWxsProcessor(opts, defaultBabelProcessorName) {\n    registerProcessor({\n        name: 'wxs2filter',\n        processor(file, options) {\n            let content = file.content.toString();\n\n            return {\n                content: wxs2filter(content)\n            };\n        },\n        extnames: ['wxs'],\n        rext: 'filter.js'\n    });\n}",
  "function readyCb(cb){\t\n\t\t//if(opened) return\n\t\t//opened = true\n\t\t\n\t\tif(exports.slowGet){//special debug hook - specifies millisecond delay for testing\n\t\t\tsetTimeout(function(){\n\t\t\t\tcb(undefined, api.getView(viewId, historicalKey))\n\t\t\t},exports.slowGet)\n\t\t}else{\n\t\t\tvar viewObj = api.getView(viewId, historicalKey)\n\t\t\tif(!viewObj) _.errout('could not find view object: ' + viewId)\n\t\t\tcb(undefined, viewObj)\n\t\t}\n\t}",
  "function(qName, id) {\n    var q = queue.get(qName);\n    return q.getJob(id).then(function(job) {\n      return job.remove();\n    });\n  }",
  "function (app, callback) {\n    var options = {\n      dir: configHelpers.getModulesPath(),\n      prefix: ''\n    };\n    npm.load(options, function () {\n      npm.commands.uninstall([app], callback);\n    });\n  }",
  "function makePow(left, prev) {\n  if (left.isEmpty()) {\n    return prev;\n  }\n  const elem = left.first();\n  return makePow(\n    left.remove(elem),\n    prev.union(prev.map(e => e.add(elem)))\n  );\n}",
  "function rsaVerify (input, algorithm, publicSecret, signature) {\n  try {\n    // verify with rsa_public_key.pem\n    const verify = crypto.createVerify(algorithm).update(input).verify(\n      publicSecret,\n      base64URLUnescape(signature),\n      'base64'\n    )\n    if (!verify) {\n      errorMap['006'].message = 'Unvalid public secret for rsa verify, signature verification failed'\n      errorMap['006'].error = new Error(errorMap['006'].message)\n    }\n    return verify\n  } catch (e) {\n    errorMap['006'].message = 'Exception error in rsa verify, signature verification failed'\n    errorMap['006'].error = e\n    return false\n  }\n}",
  "function StripeResource(stripe, urlData) {\n  this._stripe = stripe;\n  this._urlData = urlData || {};\n\n  this.basePath = utils.makeURLInterpolator(this.basePath || stripe.getApiField('basePath'));\n  this.resourcePath = this.path;\n  this.path = utils.makeURLInterpolator(this.path);\n\n  if (this.includeBasic) {\n    this.includeBasic.forEach(function(methodName) {\n      this[methodName] = StripeResource.BASIC_METHODS[methodName];\n    }, this);\n  }\n\n  this.initialize.apply(this, arguments);\n}",
  "function getLegalBox(_ref) {\n  var src = _ref.src,\n      box = _ref.box;\n\n  if (isString(box) && box) return box;\n  src = src.toLowerCase();\n  for (var key in boxSuffixMap) {\n    var suffix = boxSuffixMap[key];\n    if (src.indexOf(suffix) > -1) return key;\n  }\n  return 'native';\n}",
  "function setDefaults() {\n    // sequence: generate a random 3-byte integer initial value for the sequence counter\n    if (seq === undefined)\n        seq = ~~(Math.random() * 0xffffff)\n\n    // processId: 2-byte integer derived from the PID assigned by the OS\n    if (pid === undefined)\n        pid = process.pid % 0xffff\n\n    // machineId: first three bytes of the md5 hash calculated from OS hostname\n    if (mid === undefined)\n        mid = crypto.createHash('md5')\n                    .update(os.hostname())\n                    .digest()\n                    .slice(0, 3)\n                    .readUIntBE(0, 3)\n\n    // reset the counter\n    // (if `mid` or `pid` changes then previously allocated ids in the current second are freed)\n    ctr = 0\n\n    // `unique` is the fixed-length composition of `mid` and `pid`\n    unique = pad(mid, 6, 16) + pad(pid, 4, 16)\n\n    // calculate the initial sequence prefix\n    seqpref = pad(~~(seq / 16), 5, 16)\n}",
  "function handleFileSelect(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n\n        // Get the FileList object that contains the list of files that were dropped\n        var files = evt.dataTransfer.files;\n\n        // this UI is only built for a single file so just dump the first one\n        dumpFile(files[0]);\n    }",
  "function(refreshCache) {\n            var result = {},\n                selector;\n\n            if (rules === null || refreshCache) {\n                CSS.refreshCache();\n            }\n            for (selector in rules) {\n                result[selector] = rules[selector].cssRule;\n            }\n            return result;\n        }",
  "function computeInputVariants(str, n) {\n  var variants = [ str ];\n  for (var i = 1; i < n; i++) {\n    var pos = Math.floor(Math.random() * str.length);\n    var chr = String.fromCharCode((str.charCodeAt(pos) + Math.floor(Math.random() * 128)) % 128);\n    variants[i] = str.substring(0, pos) + chr + str.substring(pos + 1, str.length);\n  }\n  return variants;\n}",
  "function (grid, state) {\n        var filters = {};\n        this.filters.each(function (filter) {\n            if (filter.active) {\n                filters[filter.dataIndex] = filter.getValue();\n            }\n        });\n        return (state.filters = filters);\n    }",
  "function getStylesheets(window, options) {\n    if (Array.isArray(options.media) === false) {\n        options.media = [options.media];\n    }\n\n    const media = _.union(['', 'all', 'screen'], options.media);\n    const elements = window.document.querySelectorAll('link[rel=\"stylesheet\"]');\n\n    return Array.prototype.map.call(elements, (link) => ({\n        href: link.getAttribute('href'),\n        media: link.getAttribute('media') || ''\n    }))\n    .filter((sheet) => media.indexOf(sheet.media) !== -1)\n    .map((sheet) => sheet.href);\n}",
  "function default_headers(class_context) {\n  class_context = class_context || {};\n  let headers   = {};\n\n  if (class_context.token) {\n    headers.Token = class_context.token;\n  }\n\n  if (!isBrowser) {\n    headers['User-Agent'] = `Tago-Nodelib-${pkg.version}`;\n  }\n\n  return headers;\n}",
  "function figureOutWhoUserIs(req) {\n      // just stubbing this out here\n      var username = req.query.username\n      if (username === 'skroob') {\n        return {\n          username: username,\n          email: 'pres@skroob.com'\n        }\n      }\n      throw new HttpErrors.Unauthorized()\n    }",
  "function parseOids(options) {\n    if (options.oid) {\n        options.oid = parseSingleOid(options.oid);\n    }\n    if (options.oids) {\n        options.oids = options.oids.map(parseSingleOid);\n    }\n}",
  "function () {\n        var me = this, cfg = {\n            app: me,\n            startConfig: me.getStartConfig()\n        };\n\n        Ext.apply(cfg, me.taskbarConfig);\n        return cfg;\n    }",
  "function transmitDraftId( calypsoPort ) {\n\t// Bail if we are not writing a new post.\n\tif ( ! /wp-admin\\/post-new.php/.test( location.href ) ) {\n\t\treturn;\n\t}\n\n\tconst unsubscribe = subscribe( () => {\n\t\tconst currentPost = select( 'core/editor' ).getCurrentPost();\n\n\t\tif ( currentPost && currentPost.id && currentPost.status !== 'auto-draft' ) {\n\t\t\tcalypsoPort.postMessage( {\n\t\t\t\taction: 'draftIdSet',\n\t\t\t\tpayload: { postId: currentPost.id },\n\t\t\t} );\n\n\t\t\tunsubscribe();\n\t\t}\n\t} );\n}",
  "function findElements() {\n\t    try {\n\t      this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper); // Buttons\n\n\t      this.elements.buttons = {\n\t        play: getElements.call(this, this.config.selectors.buttons.play),\n\t        pause: getElement.call(this, this.config.selectors.buttons.pause),\n\t        restart: getElement.call(this, this.config.selectors.buttons.restart),\n\t        rewind: getElement.call(this, this.config.selectors.buttons.rewind),\n\t        fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),\n\t        mute: getElement.call(this, this.config.selectors.buttons.mute),\n\t        pip: getElement.call(this, this.config.selectors.buttons.pip),\n\t        airplay: getElement.call(this, this.config.selectors.buttons.airplay),\n\t        settings: getElement.call(this, this.config.selectors.buttons.settings),\n\t        captions: getElement.call(this, this.config.selectors.buttons.captions),\n\t        fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen)\n\t      }; // Progress\n\n\t      this.elements.progress = getElement.call(this, this.config.selectors.progress); // Inputs\n\n\t      this.elements.inputs = {\n\t        seek: getElement.call(this, this.config.selectors.inputs.seek),\n\t        volume: getElement.call(this, this.config.selectors.inputs.volume)\n\t      }; // Display\n\n\t      this.elements.display = {\n\t        buffer: getElement.call(this, this.config.selectors.display.buffer),\n\t        currentTime: getElement.call(this, this.config.selectors.display.currentTime),\n\t        duration: getElement.call(this, this.config.selectors.display.duration)\n\t      }; // Seek tooltip\n\n\t      if (is$1.element(this.elements.progress)) {\n\t        this.elements.display.seekTooltip = this.elements.progress.querySelector(\".\".concat(this.config.classNames.tooltip));\n\t      }\n\n\t      return true;\n\t    } catch (error) {\n\t      // Log it\n\t      this.debug.warn('It looks like there is a problem with your custom controls HTML', error); // Restore native video controls\n\n\t      this.toggleNativeControls(true);\n\t      return false;\n\t    }\n\t  }",
  "function decodeLogItem(eventObject, log, useNumberedParams = true) {\n  if (eventObject && log.topics[0] === eventSignature(eventObject)) {\n    return decodeEvent(eventObject, log.data, log.topics, useNumberedParams)\n  }\n}",
  "function _curry1(fn) {\n\t  return function f1(a) {\n\t    if (arguments.length === 0 || _isPlaceholder(a)) {\n\t      return f1;\n\t    } else {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t}",
  "function add(value, model) {\n  var self = this\n  var dict = self.data\n  var codes = model && own.call(dict, model) ? dict[model].concat() : []\n\n  push(dict, value, codes, self)\n\n  return self\n}",
  "function zipDuration(date, duration) {\n  var toSet = {};\n\n  if(duration.getSeconds()) {\n    toSet = {\n      seconds: true,\n      minutes: true,\n      hours: true,\n      days: true,\n      months: true\n    };\n  } else if(duration.getMinutes()) {\n    toSet = {\n      minutes: true,\n      hours: true,\n      days: true,\n      months: true\n    };\n  } else if(duration.getHours()) {\n    toSet = {\n      hours: true,\n      days: true,\n      months: true\n    };\n  } else if(duration.getDays()) {\n    toSet = {\n      days: true,\n      months: true\n    };\n  } else if(duration.getMonths()) {\n    toSet = {\n      months: true\n    };\n  } else {\n    return;\n  }\n\n  if(toSet.seconds && date.seconds == undefined) {\n    date.seconds = 0;\n  }\n\n  if(toSet.minutes && date.minutes == undefined) {\n    date.minutes = 0;\n  }\n\n  if(toSet.hours && date.hours == undefined) {\n    date.hours = 0;\n  }\n\n  if(toSet.days && date.day == undefined) {\n    date.day = 1;\n  }\n\n  if(toSet.months && date.month == undefined) {\n    date.month = 1;\n  }\n\n}",
  "function create(props) {\n    var multiSlider = Object.create(this);\n\n    // apply Widget defaults, then overwrite (if applicable) with MultiSlider defaults\n    _canvasWidget2.default.create.call(multiSlider);\n\n    // ...and then finally override with user defaults\n    Object.assign(multiSlider, MultiSlider.defaults, props);\n\n    // set underlying value if necessary... TODO: how should this be set given min/max?\n    if (props.value) multiSlider.__value = props.value;\n\n    // inherits from Widget\n    multiSlider.init();\n\n    if (props.value === undefined && multiSlider.count !== 4) {\n      for (var i = 0; i < multiSlider.count; i++) {\n        multiSlider.__value[i] = i / multiSlider.count;\n      }\n    } else if (typeof props.value === 'number') {\n      for (var _i = 0; _i < multiSlider.count; _i++) {\n        multiSlider.__value[_i] = props.value;\n      }\n    }\n\n    return multiSlider;\n  }",
  "function getAppAttributes(attrs, req, res) {\n      if (typeof attrs === 'function') {\n        attrs = attrs(req, res);\n      }\n      return attrs || {};\n    }",
  "function keydown (event) {\n    switch (event.keyCode) {\n      case $mdConstant.KEY_CODE.DOWN_ARROW:\n        if (ctrl.loading) return;\n        event.stopPropagation();\n        event.preventDefault();\n        ctrl.index   = Math.min(ctrl.index + 1, ctrl.matches.length - 1);\n        updateScroll();\n        reportMessages(false, ReportType.Selected);\n        break;\n      case $mdConstant.KEY_CODE.UP_ARROW:\n        if (ctrl.loading) return;\n        event.stopPropagation();\n        event.preventDefault();\n        ctrl.index   = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);\n        updateScroll();\n        reportMessages(false, ReportType.Selected);\n        break;\n      case $mdConstant.KEY_CODE.TAB:\n        // If we hit tab, assume that we've left the list so it will close\n        onListLeave();\n\n        if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;\n        select(ctrl.index);\n        break;\n      case $mdConstant.KEY_CODE.ENTER:\n        if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;\n        if (hasSelection()) return;\n        event.stopPropagation();\n        event.preventDefault();\n        select(ctrl.index);\n        break;\n      case $mdConstant.KEY_CODE.ESCAPE:\n        event.preventDefault(); // Prevent browser from always clearing input\n        if (!shouldProcessEscape()) return;\n        event.stopPropagation();\n\n        clearSelectedItem();\n        if ($scope.searchText && hasEscapeOption('clear')) {\n          clearSearchText();\n        }\n\n        // Manually hide (needed for mdNotFound support)\n        ctrl.hidden = true;\n\n        if (hasEscapeOption('blur')) {\n          // Force the component to blur if they hit escape\n          doBlur(true);\n        }\n\n        break;\n      default:\n    }\n  }",
  "function getSyncProgressPercentage( state, siteId ) {\n\tconst syncStatus = getSyncStatus( state, siteId ),\n\t\tqueued = get( syncStatus, 'queue' ),\n\t\tsent = get( syncStatus, 'sent' ),\n\t\ttotal = get( syncStatus, 'total' ),\n\t\tqueuedMultiplier = 0.1,\n\t\tsentMultiplier = 0.9;\n\n\tif ( isPendingSyncStart( state, siteId ) || ! queued || ! sent || ! total ) {\n\t\treturn 0;\n\t}\n\n\tconst countQueued = reduce(\n\t\tqueued,\n\t\t( sum, value ) => {\n\t\t\treturn ( sum += value );\n\t\t},\n\t\t0\n\t);\n\n\tconst countSent = reduce(\n\t\tsent,\n\t\t( sum, value ) => {\n\t\t\treturn ( sum += value );\n\t\t},\n\t\t0\n\t);\n\n\tconst countTotal = reduce(\n\t\ttotal,\n\t\t( sum, value ) => {\n\t\t\treturn ( sum += value );\n\t\t},\n\t\t0\n\t);\n\n\tconst percentQueued = ( countQueued / countTotal ) * queuedMultiplier * 100;\n\tconst percentSent = ( countSent / countTotal ) * sentMultiplier * 100;\n\n\treturn Math.ceil( percentQueued + percentSent );\n}",
  "function valueOrDefault (value, defaultValue, type) {\n        defaultValue = typeof defaultValue === _undefined ? null : defaultValue;\n        var retVal;\n        if (isset(type)) {\n            retVal = issetAndOfType.apply(null, [value].concat(sjl.restArgs(arguments, 2))) ? value : defaultValue;\n        }\n        else {\n            retVal = isset(value) ? value : defaultValue;\n        }\n        return retVal;\n    }",
  "function injectQuery(tokenValue, options, param) {\n    options.url += ~options.url.indexOf('?') ? '&' : '?';\n    options.url += param + '=' + tokenValue;\n}",
  "function wrap(value, wrapper) {\n      if (!isFunction(wrapper)) {\n        throw new TypeError;\n      }\n      return function() {\n        var args = [value];\n        push.apply(args, arguments);\n        return wrapper.apply(this, args);\n      };\n    }",
  "function(status) {\n        // see: https://prototype.lighthouseapp.com/projects/8886/tickets/129-ie-mangles-http-response-status-code-204-to-1223\n        status = status == 1223 ? 204 : status;\n\n        var success = (status >= 200 && status < 300) || status == 304,\n            isException = false;\n\n        if (!success) {\n            switch (status) {\n                case 12002:\n                case 12029:\n                case 12030:\n                case 12031:\n                case 12152:\n                case 13030:\n                    isException = true;\n                    break;\n            }\n        }\n        return {\n            success: success,\n            isException: isException\n        };\n    }",
  "function sh(cmd, exitOnError, cb) {\n  const child = exec(cmd, {\n    encoding: 'utf8',\n    timeout: 1000 * 60 * 2, // 2 min; just want to make sure nothing gets detached forever.\n  });\n  let stdout = '';\n  child.stdout.on('data', (data) => {\n    stdout += data;\n    process.stdout.write(data);\n  });\n  child.stderr.on('data', (data) => {\n    process.stdout.write(data);\n  });\n  child.on('close', (code) => {\n    if (code > 0) {\n      if (exitOnError) {\n        if (typeof cb === 'function') {\n          cb(new Error(`Error with code ${code} after running: ${cmd}`));\n        } else {\n          process.stdout.write(`Error with code ${code} after running: ${cmd} \\n`);\n          process.exit(code);\n        }\n      } else {\n        notifier.notify({\n          title: cmd,\n          message: stdout,\n          sound: true,\n        });\n      }\n    }\n    if (typeof cb === 'function') cb();\n  });\n}",
  "function defaults(dst, src) {\n  forEach(src, function(value, key) {\n    if (!isDefined(dst[key])) {\n      dst[key] = value;\n    }\n  });\n}",
  "function Token (token, clientId) {\n  this.token = token;\n  this.clientId = clientId;\n\n  if (token) {\n    try {\n      const parts = token.split('.');\n      this.header = JSON.parse(Buffer.from(parts[0], 'base64').toString());\n      this.content = JSON.parse(Buffer.from(parts[1], 'base64').toString());\n      this.signature = Buffer.from(parts[2], 'base64');\n      this.signed = parts[0] + '.' + parts[1];\n    } catch (err) {\n      this.content = {\n        exp: 0\n      };\n    }\n  }\n}",
  "function init() {\n  /**\n   * Called on each animation frame\n   */\n  function animate() {\n    render();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderers\n  initRenderer3D(r0);\n  initRenderer2D(r1);\n  initRenderer2D(r2);\n  initRenderer2D(r3);\n\n  // start rendering loop\n  animate();\n}",
  "function(animate){\n        var me = this;\n        me.setVisible(!me.isVisible(), me.anim(animate));\n        return me;\n    }",
  "function (runState) {\n    const [a, b] = runState.stack.popN(2)\n    const r = new BN(a.lt(b) ? 1 : 0)\n    runState.stack.push(r)\n  }",
  "function() {\n\t\t\tvar attrs = [];\n\t\t\t\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element') && _.isArray(res.attributes)) {\n\t\t\t\tattrs = attrs.concat(res.attributes);\n\t\t\t}\n\t\t\t\n\t\t\treturn optimizeAttributes(attrs.concat(this._attributes));\n\t\t}",
  "function throwTypeErrorIfEmpty (prefix, paramName, value, type, suffix) {\n        throwTypeErrorIfEmptyOrNotOfType (prefix, paramName, value, type, suffix);\n    }",
  "function setLoading( state, params, newStatus ) {\n\tconst queries = ( state.queries && { ...state.queries } ) || {};\n\tconst key = getSerializedProductsQuery( params );\n\tqueries[ key ] = { ...( queries[ key ] || {} ), isLoading: newStatus };\n\treturn queries;\n}",
  "function(value, uri) {\n    var _url = new URL(uri);\n    var _params = new URLSearchParams(_url.search.slice(1));\n    if (value === '') {\n      _params.delete('filter');\n    } else {\n      _params.set('filter', value);\n    }\n    _url.search = _params.toString();\n    window.history.replaceState(null, document.title, _url.toString());\n  }",
  "function(c) {  // (note parentheses for precence)\n\t\t\t\tvar cc = ((c.charCodeAt(0)&0x0f)<<12) | ((c.charCodeAt(1)&0x3f)<<6) | ( c.charCodeAt(2)&0x3f);\n\t\t\t\treturn String.fromCharCode(cc); }",
  "function mapException(exception, warningHandler) {\n        try {\n            if(exception instanceof Error) {\n                var stacktrace;\n                return options.getExceptionInfo(exception).then(function(trace){\n                    stacktrace = trace\n\n                    var smcFutures = []\n                    for(var n=0; n<trace.length; n++) {\n                        if(trace[n].file !== undefined) {\n                            smcFutures.push(getSourceMapConsumer(trace[n].file, warningHandler))\n                        } else {\n                            smcFutures.push(Future(undefined))\n                        }\n                    }\n\n                    return Future.all(smcFutures)\n                }).then(function(sourceMapConsumers) {\n                    var CustomMappedException = proto(MappedException, function() {\n                        // set the name so it looks like the original exception when printed\n                        // this subclasses MappedException so that name won't be an own-property\n                        this.name = exception.name\n                    })\n\n                    try {\n                        throw CustomMappedException(exception, stacktrace, sourceMapConsumers)  // IE doesn't give exceptions stack traces unless they're actually thrown\n                    } catch(mappedExcetion) {\n                        return Future(mappedExcetion)\n                    }\n                })\n            } else {\n                return Future(exception)\n            }\n        } catch(e) {\n            var errorFuture = new Future\n            errorFuture.throw(e)\n            return errorFuture\n        }\n    }",
  "function consume_opening_or_closing_tag (proc_stack) {\n  proc_stack.tSkip();\n  let is_closing = proc_stack.tSkipIf(\"/\");\n  let tag_name = proc_stack.tAcceptUntilSet(TAG_NAME_DELIMITER).toLocaleLowerCase();\n  if (!/^[a-z0-9]+(-[a-z0-9]+)*(:[a-z0-9]+(-[a-z0-9]+)*)?$/.test(tag_name)) {\n    throw new SyntaxError(`Invalid HTML tag name \"${tag_name}\"`);\n  }\n\n  if (!is_closing && /^zc-/.test(tag_name)) {\n    return consume_directive_tag(proc_stack, tag_name);\n  }\n\n  let parts = []; // Parts are needed for attribute value directives\n\n  let html = \"<\" + (is_closing ? \"/\" : \"\") + tag_name;\n  let done = false;\n  while (!done) {\n    html += proc_stack.tAcceptUntilSet(ATTR_VAL_START_OR_TAG_END_DELIMITER);\n    let c = proc_stack.tAccept();\n    html += c;\n\n    switch (c) {\n    case \"\\\"\":\n      parts.push(html);\n      Array.prototype.push.apply(parts, consume_char_data_with_entity_directives(proc_stack, false, \"\\\"\"));\n      html = proc_stack.tAccept();\n      break;\n\n    case \">\":\n      done = true;\n      break;\n\n    default:\n      throw new Error(`INTERR Invalid char after ATTR_VAL_START_OR_TAG_END_DELIMITER`);\n    }\n  }\n\n  parts.push(html);\n\n  return parts;\n}",
  "function _createOverlay() {\n        this.overlay = new LayoutController({\n            layout: OverlayLayout,\n            layoutOptions: {\n                itemSize: this.options.wheelLayout.itemSize\n            },\n            dataSource: this._overlayRenderables\n        });\n        this.add(this.overlay);\n    }",
  "function(callback) {\n      var t = this;\n      var className = this.__className;\n      t.__fatalCompileError = false;\n      t.__numClassesDefined = 0;\n\n      fs.readFile(this.getSourcePath(), {encoding: \"utf-8\"}, function(err, src) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        try {\n          let options = t.__analyser.getBabelOptions() || {};\n          options.modules = false;\n          var config = {\n              babelrc: false,\n              sourceFileName : t.getSourcePath(),\n              filename: t.getSourcePath(),\n              sourceMaps: true,\n              \"presets\": [\n                [ require.resolve(\"@babel/preset-env\"), options]\n              ],\n              plugins: [\n                t._babelClassPlugin()\n              ],\n              parserOpts: { sourceType: \"script\" },\n              passPerPreset: true\n            };\n          var result = babelCore.transform(src, config);\n        } catch (ex) {\n          if (ex._babel) {\n            console.log(ex);\n          }\n          t.addMarker(\"compiler.syntaxError\", ex.loc, ex.message, ex.codeFrame);\n          t.__fatalCompileError = true;\n          t._compileDbClassInfo();\n          callback();\n          return;\n        }\n        \n        if (!t.__numClassesDefined) {\n          t.addMarker(\"compiler.missingClassDef\");\n          t.__fatalCompileError = true;\n          t._compileDbClassInfo();\n          callback();\n          return;\n        }\n\n        if (!t.__metaDefinitions[className]) {\n          t.addMarker(\"compiler.wrongClassName\", null, className, Object.keys(t.__metaDefinitions).join(\", \"));\n          t._compileDbClassInfo();\n        }\n\n        var pos = className.lastIndexOf(\".\"); \n        var name = pos > -1 ? className.substring(pos + 1) : className;\n        var outputPath = t.getOutputPath();\n        util.mkParentPath(outputPath, function(err) {\n          if (err) {\n            callback(err);\n            return;\n          }\n          fs.writeFile(outputPath, result.code + \"\\n\\n//# sourceMappingURL=\" + name + \".js.map?dt=\" + (new Date().getTime()), {encoding: \"utf-8\"}, function(err) {\n            if (err) {\n              callback(err);\n              return;\n            }\n            fs.writeFile(outputPath + \".map\", JSON.stringify(result.map, null, 2), {encoding: \"utf-8\"}, function(err) {\n              if (err) {\n                callback(err);\n                return;\n              }\n              t._waitForTaskQueueDrain(function() {\n                callback();\n              });\n            });\n          });\n        });\n      });\n    }",
  "function DatasetClientsCleaner(opts) {\n  this.retentionPeriod = opts.retentionPeriod || '24h';\n  this.checkFrequency = opts.checkFrequency || '1h';\n  this.cleanerLockName = opts.cleanerLockName || 'locks:sync:DatasetCleaner';\n  this.lockTimeout = parseDuration(this.checkFrequency) / 2;\n  this.job;\n}",
  "function match({ just, nothing }) {\r\n    return function (maybe) {\r\n        for (const value of maybe) {\r\n            return just(value);\r\n        }\r\n        return nothing();\r\n    };\r\n}",
  "function(recipientPrivate, senderPublic, _payload) {\n    // Errorsp\n    if(!recipientPrivate || !senderPublic || !_payload) throw new Error('Missing argument !');\n    // Processing\n    let binPayload = convert.hexToUint8(_payload);\n    let salt = new Uint8Array(binPayload.buffer, 0, 32);\n    let iv = new Uint8Array(binPayload.buffer, 32, 16);\n    let payload = new Uint8Array(binPayload.buffer, 48);\n\n    let keyPair = createKeyPairFromPrivateKeyString(recipientPrivate);\n    let pk = convert.hexToUint8(senderPublic);\n    let encKey = deriveSharedKey(keyPair, pk, salt);\n    let encIv = {\n        iv: ua2words(iv, 16)\n    };\n    let encrypted = {\n        'ciphertext': ua2words(payload, payload.length)\n    };\n    let plain = CryptoJS.AES.decrypt(encrypted, encKey, encIv);\n    // Result\n    let hexplain = CryptoJS.enc.Hex.stringify(plain);\n    return hexplain;\n}",
  "function init() {\r\n\ttinyMCEPopup.resizeToInnerSize();\r\n\tvar inst = tinyMCEPopup.editor;\r\n\tvar dom = inst.dom;\r\n\tvar elm = inst.selection.getNode();\r\n\tvar f = document.forms[0];\r\n\tvar onclick = dom.getAttrib(elm, 'onclick');\r\n\r\n\tsetFormValue('title', dom.getAttrib(elm, 'title'));\r\n\tsetFormValue('id', dom.getAttrib(elm, 'id'));\r\n\tsetFormValue('style', dom.getAttrib(elm, \"style\"));\r\n\tsetFormValue('dir', dom.getAttrib(elm, 'dir'));\r\n\tsetFormValue('lang', dom.getAttrib(elm, 'lang'));\r\n\tsetFormValue('tabindex', dom.getAttrib(elm, 'tabindex', typeof(elm.tabindex) != \"undefined\" ? elm.tabindex : \"\"));\r\n\tsetFormValue('accesskey', dom.getAttrib(elm, 'accesskey', typeof(elm.accesskey) != \"undefined\" ? elm.accesskey : \"\"));\r\n\tsetFormValue('onfocus', dom.getAttrib(elm, 'onfocus'));\r\n\tsetFormValue('onblur', dom.getAttrib(elm, 'onblur'));\r\n\tsetFormValue('onclick', onclick);\r\n\tsetFormValue('ondblclick', dom.getAttrib(elm, 'ondblclick'));\r\n\tsetFormValue('onmousedown', dom.getAttrib(elm, 'onmousedown'));\r\n\tsetFormValue('onmouseup', dom.getAttrib(elm, 'onmouseup'));\r\n\tsetFormValue('onmouseover', dom.getAttrib(elm, 'onmouseover'));\r\n\tsetFormValue('onmousemove', dom.getAttrib(elm, 'onmousemove'));\r\n\tsetFormValue('onmouseout', dom.getAttrib(elm, 'onmouseout'));\r\n\tsetFormValue('onkeypress', dom.getAttrib(elm, 'onkeypress'));\r\n\tsetFormValue('onkeydown', dom.getAttrib(elm, 'onkeydown'));\r\n\tsetFormValue('onkeyup', dom.getAttrib(elm, 'onkeyup'));\r\n\tclassName = dom.getAttrib(elm, 'class');\r\n\r\n\taddClassesToList('classlist', 'advlink_styles');\r\n\tselectByValue(f, 'classlist', className, true);\r\n\r\n\tTinyMCE_EditableSelects.init();\r\n}",
  "function (plugin, manifest) {\n    if (config.plugins === undefined) {\n      config.plugins = {};\n    }\n\n    config.plugins[plugin] = {\n      name: manifest.name,\n      displayName: manifest.displayName,\n      version: manifest.version,\n      description: manifest.description\n    };\n    configHelpers.saveConfig();\n  }",
  "function loadUsrInfo(token, app, zlSite, next) {\n  app.models.zlUser.findById(token.userId, (err, usr) => {\n    if (err) next(err);\n    else if (usr) {\n      zlSite.user = _.cloneDeep(usr);\n      if (!zlSite.user.usrPhoto && zlSite.user.email) {\n        // use gravatar\n        let graHash = md5(zlSite.user.email.toLowerCase());\n        zlSite.user.usrPhoto = `https://www.gravatar.com/avatar/${graHash}?s=100&d=mm`\n      }\n      next();\n    }\n    else {\n      // user must no longer exist\n      next();\n    }\n  });\n}",
  "function(data) {\n\t\tvar key = hash_key(data[this.settings.valueField]);\n\t\tif (typeof key === 'undefined' || key === null || this.options.hasOwnProperty(key)) return false;\n\t\tdata.$order = data.$order || ++this.order;\n\t\tthis.options[key] = data;\n\t\treturn key;\n\t}",
  "function logMessage (message, data) {\n  if (!message) return\n  render(message, data, function (err, res) {\n    if (err) {\n      console.error('\\n   Error when rendering template complete message: ' + err.message.trim())\n    } else {\n      console.log(`\\nTo get started:`)\n      console.log('')\n      console.log(`${chalk.gray('  ------------------')}`)\n      console.log('  ' + res.split(/\\r?\\n/g).map(function (line) {\n        return `${chalk.blue(line)}`\n      }).join('\\n'))\n      console.log(`${chalk.gray('  ------------------')}`)\n      console.log('')\n      console.log(`More infomation: ${chalk.blue.underline('fe -h')}`)\n    }\n  })\n}",
  "function(name) {\n\t\t\tif (_.isNumber(name))\n\t\t\t\treturn this.list()[name];\n\t\t\t\n\t\t\tif (_.isString(name))\n\t\t\t\treturn _.find(this.list(), function(prop) {\n\t\t\t\t\treturn prop.name() === name;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn name;\n\t\t}",
  "function Event(a, b, type, idx) {\n  this.a    = a\n  this.b    = b\n  this.type = type\n  this.idx  = idx\n}",
  "function auth (req) {\n  if (!req) {\n    throw new TypeError('argument req is required')\n  }\n\n  if (typeof req !== 'object') {\n    throw new TypeError('argument req is required to be an object')\n  }\n\n  // get header\n  var header = getAuthorization(req)\n\n  // parse header\n  return parse(header)\n}",
  "function (state) {\n        var me = this;\n        if (me.readyState != state) {\n            me.readyState = state;\n            me.onreadystatechange();\n        }\n    }",
  "function(index) {\n        var range = this._visibleRange(),\n            dm    = this.metrics().rowDimensions(index),\n            maxY  = dm.top + dm.height,\n            minY  = dm.top;\n\n        if (maxY >= range.to) {\n            this.scrollableParent().scroll(0, maxY - range.to +\n                // hackish overflow to compensate for bottom scroll bar\n                (index === this.data().length - 1 ? 100 : 0)\n            );\n        } else if (minY < range.from) {\n            this.scrollableParent().scroll(0, minY - range.from);\n        }\n        this._wrappedUpdate();\n        return this;\n    }",
  "function oldVideoTimeupdate() {\n              var currentTime = _this2.kernel.currentTime;\n              if (bias <= 0 && currentTime >= idealTime || bias > 0 && (Math.abs(idealTime - currentTime) <= bias && newVideoReady || currentTime - idealTime > bias)) {\n                chimeeHelper.removeEvent(_this2.dom.videoElement, 'timeupdate', oldVideoTimeupdate);\n                chimeeHelper.removeEvent(video, 'error', _videoError, true);\n                if (!newVideoReady) {\n                  chimeeHelper.removeEvent(video, 'canplay', videoCanplay, true);\n                  chimeeHelper.removeEvent(video, 'loadedmetadata', videoLoadedmetadata, true);\n                  kernel.destroy();\n                  return resolve();\n                }\n                return reject({\n                  error: false,\n                  video: video,\n                  kernel: kernel\n                });\n              }\n            }",
  "function Mailto(form, options){\n  /**\n   *\n   * @type {HTMLElement}\n   */\n  this.form = null;\n\n  /**\n   *\n   * @type {boolean}\n   */\n  this.preventDefault = true;\n\n  /**\n   *\n   * @type {Function}\n   */\n  this.formatter = Mailto.defaultFormatter;\n\n  /**\n   *\n   * @type {Function}\n   */\n  this.onSubmit = function(m){};\n\n  this.initFormObject(form);\n  this.initOptions(options);\n  this.initFormHandler();\n}",
  "function merge(obj) {\n    for (var i=1; i < arguments.length; i++) {\n      var def = arguments[i]\n      for (var n in def)\n        if (obj[n] === undefined) obj[n] = def[n]\n    }\n    return obj\n  }",
  "function classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(className);\n\t\tvar range = require('range');\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}",
  "function checkNodesIndent(nodes, indent, excludeCommas) {\n\t\tnodes.forEach(function(node) {\n\t\t\tif (node.type === \"IfStatement\" && node.alternate) {\n\t\t\t\tvar elseToken = context.getTokenBefore(node.alternate);\n\t\t\t\tcheckNodeIndent(elseToken, indent, excludeCommas);\n\t\t\t}\n\t\t\tcheckNodeIndent(node, indent, excludeCommas);\n\t\t});\n\t}",
  "function tokenize(content) {\n    var tokens = [];\n    var parser = new htmlparser.Parser({\n        onopentag: function(name, attribs) { },\n        ontext: function(text) {\n            var start = parser.startIndex;\n\n            tokens.push({\n                value: text,\n                index: start,\n                offset: text.length\n            });\n        },\n        onclosetag: function(tagname) { }\n    });\n    parser.write(content);\n    parser.end();\n\n    return tokens;\n}",
  "function update_db(p, stats, _cb) {\n        var key = sprintf(FILES_KEY_FMT, p);\n        var k1 = sprintf(FHANDLE_KEY_FMT, p);\n        var k2 = sprintf(FNAME_KEY_FMT, stats._fhandle);\n\n        self.db.batch()\n            .put(key, stats)\n            .put(k1, stats._fhandle)\n            .put(k2, p)\n            .write(function onBatchWrite(err2) {\n                if (err2) {\n                    log.error(err2, 'update_db(%s): failed', p);\n                    _cb(errno(err2));\n                } else {\n                    log.trace('update_db(%s): done', p);\n                    self.cache.set(key, stats);\n                    _cb(null);\n                }\n            });\n    }",
  "function() {\n        var rect = this.element.getClientRects()[0];\n\n        this.completer.style.top = rect.top + 'px';\n        var height = rect.bottom - rect.top;\n        this.completer.style.height = height + 'px';\n        this.completer.style.lineHeight = height + 'px';\n        this.completer.style.left = rect.left + 'px';\n        var width = rect.right - rect.left;\n        this.completer.style.width = width + 'px';\n\n        if (this.hintDirection.get() === 'below') {\n            this.hinter.style.top = rect.bottom + 'px';\n            this.hinter.style.bottom = 'auto';\n        }\n        else {\n            this.hinter.style.top = 'auto';\n            this.hinter.style.bottom = (this.doc.documentElement.clientHeight - rect.top) + 'px';\n        }\n        this.hinter.style.left = (rect.left + 30) + 'px';\n        this.hinter.style.maxWidth = (width - 110) + 'px';\n\n        if (this.popupOutput) {\n            if (this.outputDirection.get() === 'below') {\n                this.output.style.top = rect.bottom + 'px';\n                this.output.style.bottom = 'auto';\n            }\n            else {\n                this.output.style.top = 'auto';\n                this.output.style.bottom = (this.doc.documentElement.clientHeight - rect.top) + 'px';\n            }\n            this.output.style.left = rect.left + 'px';\n            this.output.style.width = (width - 80) + 'px';\n        }\n    }",
  "function fillData(props, datasets) {\n  const { fillInMissingData } = props;\n  const xMap = datasets.reduce((prev, dataset) => {\n    dataset.forEach((datum) => {\n      prev[datum._x instanceof Date ? datum._x.getTime() : datum._x] = true;\n    });\n    return prev;\n  }, {});\n  const xKeys = keys(xMap).map((k) => +k);\n  const xArr = orderBy(xKeys);\n\n  return datasets.map((dataset) => {\n    let indexOffset = 0;\n    const isDate = dataset[0] && dataset[0]._x instanceof Date;\n    const filledInData = xArr.map((x, index) => {\n      x = +x;\n      const datum = dataset[index - indexOffset];\n\n      if (datum) {\n        const x1 = isDate ? datum._x.getTime() : datum._x;\n        if (x1 === x) {\n          return datum;\n        } else {\n          indexOffset++;\n          const y = fillInMissingData ? 0 : null;\n          x = isDate ? new Date(x) : x;\n          return { x, y, _x: x, _y: y };\n        }\n      } else {\n        const y = fillInMissingData ? 0 : null;\n        x = isDate ? new Date(x) : x;\n        return { x, y, _x: x, _y: y };\n      }\n    });\n\n    return filledInData;\n  });\n}",
  "function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new(tree.Dimension)(value[1], value[2]);\n                    }\n                }",
  "function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}",
  "function computeNodeDepths(graph) {\n    var nodes, next, x;\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.depth = x;\n        node.sourceLinks.forEach(function (link) {\n          if (next.indexOf(link.target) < 0 && !link.circular) {\n            next.push(link.target);\n          }\n        });\n      });\n    }\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.height = x;\n        node.targetLinks.forEach(function (link) {\n          if (next.indexOf(link.source) < 0 && !link.circular) {\n            next.push(link.source);\n          }\n        });\n      });\n    }\n\n    // assign column numbers, and get max value\n    graph.nodes.forEach(function (node) {\n      node.column = Math.floor(align.call(null, node, x));\n    });\n  }",
  "function getMaxFromProps(props, axis) {\n  if (isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" ? props.maxDomain : undefined;\n}",
  "function(sourceEditMode) {\n        var me = this,\n            iframe = me.iframeEl,\n            textarea = me.textareaEl,\n            hiddenCls = Ext.baseCSSPrefix + 'hidden',\n            btn = me.getToolbar().getComponent('sourceedit');\n\n        if (!Ext.isBoolean(sourceEditMode)) {\n            sourceEditMode = !me.sourceEditMode;\n        }\n        me.sourceEditMode = sourceEditMode;\n\n        if (btn.pressed !== sourceEditMode) {\n            btn.toggle(sourceEditMode);\n        }\n        if (sourceEditMode) {\n            me.disableItems(true);\n            me.syncValue();\n            iframe.addCls(hiddenCls);\n            textarea.removeCls(hiddenCls);\n            textarea.dom.removeAttribute('tabIndex');\n            textarea.focus();\n            me.inputEl = textarea;\n        } else {\n            if (me.initialized) {\n                me.disableItems(me.readOnly);\n            }\n            me.pushValue();\n            iframe.removeCls(hiddenCls);\n            textarea.addCls(hiddenCls);\n            textarea.dom.setAttribute('tabIndex', -1);\n            me.deferFocus();\n            me.inputEl = iframe;\n        }\n        me.fireEvent('editmodechange', me, sourceEditMode);\n        me.updateLayout();\n    }",
  "function raw(incomingData, logger, opConfig, metadata, slice) {\n    const data = _toRecords(incomingData, opConfig.line_delimiter, slice);\n    return data.map((record) => {\n        try {\n            return DataEntity.make(\n                { data: record },\n                metadata\n            );\n        } catch (err) {\n            if (opConfig._dead_letter_action === 'log') {\n                logger.error(err, 'Bad record:', record);\n            } else if (opConfig._dead_letter_action === 'throw') {\n                throw err;\n            }\n            return null;\n        }\n    });\n}",
  "function(store, initial) {\n        var me = this;\n        me.mixins.bindable.bindStore.apply(me, arguments);\n        store = me.store;\n        if (store && store.isLoading()) {\n            me.onBeforeLoad();\n        }\n    }",
  "function interceptWriteStream(writeStream) {\n\treturn new Promise((resolve, reject) => {\n\t\tlet response = \"\";\n\t\tlet writeBkp = writeStream.write;\n\t\tlet sendBkp = writeStream.send; // For express response streams\n\t\tlet endBkp = writeStream.end;\n\n\t\twriteStream.write = function(chunk, encoding, callback) {\n\t\t\tresponse += chunk;\n\n\t\t\tif(typeof encoding == \"function\") {\n\t\t\t\tencoding();\n\t\t\t} else if(callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\twriteStream.send = function(body) {\n\t\t\twriteStream.end(body);\n\t\t};\n\n\t\twriteStream.end = function(chunk, encoding, callback) {\n\t\t\tif(chunk) {\n\t\t\t\tresponse += chunk;\n\t\t\t}\n\n\t\t\twriteStream.write = writeBkp;\n\t\t\twriteStream.send = sendBkp;\n\t\t\twriteStream.end = endBkp;\n\n\t\t\tif(typeof encoding == \"function\") {\n\t\t\t\twriteStream.once(\"finish\", encoding);\n\t\t\t} else if(callback) {\n\t\t\t\twriteStream.once(\"finish\", encoding);\n\t\t\t}\n\n\t\t\tresolve(response);\n\t\t};\n\t});\n}",
  "function empty (entity, schema, Empty) {\n  if (typeof entity === 'undefined' || entity === null) {\n    return\n  }\n  _.forEach(schema, function(v, k) {\n    if (v === Empty) {\n      delete entity[k]\n    }\n  })\n}",
  "function PagerDuty(options, log) {\n  var parsed = url.parse(options.url);\n  delete parsed.host;\n  this.url = url.format(parsed);\n\n  this.users = options.users;\n  this.schedules = options.schedules;\n  this.log = log || logmagic.local('pagerduty');\n  this.pagerduty_auth = sprintf('Token token=%s', options.password);\n}",
  "function BinaryConstraint(var1, var2, strength) {\n  BinaryConstraint.superConstructor.call(this, strength);\n  this.v1 = var1;\n  this.v2 = var2;\n  this.direction = Direction.NONE;\n  this.addConstraint();\n}",
  "function(array) {\n            var len = arguments.length,\n                i = 1,\n                newItem;\n\n            if (array === undefined) {\n                array = [];\n            } else if (!Ext.isArray(array)) {\n                array = [array];\n            }\n            for (; i < len; i++) {\n                newItem = arguments[i];\n                Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](array, newItem);\n            }\n            return array;\n        }",
  "function shouldAddSympathy() {\n\t// If `force-sympathy` flag is enabled, always clear persistent state.\n\tif ( config.isEnabled( 'force-sympathy' ) ) {\n\t\treturn true;\n\t}\n\n\t// If `no-force-sympathy` flag is enabled, never clear persistent state.\n\tif ( config.isEnabled( 'no-force-sympathy' ) ) {\n\t\treturn false;\n\t}\n\n\t// Otherwise, in development mode, clear persistent state 25% of the time.\n\tif ( 'development' === process.env.NODE_ENV && Math.random() < 0.25 ) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, do not clear persistent state.\n\treturn false;\n}",
  "function(cb) {\n      var t = this;\n      if (!this.__db) {\n        this.__db = {};\n      }\n      async.parallel(\n          [\n            // Load Resources\n            function(cb) {\n              if (!t.__resManager) {\n                cb(null);\n                return;\n              }\n\n              t.__resManager.findAllResources(function(err) {\n                if (err) {\n                  cb(err);\n                  return;\n                }\n                log.debug(\"found all resources\");\n                cb(null);\n              });\n            },\n\n            // Find all classes\n            function(cb) {\n              async.each(t.__libraries,\n                  function(library, cb) {\n                    library.scanForClasses(err => {\n                      log.debug(\"Finished scanning for \" + library.getNamespace());\n                      cb(err);\n                    });\n                  },\n                  err => {\n                    log.debug(\"Finished scanning for all libraries\");\n                    cb(err);\n                  });\n            }\n          ],\n          function(err) {\n            log.debug(\"processed source and resources\");\n            cb(err);\n          });\n    }",
  "function unConfigurableNamespace(ns_string, objToSearch, valueToSet) {\n        var parent = objToSearch,\n            shouldSetValue = typeof valueToSet !== _undefined,\n            hasOwnProperty;\n\n        ns_string.split('.').forEach(function (key, i, parts) {\n            hasOwnProperty = parent.hasOwnProperty(key);\n            if (i === parts.length - 1\n                && shouldSetValue && !hasOwnProperty) {\n                defineEnumProp(parent, key, valueToSet);\n            }\n            else if (typeof parent[key] === _undefined && !hasOwnProperty) {\n                defineEnumProp(parent, key, {});\n            }\n            parent = parent[key];\n        });\n\n        return parent;\n    }",
  "function lazyConsForce() {\n  /* jshint validthis:true */\n  var val = this.tailFn();\n  /* eslint-disable no-use-before-define */\n  this.tailValue = Array.isArray(val) ? fromArray(val) : val;\n  /* eslint-enable no-use-before-define */\n\n  delete this.tail;\n  delete this.force;\n\n  return this;\n}",
  "function karmaEsmFramework(karmaConfig, karmaEmitter) {\n  if (!karmaConfig.files.some(file => file.type === 'module')) {\n    throw new Error(\n      \"Did not find any test files with type='module'.\" +\n        \"Follow this format: { pattern: config.grep ? config.grep : 'test/**/*.test.js', type: 'module' }\",\n    );\n  }\n\n  initialize(karmaConfig, karmaEmitter);\n}",
  "function advance(id, t) {\n        switch (token.id) {\n        case '(number)':\n            if (nexttoken.id === '.') {\n                warning(\n\"A dot following a number can be confused with a decimal point.\", token);\n            }\n            break;\n        case '-':\n            if (nexttoken.id === '-' || nexttoken.id === '--') {\n                warning(\"Confusing minusses.\");\n            }\n            break;\n        case '+':\n            if (nexttoken.id === '+' || nexttoken.id === '++') {\n                warning(\"Confusing plusses.\");\n            }\n            break;\n        }\n        if (token.type === '(string)' || token.identifier) {\n            anonname = token.value;\n        }\n\n        if (id && nexttoken.id !== id) {\n            if (t) {\n                if (nexttoken.id === '(end)') {\n                    warning(\"Unmatched '{a}'.\", t, t.id);\n                } else {\n                    warning(\n\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n                            nexttoken, id, t.id, t.line, nexttoken.value);\n                }\n            } else if (nexttoken.type !== '(identifier)' ||\n                            nexttoken.value !== id) {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, id, nexttoken.value);\n            }\n        }\n        prevtoken = token;\n        token = nexttoken;\n        for (;;) {\n            nexttoken = lookahead.shift() || lex.token();\n            if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {\n                return;\n            }\n            if (nexttoken.type === 'special') {\n                doOption();\n            } else {\n                if (nexttoken.id !== '(endline)') {\n                    break;\n                }\n            }\n        }\n    }",
  "function () {\n                var entities = this.entities;\n\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||\n                    entities.javascript();\n            }",
  "function (subject) {\n    var target = kb.any(subject, ns.meeting('target')) || subject\n    var count = kb.each(target, predicate).length\n    if (count > 0) {\n      return UI.utils.label(predicate) + ' ' + count\n    }\n    return null\n  }",
  "function pipeStream(...args) {\n  const src = args.shift();\n\n  return new Promise((resolve, reject) => {\n    let stream = src.on('error', reject);\n    let target;\n\n    while ((target = args.shift()) != null) {\n      stream = stream.pipe(target).on('error', reject);\n    }\n\n    stream.on('finish', resolve);\n    stream.on('end', resolve);\n    stream.on('close', resolve);\n  });\n}",
  "function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createBound(func, 4, null, null, null, arity);\n    }",
  "function scrollIntoViewport( element ) {\n\tconst elementStartY = recursivelyWalkAndSum( element, 'offsetTop', 'offsetParent' ),\n\t\telementEndY = elementStartY + element.offsetHeight;\n\tif ( isInViewportRange( elementStartY, elementEndY ) ) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\twindow.scroll( {\n\t\t\ttop: elementStartY,\n\t\t\tleft: 0,\n\t\t\tbehavior: 'smooth',\n\t\t} );\n\t} catch ( e ) {\n\t\twindow.scrollTo( 0, elementStartY );\n\t}\n}",
  "function ArgumentStatement(args, options, define) {\n    options = options || {};\n    this.value = args;\n    this.flags = {};\n    this.args = [];\n    this.options = options;\n\n    if (typeof options.parse === 'undefined') options.parse = true;\n    if (typeof options.separator === 'undefined') options.separator = ',';\n    if (typeof options.parseArgs === 'undefined') options.parseArgs = true;\n\n    if (options.parse) {\n        if (options.flags) {\n            var isFlag = true;\n\n            // Find all matching flags  until no flag is found\n            while(isFlag) {\n                var firstFlagEnd = args.indexOf(' ');\n                if (firstFlagEnd === -1) firstFlagEnd = args.length;\n                var firstFlag = args.substring(0, firstFlagEnd).trim().toUpperCase();\n\n                if (options.flags.indexOf(firstFlag) !== -1) {\n                    this.flags[firstFlag] = true;\n                    args = args.substring(firstFlagEnd).trim();\n                }\n                else isFlag = false;\n            }\n        }\n\n        this.rawArgs = args;\n\n        args = args.trim();\n        var argList = [args];\n        if (options.separator) {\n            if (!args.length) argList = [];\n            else {\n                var positions = util.findPositions(args, [\n                    {'start': '\"', 'end': '\"'},\n                    {'start': '(', 'end': ')'}\n                ]);\n                argList = util.splitOutside(args, options.separator, positions);\n            }\n        }\n        for (var i = 0; i < argList.length; i++) {\n            var arg = argList[i].trim();\n            if (options.parseArgs) arg = new statements.ExpressionStatement(arg, define);\n            this.args.push(arg);\n        }\n    }\n}",
  "function processFile(file, processor, buildManager) {\n    let {compileContext, logger} = buildManager;\n    let {handler, options: opts, rext} = processor;\n    logger.debug(`compile file ${file.path}, using ${processor.name}: `, opts);\n\n    let result = handler(file, Object.assign({\n        config: opts\n    }, compileContext));\n    if (!result) {\n        return;\n    }\n\n    rext && (file.rext = rext);\n\n    if (isPromise(result)) {\n        buildManager.addAsyncTask(file, result);\n        return;\n    }\n\n    if (result.isSfcComponent) {\n        compileComponent(result, file, buildManager);\n        result = {content: file.content};\n    }\n    buildManager.updateFileCompileResult(file, result);\n}",
  "function(action){\n\n        var url;\n        var error;\n\n        // Iterate over the routes, looking for a match.\n        var routes = this.getRoutes();\n        for (var i = 0; url === undefined && i < routes.length; i++){\n\n            try {\n\n                // Simplify access.\n                var route = routes[i];\n\n                // Check the controller + method. If we find one, figure out the URL to return.\n                if (action == route.controller + '.' + route.method){\n\n                    var params = [];\n\n                    // If there are parameters, bind them.\n                    if (arguments.length > 1) {\n\n                        // Turn them into a proper array.\n                        params = Array.prototype.slice.apply(arguments);\n\n                        // And drop the first entry (which was the action itself).\n                        params = params.slice(1);\n                    }\n\n                    // We always call bind, even with an empty array, to see if we generate an error.\n                    url = this.bindUrl(route.path, params);\n                }\n            }\n\n            catch(e) {\n\n                // Store the error in case we need to rethrow it.\n                error = e;\n            }\n\n        }\n\n        // If we found a match, return it.\n        if (url !== undefined) {\n            return url;\n        }\n\n        // Otherwise, throw an exception.\n        else {\n\n            // If we captured an earlier error, reuse that (since it implies we found a match but couldn't bind it).\n            if (error !== undefined) {\n                throw error;\n            }\n\n            else {\n                throw new Error(\"No matching action was found.\");\n            }\n        }\n    }",
  "function deleteInvites( siteInvites, invitesToDelete ) {\n\treturn siteInvites.filter( siteInvite => ! includes( invitesToDelete, siteInvite.key ) );\n}",
  "function( values ) {\n\tthis._hasScore = false;\n\tthis._identifier = \"\";\n\tthis._hasMarks = false;\n\tthis._marker = emptyMarker;\n\tthis.score = 0;\n\tthis.text = \"\";\n\tthis.marks = [];\n\n\tif ( isUndefined( values ) ) {\n\t\tvalues = {};\n\t}\n\n\tif ( ! isUndefined( values.score ) ) {\n\t\tthis.setScore( values.score );\n\t}\n\n\tif ( ! isUndefined( values.text ) ) {\n\t\tthis.setText( values.text );\n\t}\n\n\tif ( ! isUndefined( values.marks ) ) {\n\t\tthis.setMarks( values.marks );\n\t}\n}",
  "function run(js, path) {\n  var m = new Module(path, module)\n  Module._findPath = findPath\n  m.paths = Module._nodeModulePaths(dirname(path))\n  m.id = path\n  m.filename = path\n  js = 'module.return=eval(' + json(js) + ')'\n  m._compile(js, path)\n  Module._findPath = originalFindPath\n  return m\n}",
  "function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n  buf[p++] = min_code_size;\n  var cur_subblock = p++;  // Pointing at the length field.\n\n  var clear_code = 1 << min_code_size;\n  var code_mask = clear_code - 1;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  var cur_shift = 0;\n  // We have at most 12-bit codes, so we should have to hold a max of 19\n  // bits here (and then we would write out).\n  var cur = 0;\n\n  function emit_bytes_to_buffer(bit_block_size) {\n    while (cur_shift >= bit_block_size) {\n      buf[p++] = cur & 0xff;\n      cur >>= 8; cur_shift -= 8;\n      if (p === cur_subblock + 256) {  // Finished a subblock.\n        buf[cur_subblock] = 255;\n        cur_subblock = p++;\n      }\n    }\n  }\n\n  function emit_code(c) {\n    cur |= c << cur_shift;\n    cur_shift += cur_code_size;\n    emit_bytes_to_buffer(8);\n  }\n\n  // I am not an expert on the topic, and I don't want to write a thesis.\n  // However, it is good to outline here the basic algorithm and the few data\n  // structures and optimizations here that make this implementation fast.\n  // The basic idea behind LZW is to build a table of previously seen runs\n  // addressed by a short id (herein called output code).  All data is\n  // referenced by a code, which represents one or more values from the\n  // original input stream.  All input bytes can be referenced as the same\n  // value as an output code.  So if you didn't want any compression, you\n  // could more or less just output the original bytes as codes (there are\n  // some details to this, but it is the idea).  In order to achieve\n  // compression, values greater then the input range (codes can be up to\n  // 12-bit while input only 8-bit) represent a sequence of previously seen\n  // inputs.  The decompressor is able to build the same mapping while\n  // decoding, so there is always a shared common knowledge between the\n  // encoding and decoder, which is also important for \"timing\" aspects like\n  // how to handle variable bit width code encoding.\n  //\n  // One obvious but very important consequence of the table system is there\n  // is always a unique id (at most 12-bits) to map the runs.  'A' might be\n  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship\n  // can be used for an effecient lookup strategy for the code mapping.  We\n  // need to know if a run has been seen before, and be able to map that run\n  // to the output code.  Since we start with known unique ids (input bytes),\n  // and then from those build more unique ids (table entries), we can\n  // continue this chain (almost like a linked list) to always have small\n  // integer values that represent the current byte chains in the encoder.\n  // This means instead of tracking the input bytes (AAAABCD) to know our\n  // current state, we can track the table entry for AAAABC (it is guaranteed\n  // to exist by the nature of the algorithm) and the next character D.\n  // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n  // unique.  This allows us to create a simple lookup key for mapping input\n  // sequences to codes (table indices) without having to store or search\n  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the\n  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our\n  // key.  This leads to a integer value at most 20-bits, which can always\n  // fit in an SMI value and be used as a fast sparse array / object key.\n\n  // Output code for the current contents of the index buffer.\n  var ib_code = index_stream[0] & code_mask;  // Load first input index.\n  var code_table = { };  // Key'd on our 20-bit \"tuple\".\n\n  emit_code(clear_code);  // Spec says first code should be a clear code.\n\n  // First index already loaded, process the rest of the stream.\n  for (var i = 1, il = index_stream.length; i < il; ++i) {\n    var k = index_stream[i] & code_mask;\n    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.\n    var cur_code = code_table[cur_key];  // buffer + k.\n\n    // Check if we have to create a new code table entry.\n    if (cur_code === undefined) {  // We don't have buffer + k.\n      // Emit index buffer (without k).\n      // This is an inline version of emit_code, because this is the core\n      // writing routine of the compressor (and V8 cannot inline emit_code\n      // because it is a closure here in a different context).  Additionally\n      // we can call emit_byte_to_buffer less often, because we can have\n      // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n      // be 12-bits, so can safely have 18-bits there without overflow.\n      // emit_code(ib_code);\n      cur |= ib_code << cur_shift;\n      cur_shift += cur_code_size;\n      while (cur_shift >= 8) {\n        buf[p++] = cur & 0xff;\n        cur >>= 8; cur_shift -= 8;\n        if (p === cur_subblock + 256) {  // Finished a subblock.\n          buf[cur_subblock] = 255;\n          cur_subblock = p++;\n        }\n      }\n\n      if (next_code === 4096) {  // Table full, need a clear.\n        emit_code(clear_code);\n        next_code = eoi_code + 1;\n        cur_code_size = min_code_size + 1;\n        code_table = { };\n      } else {  // Table not full, insert a new entry.\n        // Increase our variable bit code sizes if necessary.  This is a bit\n        // tricky as it is based on \"timing\" between the encoding and\n        // decoder.  From the encoders perspective this should happen after\n        // we've already emitted the index buffer and are about to create the\n        // first table entry that would overflow our current code bit size.\n        if (next_code >= (1 << cur_code_size)) ++cur_code_size;\n        code_table[cur_key] = next_code++;  // Insert into code table.\n      }\n\n      ib_code = k;  // Index buffer to single input k.\n    } else {\n      ib_code = cur_code;  // Index buffer to sequence in code table.\n    }\n  }\n\n  emit_code(ib_code);  // There will still be something in the index buffer.\n  emit_code(eoi_code);  // End Of Information.\n\n  // Flush / finalize the sub-blocks stream to the buffer.\n  emit_bytes_to_buffer(1);\n\n  // Finish the sub-blocks, writing out any unfinished lengths and\n  // terminating with a sub-block of length 0.  If we have already started\n  // but not yet used a sub-block it can just become the terminator.\n  if (cur_subblock + 1 === p) {  // Started but unused.\n    buf[cur_subblock] = 0;\n  } else {  // Started and used, write length and additional terminator block.\n    buf[cur_subblock] = p - cur_subblock - 1;\n    buf[p++] = 0;\n  }\n  return p;\n}",
  "function ArrayToProtocolArray_(array, mirror_serializer) {\n  var json = [];\n  for (var i = 0; i < array.length; i++) {\n    json.push(ValueToProtocolValue_(array[i], mirror_serializer));\n  }\n  return json;\n}",
  "function metaTitleFromFileName (filename) {\n  if (filename.substr(-1) === '/') {\n    filename = filename.substr(0, filename.length - 1);\n  }\n\n  return decodeURIComponent(filename);\n}",
  "function(verb, path, controller, method){\n\n        // Only add the route if we recognise the verb.\n        if (this.__verbs.indexOf(verb) >= 0){\n\n            // Create an actual object.\n            var entry = {\n                verb: verb,\n                path: path,\n                controller: controller,\n                method: method\n            };\n\n            this.routes.push(entry);\n        }\n\n        // Otherwise, they've made a mistake in their config, so throw an error.\n        else {\n            throw new Error('Unrecognised HTTP verb for route: ' + path);\n        }\n\n    }",
  "function status () {\n  return fetch(`${STATUS_API}/check`, {\n    headers: {\n      'user-agent': USER_AGENT,\n      'accept': 'application/json'\n    }\n  })\n    .then(handleErrors) // NOTE I wonder how /check can fail\n    .then(res => res.json())\n    .then((sites) => sites.reduce((acc, val) => {\n      const hostname = Object.keys(val)[0]\n      acc.push({\n        hostname,\n        color: val[hostname],\n        isAvailable: val[hostname] === 'green' || val[hostname] === 'yellow',\n        hasIssues: val[hostname] === 'yellow' || val[hostname] === 'red'\n      })\n      return acc\n    }, []))\n}",
  "function multiplyDuration(startDuration, multiplier) {\n\n  if(!isFinite(multiplier) || multiplier <= 0) {\n    throw new Error('Invalid Multiplier');\n  }\n\n  var newDuration = {},\n      hasTime = false,\n      duration = '';\n\n  if(startDuration.getSeconds()) {\n    newDuration.seconds = Math.round(startDuration.getSeconds()*multiplier);\n  }\n\n  if(startDuration.getMinutes()) {\n    newDuration.minutes = Math.round(startDuration.getMinutes()*multiplier);\n  }\n\n  if(startDuration.getHours()) {\n    newDuration.hours = Math.round(startDuration.getHours()*multiplier);\n  }\n\n  if(startDuration.getDays()) {\n    newDuration.days = Math.round(startDuration.getDays()*multiplier);\n  }\n\n  if(startDuration.getMonths()) {\n    newDuration.months = Math.round(startDuration.getMonths()*multiplier);\n  }\n\n  if(startDuration.getYears()) {\n    newDuration.years = Math.round(startDuration.getYears()*multiplier);\n  }\n\n  if(newDuration.seconds) {\n    hasTime = true;\n    duration = newDuration.seconds+'S'+duration;\n  }\n\n  if(newDuration.minutes) {\n    hasTime = true;\n    duration = newDuration.minutes+'M'+duration;\n  }\n\n  if(newDuration.hours) {\n    hasTime = true;\n    duration = newDuration.hours+'H'+duration;\n  }\n\n  if(hasTime) {\n    duration = 'T'+duration;\n  }\n\n  if(newDuration.days) {\n    duration = newDuration.days+'D'+duration;\n  }\n\n  if(newDuration.months) {\n    duration = newDuration.months+'M'+duration;\n  }\n\n  if(newDuration.years) {\n    duration = newDuration.years+'Y'+duration;\n  }\n\n  if(!duration) {\n    throw new Error('Invalid Duration Multiplier');\n  }\n\n  return new Duration('P'+duration);\n\n}",
  "function hookAPIInit(init, args, ctx) {\n    // API init interception\n    if (isFunction(init)) {\n        if (args.length > 1 || !isObject(args[0])) {\n            // convert as one array type argument to make the developer\n            // can modify the call arguments directly\n            args = [args];\n        }\n        return init.apply(this, [...args, ctx]);\n    }\n}",
  "function diffText(a,b){\n\tvar changes = []\n\tvar text = a\n\twhile(text !== b){\n\t\tvar c = partiallyDiffText(text,b)\n\t\tif(c.type === 'add'){\n\t\t\ttext = text.substr(0,c.index)+c.value+text.substr(c.index)\n\t\t}else{\n\t\t\ttext = text.substr(0,c.index)+text.substr(c.index+c.many)\n\t\t}\n\t\tchanges.push(c)\n\t}\n\t\n\treturn changes\n}",
  "function buf2hex(buffer, options = { prefix: true }) {\n  var hex = Array.prototype.map\n    .call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n\n  return options.prefix === true ? `0x${hex}` : hex;\n}",
  "function recurse (streams) {\n    if(streams.length < 2)\n      return\n    streams[0].pipe(streams[1])\n    recurse(streams.slice(1))\n  }",
  "function debuggerHelper (left, right) {\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tvar shouldBreak = evaluateArgs.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n\t\tif (!shouldBreak) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar options = arguments[arguments.length - 1],\n\t\t\tscope = options && options.scope;\n\t\tvar get = function (path) {\n\t\t\treturn scope.get(path);\n\t\t};\n\t\t// This makes sure `get`, `options` and `scope` are available\n\t\tdebuggerHelper._lastGet = get;\n\n\t\tcanLog.log('Use `get(<path>)` to debug this template');\n\n\t\tvar allowDebugger = __testing.allowDebugger;\n\t\t// forgotten debugger\n\t\t// jshint -W087\n\t\tif (allowDebugger) {\n\t\t\tdebugger;\n\t\t\treturn;\n\t\t}\n\t\t// jshint +W087\n\t}\n\t//!steal-remove-end\n\n\tcanLog.warn('Forgotten {{debugger}} helper');\n}",
  "function removeUnUseDecl(decl, toRemovePropName) {\n    let nodes = decl.parent.nodes;\n    let currIdx = nodes.indexOf(decl);\n\n    for (let i = currIdx - 1; i >= 0; i--) {\n        let item = nodes[i];\n        if (item.type === 'decl' && item.prop === toRemovePropName) {\n            item.remove();\n        }\n    }\n}",
  "function loadModels(app, datasource, src, cb = null) {\n  const ds = app.dataSources[datasource];\n  let promises = [], modelsNames = [];\n\n  let files = fs.readdirSync(src);\n  if (files) {\n    files.forEach(file => {\n      // load model for all model json files\n      if (file.endsWith('.json')) {\n        promises.push( new Promise((resolve, reject) => {\n          fs.readFile(`${src}/${file}`, 'utf8', (fileErr, data) => {\n            if (fileErr) app.error(`Failed reading %s because: %s`, file, fileErr);\n            else {\n              let mJson = JSON.parse(data);\n              let model = loopback.createModel(mJson);\n              app.model(model, {dataSource: datasource});\n              modelsNames.push(mJson.name);\n              resolve();\n            }\n          });\n        }));\n      }\n    });\n  }\n\n  Promise.all(promises).then(() => {\n    // process addl model js\n    if (files) {\n      files.forEach(file => {\n        if (file.endsWith('.js')) {\n          require(`${src}/${file}`)(app);\n        }\n      });\n      /**\n       * NOTE: UNCOMMENT TO UPDATE DB ON PRODUCTION ALTHOUGH THAT SHOULD BE\n       * AVOIDED BECAUSE IT RECREATE TABLE STRUCTURE AND REMOVES INDEXES, while\n       * TRYING TO REBUILD STRUCTURE/INDEX IT CAN LEAVE SOME OUT ON LARGE DB AND\n       * CREATE OPTIMIZATION NIGHTMARE\n       */\n      //if ('build' === process.env.WORK && !_.isEmpty(modelsNames)) {\n      if ('development' === process.env.NODE_ENV && !_.isEmpty(modelsNames)) {\n        ds.autoupdate(modelsNames);\n      }\n    }\n    if (cb) cb();\n  });\n}",
  "function PageViewPort_clone(args) {\n      args = args || {};\n      var scale = 'scale' in args ? args.scale : this.scale;\n      var rotation = 'rotation' in args ? args.rotation : this.rotation;\n      return new PageViewport(this.viewBox.slice(), scale, rotation,\n                              this.offsetX, this.offsetY, args.dontFlip);\n    }",
  "function shouldBreakInsideInline(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar hasBlockElems = _.any(node.children, function(child) {\n\t\t\tif (abbrUtils.isSnippet(child))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\t\t\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
  "function requestPromise(options) {\n  return new Promise((resolve, reject) => {\n    request(options, (error, response) => {\n      if (!error && response.statusCode === 200) {\n        resolve(response);\n      } else if (error) {\n        reject(error);\n      } else {\n        reject(new Error(`Status code is ${response.statusCode}`));\n      }\n    });\n  });\n}",
  "function compile(file, options) {\n    if (!file.compileReady && !file.owner.processed) {\n        return {content: file.content};\n    }\n\n    let {\n        getAllPageConfigFiles,\n        sourceDir,\n        designWidth\n    } = options;\n    let obj = JSON.parse(file.content.toString());\n\n    // normalize router info\n    let routerInfo = normalizeRouteInfo(obj.pages);\n    delete obj.pages;\n    obj.router = routerInfo;\n\n    // normalize debug info\n    normalizeDebugConfig(obj);\n\n    // init designWidth\n    if (designWidth) {\n        obj.config || (obj.config = {});\n        if (!obj.config.designWidth) {\n            obj.config.designWidth = designWidth;\n        }\n    }\n\n    // normalize window config info\n    let displayInfo = obj.display;\n    let displayConfig = normalizeWindowConfig(obj.window);\n    // the display config has higher priority than window config\n    displayConfig && (displayInfo = Object.assign(displayConfig, displayInfo));\n    displayInfo && (obj.display = displayInfo);\n    delete obj.window;\n\n    // normalize display pages info\n    if (displayInfo && displayInfo.pages) {\n        displayInfo.pages = normalizeDisplayPages(displayInfo.pages);\n    }\n\n    // normalize features\n    let features = getUsedAPIFeatures(obj.features, options);\n    features && (obj.features = features);\n\n    // merge the page display config defined in page\n    let pageConfigFiles = getAllPageConfigFiles();\n    let currDisplayPages = (displayInfo && displayInfo.pages) || {};\n    pageConfigFiles.forEach(item => {\n        addDisplayPageConfig(currDisplayPages, sourceDir, item);\n    });\n    if (Object.keys(currDisplayPages).length) {\n        displayInfo || (obj.display = {});\n        obj.display.pages = currDisplayPages;\n    }\n\n    return {\n        content: JSON.stringify(obj, null, 4)\n    };\n}",
  "function initProcessorInfo(name, info, existedProcessors) {\n    let processor = info.processor;\n    if (!processor) {\n        return info;\n    }\n\n    if (typeof processor === 'string') {\n        // if the processor refer to the existed processor, merge the existed\n        // processor info with current processor\n        let old = existedProcessors[processor];\n        if (old) {\n            info.processor = undefined;\n            // remove undefined attributes\n            info = removeUndefinedAttributes(info);\n\n            let deps = info.deps;\n            deps && !Array.isArray(deps) && (deps = [deps]);\n\n            let oldDeps = old.deps;\n            oldDeps && !Array.isArray(oldDeps) && (oldDeps = [oldDeps]);\n\n            info = Object.assign({}, old, info);\n            info.deps = merge(deps || [], oldDeps || []);\n\n            return Object.assign({refer: processor}, old, info);\n        }\n    }\n\n    try {\n        info.processor = resolveProcessor(processor);\n    }\n    catch (ex) {\n        let msg = `processor \\`${name}\\` handler \\`${processor}\\` not `\n            + `found: ${ex.message || ex.toString()}`;\n        throw new Error(msg);\n    }\n    return info;\n}",
  "function () {\n      var self = this;\n\n      self.clear_ui();\n      self.resize();\n      self.draw_scale();\n\n      self.capture_idx.servers.forEach(function (bundle) {\n        var server_name = bundle[0];\n        var conn_ids = bundle[1];\n        var i;\n        self.y += self.server_pad;\n        self.draw_server_label(server_name);\n        self.y += self.server_pad;\n        conn_ids.forEach(function (conn_id) {\n          var conn = self.capture.sessions[server_name][conn_id];\n          htracr.connection(conn).draw(\n            di, [server_name, conn_id, undefined, 0]);\n          i = 0;\n          conn.http_reqs.forEach(function (http_req) {\n            var msg = htracr.http_msg(http_req);\n            msg.kind = \"req\";\n            msg.draw(di, [server_name, conn_id, 'http_reqs', i]);\n            i += 1;\n          });\n          i = 0;\n          conn.http_ress.forEach(function (http_req) {\n            var msg = htracr.http_msg(http_req);\n            msg.kind = \"res\";\n            msg.draw(di, [server_name, conn_id, 'http_ress', i]);\n            i += 1;\n          });\n          i = 0;\n          conn.packets.forEach(function (packet) {\n            var pkt = htracr.packet(packet);\n            pkt.draw(di, [server_name, conn_id, 'packets', i]);\n            i += 1;\n          });\n          self.y += self.conn_pad;\n        });\n        \n        self.draw_referers();\n        self.draw_locations();\n      });\n    }",
  "function css(el, prop) {\n    for (var n in prop)\n      el.style[vendor(el, n)||n] = prop[n]\n\n    return el\n  }",
  "function createDefaultSnippetPreview() {\n\tvar targetElement = document.getElementById( this.config.targets.snippet );\n\n\treturn new SnippetPreview( {\n\t\tanalyzerApp: this,\n\t\ttargetElement: targetElement,\n\t\tcallbacks: {\n\t\t\tsaveSnippetData: this.config.callbacks.saveSnippetData,\n\t\t},\n\t} );\n}",
  "function(start, len) {\n\t\t\tif (_.isUndefined(start) || start === null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (start instanceof Range)\n\t\t\t\treturn start;\n\t\t\t\n\t\t\tif (_.isObject(start) && 'start' in start && 'end' in start) {\n\t\t\t\tlen = start.end - start.start;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn new Range(start, len);\n\t\t}",
  "function SelectQuery(request, context) {\n  this.request = request;\n  this.domain = new Domain({ source: request,\n                             context: context });\n\n  this.filters         = [];\n  this.matchExpression = '';\n  this.noResult        = false;\n\n  this.parse();\n}",
  "function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }",
  "function(opacity, animate) {\n        var me = this;\n\n        if (!me.dom) {\n            return me;\n        }\n\n        if (!animate || !me.anim) {\n            me.setStyle('opacity', opacity);\n        }\n        else {\n            if (typeof animate != 'object') {\n                animate = {\n                    duration: 350,\n                    easing: 'ease-in'\n                };\n            }\n\n            me.animate(Ext.applyIf({\n                to: {\n                    opacity: opacity\n                }\n            }, animate));\n        }\n        return me;\n    }",
  "function toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trange = property \n\t\t\t\t\t? property.range(true) \n\t\t\t\t\t: require('range').create(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trange = require('range').create(editor.getCurrentLineRange());\n\t\t\trequire('utils').narrowToNonSpace(info.content, range);\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '/*', '*/', range);\n\t}",
  "function check_role_authorization(req, res, next) {\n\n    if (!req.hasOwnProperty(\"user\") || !req.user.hasOwnProperty('authorized_roles') ||\n        !(req.user.authorized_roles instanceof Array) || req.user.authorized_roles.length === 0){\n\n        running_debug(\"Unhautorized: Invalid role or path not configured\");\n        var err = new Error(\"Unhautorized: Invalid role or path not configured\");\n        err.status = 401;\n        return next(err);\n\n    }\n\n    running_debug(\"Authorized roles: \" + req.user.authorized_roles);\n    return next();\n\n\n}",
  "function createOptions() {\n    this.element.innerHTML = '';\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = this.options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var option = _step.value;\n\n        var optionEl = document.createElement('option');\n        optionEl.setAttribute('value', option);\n        optionEl.innerText = option;\n        this.element.appendChild(optionEl);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }",
  "function WebView() {\n  this.tab = null;\n  this.handler = null;\n  this.open = this.open.bind(this);\n  this.handleFirstLoadEnd = this.handleFirstLoadEnd.bind(this);\n  this.handleLoadError = this.handleLoadError.bind(this);\n  this.handleExit = this.handleExit.bind(this);\n  this.clearEvents = this.clearEvents.bind(this);\n  this.close = this.close.bind(this);\n}",
  "function() {\r\n\t\t\tvar self = this, storage = self.storage, key = self.key, content;\r\n\r\n\t\t\tif (storage) {\r\n\t\t\t\t// Get current contents and remove the existing draft\r\n\t\t\t\tcontent = storage.getItem(key);\r\n\t\t\t\tstorage.removeItem(key);\r\n\t\t\t\tstorage.removeItem(key + \"_expires\");\r\n\r\n\t\t\t\t// Dispatch remove event if we had any contents\r\n\t\t\t\tif (content) {\r\n\t\t\t\t\tself.onRemoveDraft.dispatch(self, {\r\n\t\t\t\t\t\tcontent : content\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
  "function MakeBreakPoint(source_position, opt_script_break_point) {\n  var break_point = new BreakPoint(source_position, opt_script_break_point);\n  break_points.push(break_point);\n  return break_point;\n}",
  "function any (o, f) {\n                    f = f instanceof Function ? f : undefined;\n\n                    if(f instanceof Function) {\n                        var self = o, keys, property, value;\n                        if(typeof self === 'number' || typeof self === 'function' || typeof self === 'boolean') self = o.toString();\n\n                        // Firefox does some funky stuff here...\n                        if(typeof o === 'function') self = fixFirefoxFunctionString(self);\n\n                        // For Safari...\n                        var isArgs = Object.prototype.toString.call(o) === '[object Arguments]', idx = -1;\n                        keys = getKeys(self);\n                        idx  = keys.indexOf('length');\n\n                        if(isArgs && idx > -1) keys.splice(idx, 1);\n\n                        for(var n = 0; n < keys.length; n++) {\n                            property = keys[n];\n                            value    = (typeof o === 'number' && !isNaN(parseFloat(self[property]))) ? parseFloat(self[property]) : self[property];\n                            var ret = f.call(o, value, property, n, o);\n                            if(ret !== undefined) return ret;\n                        }\n                    }\n                    return undefined;\n                }",
  "function doUpdateDatasetClient(datasetClientId, fields, upsert, cb) {\n  debug('doUpdateDatasetClient datasetClientId = %s :: fields = %j', datasetClientId, fields);\n  var col = mongoClient.collection(DATASETCLIENTS_COLLECTION);\n  delete fields._id;\n  col.findOneAndUpdate({id: datasetClientId}, {'$set': fields}, {upsert: upsert, returnOriginal: false}, function(err, result) {\n    if (err) {\n      debugError('Failed to update datasetClients due to error %s :: datasetClientId = %s :: fields = %j',err,datasetClientId,fields);\n      return cb(err);\n    }\n\n    if (result.value === null) {\n      return cb(new Error('DatasetClient not found for id ' + datasetClientId));\n    }\n\n    //ensure the indexes are create for a given dataset\n    ensureIndexesForDataset(result.value.datasetId);\n    return cb(null, result.value);\n  });\n}",
  "function Discover(userAddress) {\n  return new Promise((resolve, reject) => {\n\n    if (userAddress in cachedInfo) {\n      return resolve(cachedInfo[userAddress]);\n    }\n\n    var webFinger = new WebFinger({\n      tls_only: false,\n      uri_fallback: true,\n      request_timeout: 5000\n    });\n\n    return webFinger.lookup(userAddress, function (err, response) {\n      if (err) {\n        return reject(err);\n      } else if ((typeof response.idx.links.remotestorage !== 'object') ||\n                 (typeof response.idx.links.remotestorage.length !== 'number') ||\n                 (response.idx.links.remotestorage.length <= 0)) {\n        log(\"[Discover] WebFinger record for \" + userAddress + \" does not have remotestorage defined in the links section \", JSON.stringify(response.json));\n        return reject(\"WebFinger record for \" + userAddress + \" does not have remotestorage defined in the links section.\");\n      }\n\n      var rs = response.idx.links.remotestorage[0];\n      var authURL = rs.properties['http://tools.ietf.org/html/rfc6749#section-4.2'] ||\n                    rs.properties['auth-endpoint'];\n      var storageApi = rs.properties['http://remotestorage.io/spec/version'] ||\n                       rs.type;\n\n      // cache fetched data\n      cachedInfo[userAddress] = {\n        href: rs.href,\n        storageApi: storageApi,\n        authURL: authURL,\n        properties: rs.properties\n      };\n\n      if (hasLocalStorage) {\n        localStorage[SETTINGS_KEY] = JSON.stringify({ cache: cachedInfo });\n      }\n\n      return resolve(cachedInfo[userAddress]);\n    });\n  });\n}",
  "function(options) {\n        var form = this.getForm(options);\n        if (form) {\n            return (options.isUpload || (/multipart\\/form-data/i).test(form.getAttribute('enctype')));\n        }\n        return false;\n    }",
  "function storeInfoSubmit( state = false, { type } ) {\n\tswitch ( type ) {\n\t\tcase WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT:\n\t\tcase WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS:\n\t\tcase WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE:\n\t\t\treturn WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT === type;\n\t}\n\n\treturn state;\n}",
  "function addLocalGulpTasks(subfile, submodule, tasks) {\n\n    var gulpMod = findModule(function(mod) {\n        return (path.basename(path.dirname(mod.id)) === 'gulp');\n    }, submodule);\n\n    var localInst = gulpMod.exports;\n\n    // copy all the tasks over\n    for (var name in localInst.tasks) {\n        if (localInst.tasks.hasOwnProperty(name)) {\n            var task = localInst.tasks[name];\n\n            if (!task.__hubadded) {\n                task.__hubadded = true;\n                addSubtask(subfile, tasks, task.name, task.dep, task.fn);\n            }\n        }\n    }\n}",
  "function smsDeletePhonesFromBlacklist(callback, phones) {\n    if ((phones === undefined) || (!phones.length)) {\n        return callback(returnError(\"Empty phones\"));\n    }\n    var data = {\n        'phones': JSON.stringify(phones),\n    }\n\n    sendRequest('sms/black_list', 'DELETE', data, true, callback);\n}",
  "async function deleteItems(items, session) {\n  // create our iterator which should return a `Promise`\n  const asyncIterable = {\n    [Symbol.asyncIterator]: () => ({\n      // every time we ask for a new item\n      next: function() {\n        // remove the next item from the array\n        const item = items.pop();\n\n        // we are done if there is no item\n        if (!item) {\n          return Promise.resolve({ done: true });\n        }\n\n        // prompt to delete this item.\n        return deleteItem(item, session);\n      }\n    })\n  };\n\n  // lets get our `next` function so we can itterate over it\n  const { next } = asyncIterable[Symbol.asyncIterator]();\n\n  for (\n    let { done, deleted, item } = await next(); // start condition, call next and wait for the `Promise` to resolve, results are destructed.\n    !done; // end condition,\n    { done, deleted, item } = await next() // action on every loop, sets up the next round of checks\n  ) {\n    if (deleted) {\n      console.log(chalk.green(`${item.title} deleted successfuly\\n`));\n    } else {\n      console.log(chalk.gray(`${item.title} skipped\\n`));\n    }\n  }\n\n  // since this is inside an async function code execution is stopped at the loop\n  // this will return an empty resolved `Promise` when the loop is done.\n  return Promise.resolve();\n}",
  "function locateAcpiDevice(dev) {\n  if (!dev.isDevice()) {\n    return null;\n  }\n\n  const addr = dev.address();\n  const slotId = ((addr >>> 16) & 0xffff) >>> 0;\n  const funcId = (addr & 0xffff) >>> 0;\n  let busId = 0;\n\n  if (dev.isRootBridge()) {\n    busId = dev.getRootBridgeBusNumber();\n\n    return {\n      bus: busId,\n      slot: slotId,\n      func: funcId,\n    };\n  }\n\n  const parentDev = dev.parent();\n  if (parentDev === null) {\n    return null;\n  }\n\n  if (!parentDev.isDevice()) {\n    return null;\n  }\n\n  if (parentDev.isRootBridge()) {\n    busId = parentDev.getRootBridgeBusNumber();\n\n    return {\n      bus: busId,\n      slot: slotId,\n      func: funcId,\n    };\n  }\n\n  const parentLocation = locateAcpiDevice(parentDev);\n  if (parentLocation === null) {\n    return null;\n  }\n\n  const pciParent = pciAccessorFactory.get({\n    bus: parentLocation.bus,\n    slot: parentLocation.slot,\n    func: parentLocation.func,\n  });\n\n  const header = pciParent.read(pciParent.fields().HEADER_TYPE);\n\n  // Mask multifunction bit\n  const headerType = (header & 0x7f) >>> 0;\n  if (headerType !== 0x01 && headerType !== 0x02) {\n    return null;\n  }\n\n  const bridgeBus = pciParent.read(pciParent.bridgeFields().SECONDARY_BUS);\n\n  return {\n    bus: bridgeBus,\n    slot: slotId,\n    func: funcId,\n  };\n}",
  "function domGen(tagName) {\n\n  /**\n   * Generates a dom with the given params.\n   * @param {object} [opts] The options to pass as the second arg of $('<tag/>', arg)\n   * @param {object[]} args The objects to append to the element\n   * @return {jQuery}\n   */\n  return (opts, ...args) => {\n    if (!seemLikePlainObject(opts)) {\n      args.unshift(opts)\n      opts = undefined\n    }\n\n    return $('<' + tagName + '/>', opts).append(...[].concat(...args))\n  }\n}",
  "function(datasetClientId, callback) {\n      return metrics.timeAsyncFunc(metrics.KEYS.MONGODB_OPERATION_TIME, doReadDatasetClientWithRecordsUseCache)(datasetClientId, callback);\n    }",
  "function(assemble, next) {\n\n      grunt.verbose.writeln('Validating options');\n\n      if (utils.endsWithDot(assemble.options.ext)) {\n        grunt.warn('Invalid ext \"' + assemble.options.ext + '\". ext cannot end with a period.');\n        done(false);\n      }\n\n      // find an engine to use\n      assemble.options.engine = assemble.options.engine || 'handlebars';\n      grunt.verbose.ok('>> Current engine:'.yellow, assemble.options.engine);\n\n      assemble.engine.load(assemble.options.engine);\n\n      var initializeEngine = function(engine, options) { engine.init(options, { grunt: grunt, assemble: assemble }); };\n      assemble.options.initializeEngine = assemble.options.initializeEngine || initializeEngine;\n\n      var registerFunctions = function(engine) { engine.registerFunctions(); };\n      assemble.options.registerFunctions = assemble.options.registerFunctions || registerFunctions;\n\n      var registerPartial = function(engine, filename, content) { engine.registerPartial(filename, content); };\n      assemble.options.registerPartial = assemble.options.registerPartial || registerPartial;\n\n      assemble.partials = file.expand(assemble.options.partials);\n\n      if (_.isArray(assemble.options.dataFiles) && assemble.options.dataFiles.length > 0) {\n        assemble.dataFiles = file.expand(assemble.options.dataFiles);\n        //assemble.options.data = {};\n      }\n\n      // Expand layout into layoutFiles if a glob pattern is specified\n      if (assemble.options.layouts) {\n        assemble.layoutFiles = file.expand({filter: 'isFile'}, assemble.options.layouts);\n      }\n\n      if (assemble.layoutFiles && assemble.layoutFiles.length !== 0) {\n        grunt.verbose.writeln('Found layout files:'.yellow, assemble.layoutFiles);\n      } else {\n        assemble.layoutFiles = null;\n      }\n\n      assemble.options.initializeEngine(assemble.engine, assemble.options);\n      assemble.options.registerFunctions(assemble.engine);\n\n      next(assemble);\n    }",
  "function (start, end, y_adj, attrs) {\n      var start_x = time_x(start) || margin[3];\n      var end_x = time_x(end) || ui.w - margin[1];\n      var y = ui.y + y_adj;\n      var e = paper.path(\n        \"M\" + start_x + \",\" + y + \" \" +\n        \"L\" + end_x + \",\" + y\n      ).attr(attrs || {});\n      return e;\n    }",
  "function (item, checked) {\n        var value = [];\n        this.items.each(function(item){\n            if (item.checked) {\n                value.push(item.value);\n            }\n        });\n        this.selected = value;\n\n        this.fireEvent('checkchange', item, checked);\n    }",
  "function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n  var isBindKey = bitmask & BIND_KEY_FLAG;\n  if (!isBindKey && typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var length = partials ? partials.length : 0;\n  if (!length) {\n    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n    partials = holders = undefined;\n  }\n  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n  arity = arity === undefined ? arity : toInteger(arity);\n  length -= holders ? holders.length : 0;\n\n  if (bitmask & PARTIAL_RIGHT_FLAG) {\n    var partialsRight = partials,\n        holdersRight = holders;\n\n    partials = holders = undefined;\n  }\n  var data = isBindKey ? undefined : getData(func);\n\n  var newData = [\n    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n    argPos, ary, arity\n  ];\n\n  if (data) {\n    mergeData(newData, data);\n  }\n  func = newData[0];\n  bitmask = newData[1];\n  thisArg = newData[2];\n  partials = newData[3];\n  holders = newData[4];\n  arity = newData[9] = newData[9] == null\n    ? (isBindKey ? 0 : func.length)\n    : nativeMax(newData[9] - length, 0);\n\n  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {\n    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);\n  }\n  if (!bitmask || bitmask == BIND_FLAG) {\n    var result = createBind(func, bitmask, thisArg);\n  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {\n    result = createCurry(func, bitmask, arity);\n  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {\n    result = createPartial(func, bitmask, thisArg, partials);\n  } else {\n    result = createHybrid.apply(undefined, newData);\n  }\n  var setter = data ? baseSetData : setData;\n  return setWrapToString(setter(result, newData), func, bitmask);\n}",
  "function arrayIncludes(array, value) {\n\t  var length = array ? array.length : 0;\n\t  return !!length && baseIndexOf(array, value, 0) > -1;\n\t}",
  "function parsePaths(source, stylesheets, options) {\n    return stylesheets.map((sheet) => {\n        let sourceProtocol;\n        const isLocalFile = sheet.substr(0, 5) === 'file:';\n\n        if (sheet.substr(0, 4) === 'http') {\n            /* No need to parse, it's already a valid path */\n            return sheet;\n        }\n\n        /* Check if we are fetching over http(s) */\n        if (isURL(source) && !isLocalFile) {\n            sourceProtocol = url.parse(source).protocol;\n\n            if (sheet.substr(0, 2) === '//') {\n                /* Use the same protocol we used for fetching this page.\n                 * Default to http.\n                 */\n                return sourceProtocol ? sourceProtocol + sheet : 'http:' + sheet;\n            }\n            return url.resolve(source, sheet);\n        }\n\n        /* We are fetching local files\n         * Should probably report an error if we find an absolute path and\n         *   have no htmlroot specified.\n         */\n        /* Fix the case when there is a query string or hash */\n        sheet = sheet.split('?')[0].split('#')[0];\n\n        /* Path already parsed by jsdom or user supplied local file */\n        if (isLocalFile) {\n            sheet = url.parse(sheet).path.replace('%20', ' ');\n            /* If on windows, remove first '/' */\n            sheet = isWindows() ? sheet.substring(1) : sheet;\n\n            if (options.htmlroot) {\n                return path.join(options.htmlroot, sheet);\n            }\n            sheet = path.relative(path.join(path.dirname(source)), sheet);\n        }\n\n        if (sheet[0] === '/' && options.htmlroot) {\n            return path.join(options.htmlroot, sheet);\n        } else if (isHTML(source)) {\n            return path.join(options.csspath, sheet);\n        }\n        return path.join(path.dirname(source), options.csspath, sheet);\n    });\n}",
  "function modalOpen (options) {\n    if (isString(options)) options = optionsFromTarget(options);\n    var modal = select('#d3-view-modal');\n    if (!modal.size())\n        select('body').append('modal').mount(options, vm => vm.model.$showModal());\n    else\n        modal.model().$update(options).$showModal();\n}",
  "function pad(data, length, pad) {\n    data = String(data);\n    pad = pad || ' ';\n    while (data.length < length) data += pad;\n    return data;\n}",
  "function buildDocs(api) {\n  const view = buildTemplateView(api);\n\n  // build up readmes one at a time\n  const queue = d3.queue(1);\n\n  Object.keys(api).forEach((filepath) => {\n    queue.defer(buildReadMe, filepath, view);\n  });\n\n  queue.await((err) => {\n    if (err) {\n      console.log(err);\n    }\n\n    console.log('Finished building docs');\n  });\n}",
  "function gen(k8sPods, clusterState, clusterNameLabel) {\n    // Make sure we clean up the old\n    const hostIPs = _.uniq(_.map(k8sPods.items, 'status.hostIP'));\n    const oldHostIps = _.difference(_.keys(clusterState), hostIPs);\n    _.forEach(oldHostIps, (ip) => {\n        delete clusterState[ip];\n    });\n\n    // Loop over the nodes in clusterState and set active = [] so we can append\n    // later\n    Object.keys(clusterState).forEach((nodeId) => {\n        clusterState[nodeId].active = [];\n    });\n\n    // add a worker for each pod\n    k8sPods.items.forEach((pod) => {\n        // Teraslice workers and execution controllers have the `clusterName`\n        // label that matches their cluster name attached to their k8s pods.\n        // If these labels don't match the supplied `clusterNameLabel`\n        // then it is assumed that the pod is not a member of this cluster\n        // so it is omitted from clusterState.\n        // NOTE: The cluster master will not appear in cluster state if they do\n        // not label it with clusterName=clusterNameLabel\n        if (pod.metadata.labels.clusterName === clusterNameLabel) {\n            if (!_.has(clusterState, pod.status.hostIP)) {\n                // If the node isn't in clusterState, add it\n                clusterState[pod.status.hostIP] = {\n                    node_id: pod.status.hostIP,\n                    hostname: pod.status.hostIP,\n                    pid: 'N/A',\n                    node_version: 'N/A',\n                    teraslice_version: 'N/A',\n                    total: 'N/A',\n                    state: 'connected',\n                    available: 'N/A',\n                    active: []\n                };\n            }\n\n            const worker = {\n                assets: [],\n                assignment: pod.metadata.labels.nodeType,\n                ex_id: pod.metadata.labels.exId,\n                // WARNING: This makes the assumption that the first container\n                // in the pod is the teraslice container.  Currently it is the\n                // only container, so this assumption is safe for now.\n                image: pod.spec.containers[0].image,\n                job_id: pod.metadata.labels.jobId,\n                pod_name: pod.metadata.name,\n                pod_ip: pod.status.podIP,\n                worker_id: pod.metadata.name,\n            };\n\n            // k8s pods can have status.phase = `Pending`, `Running`, `Succeeded`,\n            // `Failed`, `Unknown`.  We will only add `Running` pods to the\n            // Teraslice cluster state.\n            if (pod.status.phase === 'Running') {\n                clusterState[pod.status.hostIP].active.push(worker);\n            }\n        }\n    });\n}",
  "function get(czConfig) {\n    const scopes = [];\n\n    if (typeof czConfig.scopes === 'undefined') {\n        return defaults;\n    }\n\n    for (const scope of czConfig.scopes) {\n        scopes.push(scope.name);\n    }\n\n    if (typeof czConfig.scopeOverrides === 'undefined') {\n        return scopes;\n    }\n\n    for (const type of Object.keys(czConfig.scopeOverrides)) {\n        for (const scope of czConfig.scopeOverrides[type]) {\n            scopes.push(scope.name);\n        }\n    }\n\n    return scopes.filter(function (value, index, scope) {\n        return scope.indexOf(value) === index;\n    });\n}",
  "function tokenize() {\n\n        var ch = walker.ch;\n    \n        if (ch === \" \" || ch === \"\\t\") {\n            return white();\n        }\n\n        if (ch === '/') {\n            return comment();\n        } \n\n        if (ch === '\"' || ch === \"'\") {\n            return str();\n        }\n        \n        if (ch === '(') {\n            return brace();\n        }\n    \n        if (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\n            return num();\n        }\n    \n        if (isNameChar(ch)) {\n            return identifier();\n        }\n\n        if (isOp(ch)) {\n            return op();\n        }\n        \n        if (ch === \"\\n\") {\n            tokener(\"line\");\n            walker.nextChar();\n            return;\n        }\n        \n        throw error(\"Unrecognized character\");\n    }",
  "function compile(content, options) {\n  options = merge({\n    outputLanguage: 'es5',\n    modules: 'commonjs',\n    filename: '<unknown file>',\n    sourceMap: false,\n    cwd: process.cwd(),\n    moduleName: false\n  }, options || {});\n\n  var moduleName = options.moduleName;\n\n  traceurOptions.reset();\n  merge(traceurOptions, options);\n\n  var errorReporter = new ErrorReporter();\n  var sourceFile = new SourceFile(options.filename, content);\n  var parser = new Parser(sourceFile, errorReporter);\n  var tree = parser.parseModule();\n  var transformer;\n  if (moduleName === true || options.modules == 'register' || options.modules == 'inline') {\n    moduleName = options.filename.replace(/\\.js$/, '');\n    moduleName = path.relative(options.cwd, moduleName).replace(/\\\\/g,'/');\n  }\n  if (moduleName) {\n    transformer = new AttachModuleNameTransformer(moduleName);\n    tree = transformer.transformAny(tree);\n  }\n\n  if (options.outputLanguage.toLowerCase() === 'es6') {\n    transformer = new PureES6Transformer(errorReporter);\n  } else {\n    transformer = new FromOptionsTransformer(errorReporter);\n  }\n\n  var transformedTree = transformer.transform(tree);\n\n  if (errorReporter.hadError()) {\n    return {\n      js: null,\n      errors: errorReporter.errors,\n      sourceMap: null\n    };\n  }\n\n  var treeWriterOptions = {};\n\n  if (options.sourceMap) {\n    treeWriterOptions.sourceMapGenerator = new SourceMapGenerator({\n      file: options.filename,\n      sourceRoot: null\n    });\n  }\n\n  return {\n    js: TreeWriter.write(transformedTree, treeWriterOptions),\n    errors: errorReporter.errors,\n    sourceMap: treeWriterOptions.sourceMap || null\n  };\n}",
  "function (N, data, CART_OR_SPH, DIRECT_OR_PINV) {\n    \n    var Ndirs = data.length, Nsh = (N+1)*(N+1);\n    var invY_N;\n    var mag = [,];\n    if (Nsh>Ndirs)  {\n        console.log(\"The SHT degree is too high for the number of data points\")\n    }\n    \n    // Convert cartesian to spherical if needed\n    if (CART_OR_SPH==0) data = convertCart2Sph(data);\n    for (var  i=0; i<data.length; i++) {\n        mag[i] = data[i][2];\n    }\n    // SH sampling matrix\n    Y_N = computeRealSH(N, data);\n    // Direct SHT\n    if (DIRECT_OR_PINV==0) {\n        invY_N = numeric.mul(1/Ndirs,Y_N);\n    }\n    else {\n        invY_N = pinv_direct(numeric.transpose(Y_N));\n    }\n    // Perform SHT\n    var coeffs = numeric.dotMV(invY_N, mag);\n    return coeffs;\n}",
  "function generateData(props) {\n  const xValues = generateDataArray(props, \"x\");\n  const yValues = generateDataArray(props, \"y\");\n  const values = xValues.map((x, i) => {\n    return { x, y: yValues[i] };\n  });\n  return values;\n}",
  "function openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}",
  "function(cls) {\n        var me = this,\n            isEmpty = !cls || !cls.length,\n            iconCmp = me.iconCmp;\n\n        me.iconCls = cls;\n        if (!me.iconCmp && !isEmpty) {\n            me.initIconCmp();\n            me.insert(0, me.iconCmp);\n        } else if (iconCmp) {\n            if (isEmpty) {\n                me.iconCmp.destroy();\n                delete me.iconCmp;\n            } else {\n                iconCmp.removeCls(iconCmp.iconCls);\n                iconCmp.addCls(cls);\n                iconCmp.iconCls = cls;\n            }\n        }\n    }",
  "function grabContent(e) {\r\n\t\t\t\tvar n, or, rng, oldRng, sel = ed.selection, dom = ed.dom, body = ed.getBody(), posY, textContent;\r\n\r\n\t\t\t\t// Check if browser supports direct plaintext access\r\n\t\t\t\tif (e.clipboardData || dom.doc.dataTransfer) {\r\n\t\t\t\t\ttextContent = (e.clipboardData || dom.doc.dataTransfer).getData('Text');\r\n\r\n\t\t\t\t\tif (ed.pasteAsPlainText) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\tprocess({content : dom.encode(textContent).replace(/\\r?\\n/g, '<br />')});\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (dom.get('_mcePaste'))\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// Create container to paste into\r\n\t\t\t\tn = dom.add(body, 'div', {id : '_mcePaste', 'class' : 'mcePaste', 'data-mce-bogus' : '1'}, '\\uFEFF\\uFEFF');\r\n\r\n\t\t\t\t// If contentEditable mode we need to find out the position of the closest element\r\n\t\t\t\tif (body != ed.getDoc().body)\r\n\t\t\t\t\tposY = dom.getPos(ed.selection.getStart(), body).y;\r\n\t\t\t\telse\r\n\t\t\t\t\tposY = body.scrollTop + dom.getViewPort(ed.getWin()).y;\r\n\r\n\t\t\t\t// Styles needs to be applied after the element is added to the document since WebKit will otherwise remove all styles\r\n\t\t\t\t// If also needs to be in view on IE or the paste would fail\r\n\t\t\t\tdom.setStyles(n, {\r\n\t\t\t\t\tposition : 'absolute',\r\n\t\t\t\t\tleft : tinymce.isGecko ? -40 : 0, // Need to move it out of site on Gecko since it will othewise display a ghost resize rect for the div\r\n\t\t\t\t\ttop : posY - 25,\r\n\t\t\t\t\twidth : 1,\r\n\t\t\t\t\theight : 1,\r\n\t\t\t\t\toverflow : 'hidden'\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (tinymce.isIE) {\r\n\t\t\t\t\t// Store away the old range\r\n\t\t\t\t\toldRng = sel.getRng();\r\n\r\n\t\t\t\t\t// Select the container\r\n\t\t\t\t\trng = dom.doc.body.createTextRange();\r\n\t\t\t\t\trng.moveToElementText(n);\r\n\t\t\t\t\trng.execCommand('Paste');\r\n\r\n\t\t\t\t\t// Remove container\r\n\t\t\t\t\tdom.remove(n);\r\n\r\n\t\t\t\t\t// Check if the contents was changed, if it wasn't then clipboard extraction failed probably due\r\n\t\t\t\t\t// to IE security settings so we pass the junk though better than nothing right\r\n\t\t\t\t\tif (n.innerHTML === '\\uFEFF\\uFEFF') {\r\n\t\t\t\t\t\ted.execCommand('mcePasteWord');\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Restore the old range and clear the contents before pasting\r\n\t\t\t\t\tsel.setRng(oldRng);\r\n\t\t\t\t\tsel.setContent('');\r\n\r\n\t\t\t\t\t// For some odd reason we need to detach the the mceInsertContent call from the paste event\r\n\t\t\t\t\t// It's like IE has a reference to the parent element that you paste in and the selection gets messed up\r\n\t\t\t\t\t// when it tries to restore the selection\r\n\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t// Process contents\r\n\t\t\t\t\t\tprocess({content : n.innerHTML});\r\n\t\t\t\t\t}, 0);\r\n\r\n\t\t\t\t\t// Block the real paste event\r\n\t\t\t\t\treturn tinymce.dom.Event.cancel(e);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfunction block(e) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Block mousedown and click to prevent selection change\r\n\t\t\t\t\tdom.bind(ed.getDoc(), 'mousedown', block);\r\n\t\t\t\t\tdom.bind(ed.getDoc(), 'keydown', block);\r\n\r\n\t\t\t\t\tor = ed.selection.getRng();\r\n\r\n\t\t\t\t\t// Move select contents inside DIV\r\n\t\t\t\t\tn = n.firstChild;\r\n\t\t\t\t\trng = ed.getDoc().createRange();\r\n\t\t\t\t\trng.setStart(n, 0);\r\n\t\t\t\t\trng.setEnd(n, 2);\r\n\t\t\t\t\tsel.setRng(rng);\r\n\r\n\t\t\t\t\t// Wait a while and grab the pasted contents\r\n\t\t\t\t\twindow.setTimeout(function() {\r\n\t\t\t\t\t\tvar h = '', nl;\r\n\r\n\t\t\t\t\t\t// Paste divs duplicated in paste divs seems to happen when you paste plain text so lets first look for that broken behavior in WebKit\r\n\t\t\t\t\t\tif (!dom.select('div.mcePaste > div.mcePaste').length) {\r\n\t\t\t\t\t\t\tnl = dom.select('div.mcePaste');\r\n\r\n\t\t\t\t\t\t\t// WebKit will split the div into multiple ones so this will loop through then all and join them to get the whole HTML string\r\n\t\t\t\t\t\t\teach(nl, function(n) {\r\n\t\t\t\t\t\t\t\tvar child = n.firstChild;\r\n\r\n\t\t\t\t\t\t\t\t// WebKit inserts a DIV container with lots of odd styles\r\n\t\t\t\t\t\t\t\tif (child && child.nodeName == 'DIV' && child.style.marginTop && child.style.backgroundColor) {\r\n\t\t\t\t\t\t\t\t\tdom.remove(child, 1);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Remove apply style spans\r\n\t\t\t\t\t\t\t\teach(dom.select('span.Apple-style-span', n), function(n) {\r\n\t\t\t\t\t\t\t\t\tdom.remove(n, 1);\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// Remove bogus br elements\r\n\t\t\t\t\t\t\t\teach(dom.select('br[data-mce-bogus]', n), function(n) {\r\n\t\t\t\t\t\t\t\t\tdom.remove(n);\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// WebKit will make a copy of the DIV for each line of plain text pasted and insert them into the DIV\r\n\t\t\t\t\t\t\t\tif (n.parentNode.className != 'mcePaste')\r\n\t\t\t\t\t\t\t\t\th += n.innerHTML;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Found WebKit weirdness so force the content into paragraphs this seems to happen when you paste plain text from Nodepad etc\r\n\t\t\t\t\t\t\t// So this logic will replace double enter with paragraphs and single enter with br so it kind of looks the same\r\n\t\t\t\t\t\t\th = '<p>' + dom.encode(textContent).replace(/\\r?\\n\\r?\\n/g, '</p><p>').replace(/\\r?\\n/g, '<br />') + '</p>';\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Remove the nodes\r\n\t\t\t\t\t\teach(dom.select('div.mcePaste'), function(n) {\r\n\t\t\t\t\t\t\tdom.remove(n);\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Restore the old selection\r\n\t\t\t\t\t\tif (or)\r\n\t\t\t\t\t\t\tsel.setRng(or);\r\n\r\n\t\t\t\t\t\tprocess({content : h});\r\n\r\n\t\t\t\t\t\t// Unblock events ones we got the contents\r\n\t\t\t\t\t\tdom.unbind(ed.getDoc(), 'mousedown', block);\r\n\t\t\t\t\t\tdom.unbind(ed.getDoc(), 'keydown', block);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t}",
  "function _captureUrlChange(from, to) {\n\t    var parsedLoc = parseUrl$1(this._location.href);\n\t    var parsedTo = parseUrl$1(to);\n\t    var parsedFrom = parseUrl$1(from); // because onpopstate only tells you the \"new\" (to) value of location.href, and\n\t    // not the previous (from) value, we need to track the value of the current URL\n\t    // state ourselves\n\n\t    this._lastHref = to; // Use only the path component of the URL if the URL matches the current\n\t    // document (almost all the time when using pushState)\n\n\t    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) to = parsedTo.relative;\n\t    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) from = parsedFrom.relative;\n\t    this.captureBreadcrumb({\n\t      category: 'navigation',\n\t      data: {\n\t        to: to,\n\t        from: from\n\t      }\n\t    });\n\t  }",
  "function messageHandlerSend(actionName, data, transfers) {\n    var message = {\n      action: actionName,\n      data: data\n    };\n    this.postMessage(message, transfers);\n  }",
  "function ps(callback) {\n  var args = ['-A', '-o', 'ppid,pid'];\n\n  bin('ps', args, function(err, stdout, code) {\n    if (err) return callback(err);\n    if (code !== 0) {\n      return callback(new Error('pidtree ps command exited with code ' + code));\n    }\n\n    // Example of stdout\n    //\n    // PPID   PID\n    //    1   430\n    //  430   432\n    //    1   727\n    //    1  7166\n\n    try {\n      stdout = stdout.split(os.EOL);\n\n      var list = [];\n      for (var i = 1; i < stdout.length; i++) {\n        stdout[i] = stdout[i].trim();\n        if (!stdout[i]) continue;\n        stdout[i] = stdout[i].split(/\\s+/);\n        stdout[i][0] = parseInt(stdout[i][0], 10); // PPID\n        stdout[i][1] = parseInt(stdout[i][1], 10); // PID\n        list.push(stdout[i]);\n      }\n\n      callback(null, list);\n    } catch (error) {\n      callback(error);\n    }\n  });\n}",
  "function CouchDBCache(options) {\n    var self = this;\n    options = options || {};\n\n    this.expireAfterSeconds = options.expireAfterSeconds || 60;\n\n    this.connection = Promise.resolve()\n        .then(function () {\n            return options.auth ? this.auth(options.auth.username, options.auth.password) : null;\n        })\n        .then(function (cookie) {\n            return nano({\n                url: options.url || (options.protocol + '://' + options.host + ':' + options.port),\n                cookie: cookie\n            });\n        });\n\n    // create database if it doesn't exist\n    this.db = this.connection.then(function (connection) {\n        var dbName = options.db || 'openamagent';\n        return Promise.promisify(connection.db.create.bind(connection.db))(dbName)\n            .catch(function () {\n                // ignore\n            })\n            .then(function () {\n                return connection.use(dbName);\n            });\n    });\n}",
  "function icons(done) {\n    const stream = gulp.src(config.src)\n      .pipe(iconfont({\n        fontName: config.iconName,\n        appendUniconde: true,\n        formats: config.formats,\n        timestamp: config.useTimestamp ? getTimestamp() : 0,\n        autohint: config.autohint,\n        normalize: config.normalize,\n      }));\n    // write icons to disk\n    stream.pipe(gulp.dest(config.dest));\n\n    // reload browser\n    core.events.emit('reload');\n\n    if (config.templates.enabled && config.templates.sets.length) {\n      stream.on('glyphs', (glyphs) => {\n        // console.log(glyphs);\n        const iconData = {\n          glyphs: glyphs.map(glyph => ({ // returns the object\n            name: glyph.name,\n            content: glyph.unicode[0].toString(16).toUpperCase(),\n          })),\n          fontName: config.iconName,\n          fontPath: config.fontPathPrefix,\n          classNamePrefix: config.classNamePrefix,\n        };\n\n        Promise.all(config.templates.sets.map(set => new Promise((resolve, reject) => {\n          processIconTemplate(set.src, set.dest, iconData, (err) => {\n            if (err) reject();\n            resolve();\n          });\n        }))).then(() => done());\n      });\n    } else {\n      done();\n    }\n  }",
  "function listenToIpc(channel) {\n  return Observable.create((subj) => {\n    let listener = (event, ...args) => {\n      d(`Got an event for ${channel}: ${JSON.stringify(args)}`);\n      subj.next(args);\n    };\n\n    d(`Setting up listener! ${channel}`);\n    ipc.on(channel, listener);\n\n    return new Subscription(() =>\n      ipc.removeListener(channel, listener));\n  });\n}",
  "function captureException(ex, options) {\n\t    options = objectMerge$1({\n\t      trimHeadFrames: 0\n\t    }, options ? options : {});\n\n\t    if (isErrorEvent$1(ex) && ex.error) {\n\t      // If it is an ErrorEvent with `error` property, extract it to get actual Error\n\t      ex = ex.error;\n\t    } else if (isDOMError$1(ex) || isDOMException$1(ex)) {\n\t      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n\t      // then we just extract the name and message, as they don't provide anything else\n\t      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n\t      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n\t      var name = ex.name || (isDOMError$1(ex) ? 'DOMError' : 'DOMException');\n\t      var message = ex.message ? name + ': ' + ex.message : name;\n\t      return this.captureMessage(message, objectMerge$1(options, {\n\t        // neither DOMError or DOMException provide stack trace and we most likely wont get it this way as well\n\t        // but it's barely any overhead so we may at least try\n\t        stacktrace: true,\n\t        trimHeadFrames: options.trimHeadFrames + 1\n\t      }));\n\t    } else if (isError$1(ex)) {\n\t      // we have a real Error object\n\t      ex = ex;\n\t    } else if (isPlainObject$1(ex)) {\n\t      // If it is plain Object, serialize it manually and extract options\n\t      // This will allow us to group events based on top-level keys\n\t      // which is much better than creating new group when any key/value change\n\t      options = this._getCaptureExceptionOptionsFromPlainObject(options, ex);\n\t      ex = new Error(options.message);\n\t    } else {\n\t      // If none of previous checks were valid, then it means that\n\t      // it's not a DOMError/DOMException\n\t      // it's not a plain Object\n\t      // it's not a valid ErrorEvent (one with an error property)\n\t      // it's not an Error\n\t      // So bail out and capture it as a simple message:\n\t      return this.captureMessage(ex, objectMerge$1(options, {\n\t        stacktrace: true,\n\t        // if we fall back to captureMessage, default to attempting a new trace\n\t        trimHeadFrames: options.trimHeadFrames + 1\n\t      }));\n\t    } // Store the raw exception object for potential debugging and introspection\n\n\n\t    this._lastCapturedException = ex; // TraceKit.report will re-raise any exception passed to it,\n\t    // which means you have to wrap it in try/catch. Instead, we\n\t    // can wrap it here and only re-raise if TraceKit.report\n\t    // raises an exception different from the one we asked to\n\t    // report on.\n\n\t    try {\n\t      var stack = tracekit.computeStackTrace(ex);\n\n\t      this._handleStackInfo(stack, options);\n\t    } catch (ex1) {\n\t      if (ex !== ex1) {\n\t        throw ex1;\n\t      }\n\t    }\n\n\t    return this;\n\t  }",
  "function KJU(configuration) {\n  var self = this\n    , option;\n\n  // defaults\n  this.limit = 500;\n  this.ms = 100;\n  this.interval = 15000;\n  this.warnings = true;\n  this.enabled = true;\n  this.recover = true;\n  this.dump = true;\n  this.path = process.cwd() + '/';\n  this.name = 'node_kju_backup.{sequence}.kju';\n\n  // apply the configuration\n  for (option in configuration)\n    this[option] = configuration[option];\n\n  // these values should not be configured\n  this.buffer = [];\n  this.length = 0;\n\n  this.drained = 0;\n  this.processed = 0;\n  this.since = Date.now();\n\n  this.minimum = this.interval / 2;\n  this.maximum = this.interval * 2;\n\n  // initialize the event emitter\n  EventEmitter2.call(this, { wildcard: true });\n\n  if (this.recover) this.recovery();\n  if (this.enabled) this.enable();\n\n  // make sure our backup path exists\n  fsExists(this.path, function existing(exists) {\n    if (!exists) {\n      return self.emit('error', new Error(self.path + ' does not exist.'));\n    }\n\n    if (self.path[self.path.length - 1] !== '/') {\n      return self.emit('error', new Error(self.path + ' should end with a slash'));\n    }\n  });\n}",
  "function createMenuItem(_ref) {\n\t    var _this3 = this;\n\n\t    var value = _ref.value,\n\t        list = _ref.list,\n\t        type = _ref.type,\n\t        title = _ref.title,\n\t        _ref$badge = _ref.badge,\n\t        badge = _ref$badge === void 0 ? null : _ref$badge,\n\t        _ref$checked = _ref.checked,\n\t        checked = _ref$checked === void 0 ? false : _ref$checked;\n\t    var attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);\n\t    var menuItem = createElement('button', extend(attributes, {\n\t      type: 'button',\n\t      role: 'menuitemradio',\n\t      class: \"\".concat(this.config.classNames.control, \" \").concat(attributes.class ? attributes.class : '').trim(),\n\t      'aria-checked': checked,\n\t      value: value\n\t    }));\n\t    var flex = createElement('span'); // We have to set as HTML incase of special characters\n\n\t    flex.innerHTML = title;\n\n\t    if (is$1.element(badge)) {\n\t      flex.appendChild(badge);\n\t    }\n\n\t    menuItem.appendChild(flex); // Replicate radio button behaviour\n\n\t    Object.defineProperty(menuItem, 'checked', {\n\t      enumerable: true,\n\t      get: function get() {\n\t        return menuItem.getAttribute('aria-checked') === 'true';\n\t      },\n\t      set: function set(checked) {\n\t        // Ensure exclusivity\n\t        if (checked) {\n\t          Array.from(menuItem.parentNode.children).filter(function (node) {\n\t            return matches$1(node, '[role=\"menuitemradio\"]');\n\t          }).forEach(function (node) {\n\t            return node.setAttribute('aria-checked', 'false');\n\t          });\n\t        }\n\n\t        menuItem.setAttribute('aria-checked', checked ? 'true' : 'false');\n\t      }\n\t    });\n\t    this.listeners.bind(menuItem, 'click keyup', function (event) {\n\t      if (is$1.keyboardEvent(event) && event.which !== 32) {\n\t        return;\n\t      }\n\n\t      event.preventDefault();\n\t      event.stopPropagation();\n\t      menuItem.checked = true;\n\n\t      switch (type) {\n\t        case 'language':\n\t          _this3.currentTrack = Number(value);\n\t          break;\n\n\t        case 'quality':\n\t          _this3.quality = value;\n\t          break;\n\n\t        case 'speed':\n\t          _this3.speed = parseFloat(value);\n\t          break;\n\n\t        default:\n\t          break;\n\t      }\n\n\t      controls.showMenuPanel.call(_this3, 'home', is$1.keyboardEvent(event));\n\t    }, type, false);\n\t    controls.bindMenuItemShortcuts.call(this, menuItem, type);\n\t    list.appendChild(menuItem);\n\t  }",
  "function(date, format) {\n        var formatFunctions = utilDate.formatFunctions;\n\n        if (!Ext.isDate(date)) {\n            return '';\n        }\n\n        if (formatFunctions[format] == null) {\n            utilDate.createFormat(format);\n        }\n\n        return formatFunctions[format].call(date) + '';\n    }",
  "function createListBoxMixin({ id, field }) {\n        return this.createObject({\n            qInfo: {\n                qType: 'ListObject'\n            },\n            qListObjectDef: {\n                qStateName: '$',\n                qLibraryId: undef.if(id, ''),\n                qDef: {\n                    qFieldDefs: undef.if(field, [field], [])\n                },\n                qInitialDataFetch: [{\n                    qTop: 0,\n                    qLeft: 0,\n                    qHeight: 5,\n                    qWidth: 1\n                }]\n            }\n        }).then((object) => {\n            return object.getLayout();\n        })\n    }",
  "function () {\n                    var js, index = parserInput.i;\n\n                    parserInput.save();\n\n                    var escape = parserInput.$char('~');\n                    var jsQuote = parserInput.$char('`');\n\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore('invalid javascript definition');\n                }",
  "function deepAssign() {\n  for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (args.length < 2) {\n    throw new Error('deepAssign accept two and more argument');\n  }\n  for (var i = args.length - 1; i > -1; i--) {\n    if (isPrimitive(args[i])) {\n      throw new TypeError('deepAssign only accept non primitive type');\n    }\n  }\n  var target = args.shift();\n  args.forEach(function (source) {\n    return _deepAssign(source, target);\n  });\n  return target;\n}",
  "function inlineImports(imports, data, declaration) {\n\n\tlet modified = imports.length > 0;\n\tlet i, item;\n\n\t// Inline the imports in reverse order to keep the indices intact.\n\tfor(i = imports.length - 1; i >= 0; --i) {\n\n\t\titem = imports[i];\n\n\t\tdata = data.substring(0, item.start) +\n\t\t\tdeclaration + \" \" + item.name + \" = \" + JSON.stringify(item.data) +\n\t\t\tdata.substring(item.end);\n\n\t}\n\n\treturn Promise.resolve([modified, data]);\n\n}",
  "function _handleKey(character, modifiers, e) {\n        var self = this;\n\n        if (!self.recording) {\n            _origHandleKey.apply(self, arguments);\n            return;\n        }\n\n        // remember this character if we're currently recording a sequence\n        if (e.type == 'keydown') {\n            if (character.length === 1 && _recordedCharacterKey) {\n                _recordCurrentCombo();\n            }\n\n            for (i = 0; i < modifiers.length; ++i) {\n                _recordKey(modifiers[i]);\n            }\n            _recordKey(character);\n\n        // once a key is released, all keys that were held down at the time\n        // count as a keypress\n        } else if (e.type == 'keyup' && _currentRecordedKeys.length > 0) {\n            _recordCurrentCombo();\n        }\n    }",
  "function(filename) {\n      return new Promise((resolve, reject) => {\n        fs.stat(filename, function(err, stats) {\n          if (err && err.code != \"ENOENT\") {\n            reject(err); \n          } else {\n            resolve(err ? null : stats);\n          }\n        });\n      });\n    }",
  "function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        return true;\n    }",
  "function initBabelProcessorOptions(file, processorOpts, buildManager) {\n    processorOpts = Object.assign(\n        {}, buildManager.babelConfig, processorOpts\n    );\n\n    // init plugins\n    let plugins = normalizeBabelPlugins(processorOpts.plugins, file, buildManager);\n\n    // init app/page/component transform plugin\n    let configInitHandler = initConfigInfo.bind(\n        null, buildManager, 'config', file\n    );\n    let appBaseClass = buildManager.getOutputAppBaseClass();\n    let pluginOpts = {\n        appType: buildManager.appType,\n        config: configInitHandler\n    };\n    let filterOptions = buildManager.getFilterTransformOptions();\n    let enableMixinSupport = buildManager.isEnableMixinSupport();\n    let {api, framework, localPolyfill, polyfill} = buildManager.buildConf;\n    let getInitOptions = buildManager.getAppBaseClassInitOptions.bind(\n        buildManager, file\n    );\n    if (file.isEntryScript) {\n        Object.assign(pluginOpts, {\n            framework,\n            registerApi: api,\n            baseClass: appBaseClass && appBaseClass.app\n        });\n        // polyfill using local variable is prior to global polyfill\n        localPolyfill || (pluginOpts.polyfill = polyfill);\n        pluginOpts.getInitOptions = getInitOptions;\n        plugins.push([\n            programPlugins.app,\n            pluginOpts\n        ]);\n    }\n    else if (file.isPageScript) {\n        Object.assign(pluginOpts, {\n            enableMixinSupport,\n            filterOptions,\n            tplRefs: file.tplRefs,\n            baseClass: appBaseClass && appBaseClass.page,\n            getInitOptions\n        });\n        plugins.push([programPlugins.page, pluginOpts]);\n    }\n    else if (file.isComponentScript) {\n        Object.assign(pluginOpts, {\n            enableMixinSupport,\n            filterOptions,\n            tplRefs: file.tplRefs,\n            baseClass: appBaseClass && appBaseClass.component,\n            getInitOptions\n        });\n        plugins.push([programPlugins.component, pluginOpts]);\n    }\n    else if (file.isBehavior) {\n        plugins.push([programPlugins.behavior, pluginOpts]);\n    }\n\n    // init local polyfill plugins\n    if (localPolyfill && !file.compiled) {\n        initLocalPolyfillPlugins(localPolyfill, plugins);\n    }\n\n    processorOpts.plugins = plugins;\n\n    return processorOpts;\n}",
  "function ShapeCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 3) throw new SyntaxError('SHAPE command requires 3 arguments');\n    this.pointsLength = parsed.args[0];\n    this.pointsX = parsed.args[1];\n    this.pointsY = parsed.args[2];\n    this.stroke = parsed.args.length > 3 ? parsed.args[3] : false;\n}",
  "function extend(o, p, deep) {\n        // If `o` or `p` are not set bail\n        if (!o || !p) {\n            return o;\n        }\n\n        // Merge all props from `p` to `o`\n        Object.keys(p).forEach(function (prop) { // For all props in p.\n            // If property is present on target (o) and is not writable, skip iteration\n            var propDescription = Object.getOwnPropertyDescriptor(o, prop);\n            if (propDescription &&\n                !(isset(propDescription.get) && isset(propDescription.set)) &&\n                !propDescription.writable) {\n                return;\n            }\n            if (deep === true) {\n                if (isObject(p[prop]) && isObject(o[prop]) && !isEmptyObj(p[prop])) {\n                    extend(o[prop], p[prop], deep);\n                }\n                else {\n                    o[prop] = p[prop];\n                }\n            }\n            else {\n                o[prop] = p[prop];\n            }\n        });\n\n        return o;\n    }",
  "function logAndFinish(tessel) {\n      // The Tessels in `tessels` that we won't be using MUST\n      // have their connections closed\n      /* istanbul ignore else */\n      if (tessel) {\n        log.info(`Connected to ${tessel.displayName}.`);\n        controller.closeTesselConnections(tessels.filter(closable => closable !== tessel))\n          .then(() => resolve(tessel));\n      } else {\n        log.info('Please specify a Tessel by name [--name <tessel name>]');\n        controller.closeTesselConnections(tessels)\n          .then(() => reject('Multiple possible Tessel connections found.'));\n      }\n    }",
  "function readFilePromise(filename) {\n  var deferred;\n\n  deferred = Q.defer();\n\n  fs.readFile(filename, 'utf-8', function (err, contents) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        debug(err.code + ': ' + filename);\n        return deferred.resolve();\n      }\n      debug(err + ' ' + filename);\n      // TODO: better error handling\n      deferred.reject(err);\n    } else {\n      debug('read ' + filename);\n      deferred.resolve(contents);\n    }\n  });\n\n  return deferred.promise;\n}",
  "function allow(action, req, res, cb) {\n\t\t// call the allow method in our options if it exists\n\t\t// or we will just assume it is always allowed\n\t\tif (options.allow) {\n\t\t\treturn options.allow.apply(this, arguments);\n\t\t}\n\n\t\treturn cb && cb(null, true);\n\t}",
  "function javascript(node) {\n  if (!is(node, 'script')) {\n    return false\n  }\n\n  if (has(node, 'type')) {\n    return check(node.properties.type)\n  }\n\n  return !has(node, 'language') || check(node.properties.language, 'text/')\n}",
  "function _resolveConfigSize(renderNode) {\n        if (renderNode instanceof RenderNode) {\n            var result = null;\n            var target = renderNode.get();\n            if (target) {\n                result = _resolveConfigSize(target);\n                if (result) {\n                    return result;\n                }\n            }\n            if (renderNode._child) {\n                return _resolveConfigSize(renderNode._child);\n            }\n        }\n        else if (renderNode instanceof Surface) {\n            return renderNode.size ? {\n                renderNode: renderNode,\n                size: renderNode.size\n            } : undefined;\n        }\n        else if (renderNode.options && renderNode.options.size) {\n            return {\n                renderNode: renderNode,\n                size: renderNode.options.size\n            };\n        }\n        return undefined;\n    }",
  "function CloseCommand(args, define) {\n    var parsed = new statements.ExpressionStatement(args, define);\n    if (!(parsed.child instanceof statements.PointerStatement)) throw new SyntaxError('Expected pointer');\n\n    this.pointer = parsed;\n}",
  "function(item) {\n        if (!item) {\n            return;\n        }\n        \n        var me = this,\n            sprite = item.sprite,\n            opts = Ext.merge({}, me.highlightCfg, me.highlight),\n            surface = me.chart.surface,\n            animate = me.chart.animate,\n            p, from, to, pi;\n\n        if (!me.highlight || !sprite || sprite._highlighted) {\n            return;\n        }\n        if (sprite._anim) {\n            sprite._anim.paused = true;\n        }\n        sprite._highlighted = true;\n        if (!sprite._defaults) {\n            sprite._defaults = Ext.apply({}, sprite.attr);\n            from = {};\n            to = {};\n            // TODO: Clean up code below.\n            for (p in opts) {\n                if (! (p in sprite._defaults)) {\n                    sprite._defaults[p] = surface.availableAttrs[p];\n                }\n                from[p] = sprite._defaults[p];\n                to[p] = opts[p];\n                if (Ext.isObject(opts[p])) {\n                    from[p] = {};\n                    to[p] = {};\n                    Ext.apply(sprite._defaults[p], sprite.attr[p]);\n                    Ext.apply(from[p], sprite._defaults[p]);\n                    for (pi in sprite._defaults[p]) {\n                        if (! (pi in opts[p])) {\n                            to[p][pi] = from[p][pi];\n                        } else {\n                            to[p][pi] = opts[p][pi];\n                        }\n                    }\n                    for (pi in opts[p]) {\n                        if (! (pi in to[p])) {\n                            to[p][pi] = opts[p][pi];\n                        }\n                    }\n                }\n            }\n            sprite._from = from;\n            sprite._to = to;\n            sprite._endStyle = to;\n        }\n        if (animate) {\n            sprite._anim = new Ext.fx.Anim({\n                target: sprite,\n                from: sprite._from,\n                to: sprite._to,\n                duration: 150\n            });\n        } else {\n            sprite.setAttributes(sprite._to, true);\n        }\n    }",
  "function () {\n                if (parserInput.commentStore.length) {\n                    var comment = parserInput.commentStore.shift();\n                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            }",
  "function splitOnWords( sentence, stopwords ) {\n\tconst splitSentences = [];\n\n\t// Split the sentence on each found stopword and push this part in an array.\n\tforEach( stopwords, function( stopword ) {\n\t\tconst sentenceSplit = sentence.split( stopword );\n\t\tif ( ! isEmpty( sentenceSplit[ 0 ] ) ) {\n\t\t\tsplitSentences.push( sentenceSplit[ 0 ] );\n\t\t}\n\t\tconst startIndex = sentence.indexOf( stopword );\n\t\tconst endIndex = sentence.length;\n\t\tsentence = stripSpaces( sentence.substr( startIndex, endIndex ) );\n\t} );\n\n\t// Push the remainder of the sentence in the sentence parts array.\n\tsplitSentences.push( sentence );\n\treturn splitSentences;\n}",
  "function (view, offset, length) {\n            var trmOffset = lib.locateStrTrm.iso(view, offset, length);\n            if (trmOffset !== -1) { length = trmOffset - offset; }\n            return lib.readStr.iso(view, offset, length);\n        }",
  "function renderBlockOnIE(block) {\r\n\t\t\t\tvar oldRng;\r\n\r\n\t\t\t\tif (tinymce.isIE && dom.isBlock(block)) {\r\n\t\t\t\t\toldRng = selection.getRng();\r\n\t\t\t\t\tblock.appendChild(dom.create('span', null, '\\u00a0'));\r\n\t\t\t\t\tselection.select(block);\r\n\t\t\t\t\tblock.lastChild.outerHTML = '';\r\n\t\t\t\t\tselection.setRng(oldRng);\r\n\t\t\t\t}\r\n\t\t\t}",
  "function(cb) {\n            // Callback is optional\n            cb = util.optional(cb);\n\n            // Grab policies config & policy modules and trigger callback\n            this.loadMiddleware(function (err) {\n                if (err) return cb(err);\n\n                sails.log.verbose('Finished loading policy middleware logic.');\n                cb();\n            }.bind(this));\n\n            // Before routing, curry controller functions with appropriate policy chains\n            sails.on('router:before', this.bindPolicies);\n        }",
  "function(dataview) {\n        /**\n         * @property dataview\n         * @type Ext.view.View\n         * The DataView bound to this instance\n         */\n        this.dataview = dataview;\n        dataview.mon(dataview, {\n            beforecontainerclick: this.cancelClick,\n            scope: this,\n            render: {\n                fn: this.onRender,\n                scope: this,\n                single: true\n            }\n        });\n    }",
  "function(array) {\n            var sum = 0,\n                i, ln, item;\n\n            for (i = 0,ln = array.length; i < ln; i++) {\n                item = array[i];\n\n                sum += item;\n            }\n\n            return sum;\n        }",
  "function formatTable(table, links, notes) {\n  var widths = [];\n  var rows = table.map(function (row) {\n    var cells = row.map(function (cell) {\n      return formatSpans(cell, links, notes);\n    });\n    cells.forEach(function (cell, index) {\n      widths[index] = Math.max(cell.length, widths[index] || 5);\n      widths[index] = Math.min(widths[index], 50);\n    });\n    return cells.join(' & ');\n  });\n\n  var totalWidth = widths.reduce(function sum(val, width) { return val + width; }, 0);\n  totalWidth = Math.max(totalWidth, 100);\n  widths = widths.map(function (width) {\n    var relativeWidth = width / totalWidth;\n    return 'p{' + relativeWidth + '\\\\textwidth}';\n  }).join(' | ');\n\n  var str =\n    '\\\\begin{longtable}{ | ' + widths + ' |}\\n' +\n    '\\\\hline\\n' +\n    rows.join(' \\\\\\\\\\n\\\\hline\\n') +\n    ' \\\\\\\\\\n' +\n    '\\\\hline\\n' +\n    '\\\\end{longtable}';\n  return str;\n}",
  "function(binding, event){\n        if (this.checkModifiers(binding, event)) {\n            var key = event.getKey(),\n                handler = binding.fn || binding.handler,\n                scope = binding.scope || this,\n                keyCode = binding.keyCode,\n                defaultEventAction = binding.defaultEventAction,\n                i,\n                len,\n                keydownEvent = new Ext.EventObjectImpl(event);\n\n\n            for (i = 0, len = keyCode.length; i < len; ++i) {\n                if (key === keyCode[i]) {\n                    if (handler.call(scope, key, event) !== true && defaultEventAction) {\n                        keydownEvent[defaultEventAction]();\n                    }\n                    break;\n                }\n            }\n        }\n    }",
  "function() {\n        var me = this,\n            obj = me.getStorageObject(),\n            ids = me.getIds(),\n            len = ids.length,\n            i;\n\n        //remove all the records\n        for (i = 0; i < len; i++) {\n            obj.removeItem(me.getRecordKey(ids[i]));\n        }\n\n        //remove the supporting objects\n        obj.removeItem(me.getRecordCounterKey());\n        obj.removeItem(me.getTreeKey());\n        obj.removeItem(me.id);\n\n        // clear the cache\n        me.cache = {};\n    }",
  "function initialize(name, accessor) {\n        var consumerSecret;\n        if (accessor.accessorSecret != null\n            && name.length > 9\n            && name.substring(name.length-9) == \"-Accessor\")\n        {\n            consumerSecret = accessor.accessorSecret;\n        } else {\n            consumerSecret = accessor.consumerSecret;\n        }\n        this.key = OAuth.percentEncode(consumerSecret)\n             +\"&\"+ OAuth.percentEncode(accessor.tokenSecret);\n    }",
  "function existsCaseSensitive(filePath) {\n    let dirPath = filePath\n\n    while (dirPath !== \"\" && !ROOT.test(dirPath)) {\n        const fileName = path.basename(dirPath)\n        dirPath = path.dirname(dirPath)\n\n        if (fs.readdirSync(dirPath).indexOf(fileName) === -1) {\n            return false\n        }\n    }\n\n    return true\n}",
  "function stopAll(cb) {\n  //sync is not started yet, but connect could be called already. In this case, just reset a few things\n  if (!syncStarted) {\n    interceptors.restore();\n    dataHandlers.restore();\n    hashProvider.restore();\n    mongoDbClient = null;\n    redisClient = null;\n    metricsClient = null;\n    return cb();\n  }\n  debug('stopAll syncs');\n  datasetClientCleaner.stop();\n  async.parallel([\n    async.apply(syncStorage.updateManyDatasetClients, {}, {stopped: true}),\n    async.apply(stopAllWorkers, syncWorkers),\n    async.apply(stopAllWorkers, ackWorkers),\n    async.apply(stopAllWorkers, pendingWorkers),\n    async.apply(syncScheduler.stop.bind(syncScheduler))\n  ], function(err) {\n    if (err) {\n      debugError('Failed to stop sync due to error : %s', err);\n      return cb(err);\n    }\n    setConfig();\n    interceptors.restore();\n    dataHandlers.restore();\n    hashProvider.restore();\n    mongoDbClient = null;\n    redisClient = null;\n    metricsClient = null;\n    ackQueue = null;\n    pendingQueue = null;\n    syncQueue = null;\n    ackWorkers = [];\n    pendingWorkers = [];\n    syncWorkers = [];\n    syncStarted = false;\n    syncLock = null;\n    datasetClientCleaner = null;\n    // Reset the memoized start fn so it can be called again\n    module.exports.api.start = async.memoize(start);\n    return cb();\n  });\n}",
  "function normalize(value, patterns) {\n  var length = patterns.length\n  var index = -1\n  var pattern\n\n  while (++index < length) {\n    pattern = patterns[index]\n    value = value.replace(pattern[0], pattern[1])\n  }\n\n  return value\n}",
  "function charAt(index) {\r\n    return value => value.length <= index ? undefined : value.charAt(index);\r\n}",
  "function(o){\n            for (var i = 1, a = arguments, len = a.length; i < len; i++) {\n                Ext.destroy(o[a[i]]);\n                delete o[a[i]];\n            }\n        }",
  "function getProcessedPath(file, data) {\n  return file.replace(/__([A-Za-z0-9-]+_?[A-Za-z0-9-]+)+__/g, (match) => {\n    const dataKey = match.substring(2, match.length - 2);\n    const dataVal = data[dataKey];\n\n    if (dataVal) {\n      return dataVal;\n    }\n    return match;\n  });\n}",
  "function checkNodeIndent(node, indent, excludeCommas) {\n\t\tvar nodeIndent = getNodeIndent(node, false, excludeCommas);\n\t\tif (\n\t\t\tnode.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" &&\n\t\t\tnodeIndent !== indent && isNodeFirstInLine(node)\n\t\t) {\n\t\t\treport(node, indent, nodeIndent);\n\t\t}\n\t}",
  "function ltrim (s, what) {\n                    what = typeof what === 'string' ? what : '\\\\s+';\n                    return s.replace(new RegExp('^' + what), '');\n                }",
  "function compileValue(value) {\n\t\tif (value.subtype === 'array') {\n\t\t\treturn compileArray(value)\n\t\t} else if (value.subtype === 'object') {\n\t\t\treturn compileObject(value)\n\t\t} else if (value.subtype === 'mixin') {\n\t\t\treturn compileMixin(value)\n\t\t} else if (value.subtype === 'js') {\n\t\t\treturn compileJS(value)\n\t\t} else if (value.subtype === 'function') {\n\t\t\treturn compileFunction(value)\n\t\t}\n\t\tthrow new Error('Invalid subtype: ' + value.subtype)\n\t}",
  "function normalizeProtocol(protocol) {\n\tif (protocol && protocol.length > 0 && protocol.charAt(protocol.length - 1) !== ':') {\n\t\treturn protocol + ':'\n\t}\n\treturn protocol\n}",
  "function getWithResolvedData(ctx, cur, down) {\n    return function(data) {\n      return ctx.push(data)._get(cur, down);\n    };\n  }",
  "function makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\n\t\t_.each(tokens, function(tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range.create({\n\t\t\t\t\t\t\tstart: tok.start + 1, \n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\t result.push(range.create(attrStart, tok.end - attrStart));\n\t\t\t\t\t \n\t\t\t\t\t attrValueRange = range.create(tok);\n\t\t\t\t\t attrValue = attrValueRange.substring(source);\n\t\t\t\t\t \n\t\t\t\t\t // is this a quoted attribute?\n\t\t\t\t\t if (isQuote(attrValue.charAt(0)))\n\t\t\t\t\t\t attrValueRange.start++;\n\t\t\t\t\t \n\t\t\t\t\t if (isQuote(attrValue.charAt(attrValue.length - 1)))\n\t\t\t\t\t\t attrValueRange.end--;\n\t\t\t\t\t \n\t\t\t\t\t result.push(attrValueRange);\n\t\t\t\t\t \n\t\t\t\t\t if (attrName == 'class') {\n\t\t\t\t\t\t result = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// offset ranges\n\t\t_.each(result, function(r) {\n\t\t\tr.shift(offset);\n\t\t});\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {        // remove empty\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {   // remove duplicates\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}",
  "function setStyle(node, prop, value) {\n            if (node && node.el) {\n                if (isObject(prop)) {\n                    Object.keys(prop).forEach(function (key) {\n                        node.el.style[key] = prop[key];\n                    });\n                } else {\n                    node.el.style[prop] = value;\n                }\n            }\n        }",
  "function isError(value) {\n  if (!isObjectLike(value)) {\n    return false;\n  }\n  return (objectToString.call(value) == errorTag) ||\n    (typeof value.message == 'string' && typeof value.name == 'string');\n}",
  "function proxyRequest(req, res, proxyTo, opts) {\n        opts = opts || {};\n        var httpRequestFunction  = opts.httpRequestFunction  || http.request;\n        var httpsRequestFunction = opts.httpsRequestFunction || https.request;\n        var setHostHeader = opts.setHostHeader;\n\n        var proxyUrl = proxyTo;\n        if (typeof(proxyTo) === 'string') {\n            proxyUrl = url.parse(proxyTo, true);\n        }\n        var proxyToHost = proxyUrl.hostname;\n        var proxyToPort = proxyUrl.port ||\n                (proxyUrl.protocol === 'https:' ? 443 : 80);\n        var proxyToPath = proxyUrl.pathname +\n            (proxyUrl.search === null ? \"\" : proxyUrl.search);\n        var requestFunction = (proxyUrl.protocol === 'https:') ?\n                httpsRequestFunction : httpRequestFunction;\n        var headers = {};\n        for (var h in req.headers) { headers[h] = req.headers[h]; }\n        if (setHostHeader) {\n            headers.host = proxyToHost +\n                (proxyUrl.port ? \":\" + proxyUrl.port : \"\");\n        }\n\n        var proxyReq = requestFunction(\n            {host: proxyToHost,\n             port: proxyToPort,\n             method: req.method,\n             path: proxyToPath,\n             headers: headers},\n            function (proxyRes) {\n                // Copy over headers and status code from proxied request\n                res.statusCode = proxyRes.statusCode;\n                res.headers    = proxyRes.headers;\n\n                proxyRes.on(\"data\", function (chunk) {\n                    res.write(chunk);\n                });\n\n                proxyRes.on(\"end\", function () {\n                    res.end();\n                });\n            });\n\n        proxyReq.on('error', function (err) {\n            res.statusCode = 502;\n            res.send('Bad Gateway! Could not proxy request. Invalid host or proxy destination down? Reported error was: ' + err);\n        });\n\n        if (req.rawBody) {\n            proxyReq.write(req.rawBody);\n        }\n        proxyReq.end();\n    }",
  "function getTimeDifference(timestr1, timestr2) {\n\tif (typeof timestr1 !== 'string' || typeof timestr2 !== 'string') {\n\t\tthrow new Error('pendel.time() expects string arguments');\n\t}\n\n\t// Check if we are getting the short timecode formats\n\t// like 1:32PM or 13:32. If Yes, convert it into a\n\t// generic datestring so that we can support the old API.\n\tvar date1 = shortTimeToDateString(timestr1);\n\tvar date2 = shortTimeToDateString(timestr2);\n\n\tif (!date1) {\n\t\tdate1 = new Date(timestr1).toString();\n\t}\n\n\tif (!date2) {\n\t\tdate2 = new Date(timestr2).toString();\n\t}\n\n\tvar time1 = dateComponents(date1);\n\tvar time2 = dateComponents(date2);\n\n\tvar results = getTotalResultsFromEpochs(time1.epoch, time2.epoch);\n\n\treturn {\n\t\thours: Math.floor(results.totalSeconds / 60 / 60),\n\t\tminutes: Math.floor((results.totalSeconds / 60) % 60),\n\t\tseconds: Math.floor(results.totalSeconds % 60),\n\t\ttotalMinutes: results.totalMinutes,\n\t\ttotalSeconds: results.totalSeconds\n\t};\n}",
  "function getEmailForwardingSupportedDomains( domains ) {\n\treturn domains.filter( function( domain ) {\n\t\tconst domainHasGSuite = hasGSuite( domain );\n\t\tconst wpcomHosted =\n\t\t\tincludes( [ domainTypes.REGISTERED ], domain.type ) && domain.hasWpcomNameservers;\n\t\tconst mapped = includes( [ domainTypes.MAPPED ], domain.type );\n\t\treturn ( wpcomHosted || mapped ) && ! domainHasGSuite;\n\t} );\n}",
  "function getString(ref)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (ref)\n\t\t\t\t{\n\t\t\t\t\ttry \n\t\t\t\t\t{\t\n\t\t\t\t\t\treturn ref;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn ref.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry \n\t\t\t\t\t{\n\t\t\t\t\t\treturn ref.toString();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) \n\t\t\t\t\t{\n\t\t\t\t\t\treturn \"undefined\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} catch (e)\n\t\t\t{\n\t\t\t\t// if we can not convert it to a string write \"undefined\" just like javascript\n\t\t\t\treturn \"undefined\";\n\t\t\t}\n\t\t}",
  "function Jenkins(options, log) {\n  var parsed = url.parse(options.url);\n\n  if (options.username && options.password) {\n    parsed['auth'] = util.format('%s:%s', options.username, options.password);\n  }\n\n  this._url = url.format(parsed);\n  this._options = options;\n  this.log = log || logmagic.local('jenkins');\n}",
  "function checkIndentInArrayOrObjectBlock(node) {\n\t\t// Skip inline\n\t\tif (isSingleLineNode(node)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n\t\t// filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n\t\telements = elements.filter(function(elem) {\n\t\t\treturn elem !== null;\n\t\t});\n\n\t\t// Skip if first element is in same line with this node\n\t\tif (elements.length > 0 && elements[0].loc.start.line === node.loc.start.line) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar nodeIndent;\n\t\tvar elementsIndent;\n\t\tvar parentVarNode = getVariableDeclaratorNode(node);\n\n\t\t// TODO - come up with a better strategy in future\n\t\tif (isNodeFirstInLine(node)) {\n\t\t\tvar parent = node.parent;\n\t\t\tvar effectiveParent = parent;\n\n\t\t\tif (parent.type === \"MemberExpression\") {\n\t\t\t\tif (isNodeFirstInLine(parent)) {\n\t\t\t\t\teffectiveParent = parent.parent.parent;\n\t\t\t\t} else {\n\t\t\t\t\teffectiveParent = parent.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeIndent = getNodeIndent(effectiveParent);\n\t\t\tif (parentVarNode && parentVarNode.loc.start.line !== node.loc.start.line) {\n\t\t\t\tif (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n\t\t\t\t\tif (parentVarNode.loc.start.line === effectiveParent.loc.start.line) {\n\t\t\t\t\t\tnodeIndent = nodeIndent + (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tparent.type === \"ObjectExpression\" ||\n\t\t\t\t\t\tparent.type === \"ArrayExpression\" ||\n\t\t\t\t\t\tparent.type === \"CallExpression\" ||\n\t\t\t\t\t\tparent.type === \"ArrowFunctionExpression\" ||\n\t\t\t\t\t\tparent.type === \"NewExpression\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tnodeIndent = nodeIndent + indentSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && effectiveParent.type !== \"MemberExpression\" && effectiveParent.type !== \"ExpressionStatement\" && effectiveParent.type !== \"AssignmentExpression\" && effectiveParent.type !== \"Property\") {\n\t\t\t\tnodeIndent = nodeIndent + indentSize;\n\t\t\t}\n\n\t\t\telementsIndent = nodeIndent + indentSize;\n\n\t\t\tcheckFirstNodeLineIndent(node, nodeIndent);\n\t\t} else {\n\t\t\tnodeIndent = getNodeIndent(node);\n\t\t\telementsIndent = nodeIndent + indentSize;\n\t\t}\n\n\t\t// check if the node is a multiple variable declaration, if yes then make sure indentation takes into account\n\t\t// variable indentation concept\n\t\tif (isNodeInVarOnTop(node, parentVarNode)) {\n\t\t\telementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n\t\t}\n\n\t\tif (node.parent && node.parent.type === \"CallExpression\" && node.parent.arguments.length > 1 && isNodeFirstArgument(node) && isNodeOnSameLineAsPrevious(node) && isNextArgumentOnNextLine(node)) {\n\t\t\telementsIndent += indentSize;\n\t\t}\n\n\t\t// Comma can be placed before property name\n\t\tcheckNodesIndent(elements, elementsIndent, true);\n\n\t\tif (elements.length > 0) {\n\t\t\t// Skip last block line check if last item in same line\n\t\t\tif (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar lastIndent = elementsIndent - indentSize;\n\n\t\tcheckLastNodeLineIndent(node, lastIndent);\n\t}",
  "function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t}",
  "function insertDOM() {\n\tif ( null !== document.getElementById( 'directlyRTMScript' ) ) {\n\t\treturn;\n\t}\n\tconst d = document.createElement( 'div' );\n\td.id = 'directlyRTMScript';\n\td.src = DIRECTLY_ASSETS_BASE_URL;\n\tdocument.body.appendChild( d );\n}",
  "function(e) {\n\t\tvar self = this;\n\n\t\t// necessary for mobile webkit devices (manual focus triggering\n\t\t// is ignored unless invoked within a click event)\n    // also necessary to reopen a dropdown that has been closed by\n    // closeAfterSelect\n\t\tif (!self.isFocused || !self.isOpen) {\n\t\t\tself.focus();\n\t\t\te.preventDefault();\n\t\t}\n\t}",
  "function( app ) {\n\tthis.app = app;\n\tthis.loaded = false;\n\tthis.preloadThreshold = 3000;\n\tthis.plugins = {};\n\tthis.modifications = {};\n\tthis.customTests = [];\n\n\t// Allow plugins 1500 ms to register before we start polling their\n\tsetTimeout( this._pollLoadingPlugins.bind( this ), 1500 );\n}",
  "function (newPaneOptions) {\n    var kb = UI.store\n    var newInstance = newPaneOptions.newInstance\n    if (!newInstance) {\n      let uri = newPaneOptions.newBase\n      if (uri.endsWith('/')) {\n        uri = uri.slice(0, -1)\n        newPaneOptions.newBase = uri\n      }\n      newInstance = kb.sym(uri)\n    }\n\n    var contentType = mime.lookup(newInstance.uri)\n    if (!contentType || !contentType.includes('html')) {\n      newInstance = $rdf.sym(newInstance.uri + '.html')\n    }\n    newPaneOptions.newInstance = newInstance // Save for creation system\n\n    console.log('New dokieli will make: ' + newInstance)\n\n    var htmlContents = DOKIELI_TEMPLATE\n    var filename = newInstance.uri.split('/').slice(-1)[0]\n    filename = decodeURIComponent(filename.split('.')[0])\n    const encodedTitle = filename.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')\n    htmlContents = htmlContents.replace('<title>', '<title>' + encodedTitle)\n    htmlContents = htmlContents.replace('</article>', '<h1>' + encodedTitle + '</h1></article>')\n    console.log('@@ New HTML for Dok:' + htmlContents)\n    return new Promise(function (resolve, reject) {\n      kb.fetcher.webOperation('PUT', newInstance.uri, { data: htmlContents, contentType: 'text/html' })\n        .then(function () {\n          console.log('new Dokieli document created at ' + newPaneOptions.newInstance)\n          resolve(newPaneOptions)\n        }).catch(function (err) {\n          console.log('Error creating dokelili dok at ' +\n            newPaneOptions.newInstance + ': ' + err)\n        })\n    })\n  }",
  "function(array, fn, scope) {\n            var i = 0,\n                len = array.length;\n\n            for (; i < len; i++) {\n                if (fn.call(scope || array, array[i], i)) {\n                    return array[i];\n                }\n            }\n            return null;\n        }",
  "function lastIndexOfOutside(data, item, index, exclude) {\n    var result, positionResult = {start: index ? index + 1 : data.length + 1, end: 0};\n\n    do {\n        result = data.lastIndexOf(item, positionResult.start - 1);\n    } while (result.index !== -1 && (positionResult = inPosition(result.index, exclude)));\n    return result;\n}",
  "function (func) {\n\tvar fnStr = func.toString().replace( /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg, '' );\n\treturn fnStr.slice( fnStr.indexOf( '(' ) + 1, fnStr.indexOf( ')' )).match(/([^\\s,]+)/g) || [];\n}",
  "function() {\n        var hash = new this.self(this.initialConfig),\n            map = this.map,\n            key;\n\n        hash.suspendEvents();\n        for (key in map) {\n            if (map.hasOwnProperty(key)) {\n                hash.add(key, map[key]);\n            }\n        }\n        hash.resumeEvents();\n        return hash;\n    }",
  "function text(message, effect, lightColor) {\n        return [\n            use(effect[0], lightColor),\n            String(message),\n            use(effect[1], lightColor)\n        ].join('');\n    }",
  "function toTitleCase() {\n\t  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t  return input.toString().replace(/\\w\\S*/g, function (text) {\n\t    return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();\n\t  });\n\t}",
  "function doBegin(n) {\n        if (n !== 'html' && !option.fragment) {\n            if (n === 'div' && option.adsafe) {\n                error(\"ADSAFE: Use the fragment option.\");\n            } else {\n                error(\"Expected '{a}' and instead saw '{b}'.\",\n                    token, 'html', n);\n            }\n        }\n        if (option.adsafe) {\n            if (n === 'html') {\n                error(\n\"Currently, ADsafe does not operate on whole HTML documents. It operates on <div> fragments and .js files.\", token);\n            }\n            if (option.fragment) {\n                if (n !== 'div') {\n                    error(\"ADsafe violation: Wrap the widget in a div.\", token);\n                }\n            } else {\n                error(\"Use the fragment option.\", token);\n            }\n        }\n        option.browser = true;\n        assume();\n    }",
  "function (event) {\n            // Only pay attention to delegated route events\n            // if `policy` is declared in event.target\n            if ( !event.target || !event.target.policy ) {\n                return;\n            }\n\n            // Bind policy function to route\n            var fn = this.lookupFn(event.target.policy, 'config.routes');\n            sails.router.bind(event.path, fn, event.verb, _.merge(event.options, event.target));\n        }",
  "function getIgnoresEnum() {\n    return Object.keys(\n        OPTIONS.reduce((retv, key) => {\n            for (const alias of FEATURES[key].alias) {\n                retv[alias] = true\n            }\n            retv[key] = true\n            return retv\n        }, Object.create(null))\n    )\n}",
  "function getModuleExportsNodes(scope) {\n    const variable = scope.set.get(\"module\")\n    if (variable == null) {\n        return []\n    }\n    return variable.references\n        .map(reference => reference.identifier.parent)\n        .filter(\n            node =>\n                node.type === \"MemberExpression\" &&\n                getStaticPropertyName(node) === \"exports\"\n        )\n}",
  "function jscoverage_recalculateSourceTab() {\r\n  if (! jscoverage_currentFile) {\r\n    jscoverage_endLengthyOperation();\r\n    return;\r\n  }\r\n  var progressLabel = document.getElementById('progressLabel');\r\n  progressLabel.innerHTML = 'Calculating coverage ...';\r\n  var progressBar = document.getElementById('progressBar');\r\n  ProgressBar.setPercentage(progressBar, 20);\r\n  setTimeout(jscoverage_makeTable, 0);\r\n}",
  "function addDefinition(defName) {\n  var definition = definitions[defName];\n  return function(params, done) {\n    if (!done && typeof params === 'function') {\n      done = params;\n      params = {};\n    }\n\n    var url = this.config.baseUrl + definition.url;\n    var xtraParams = {};\n    xtraParams.fmt = this.config.responseFormat;\n    xtraParams.api_key = this.config.apiKey;\n\n    try {\n      Object.keys(definition.params).forEach(function(paramName) {\n        var paramDef = definition.params[paramName];\n        if (!params[paramName]) {\n          if (paramDef.required) {\n            throw new Error('Parameter ' + paramName + ' is required');\n          } else {\n            return;\n          }\n        }\n        if (paramDef.location === 'url') {\n          url = url.replace(new RegExp('{' + paramName + '}', 'g'), params[paramName]);\n        } else if (paramDef.location === 'querystring') {\n          xtraParams[paramName] = params[paramName];\n        }\n      });\n    } catch (e) {\n      return done(e);\n    }\n\n    return request\n      .get(url)\n      .query(xtraParams)\n      .end(function onEnd(err, res) {\n        return done(err, res.body);\n      });\n  };\n}",
  "function WPCOMUndocumented( token, reqHandler ) {\n\tif ( ! ( this instanceof WPCOMUndocumented ) ) {\n\t\treturn new WPCOMUndocumented( token, reqHandler );\n\t}\n\n\tif ( 'function' === typeof token ) {\n\t\treqHandler = token;\n\t\ttoken = null;\n\t} else if ( token ) {\n\t\tthis.loadToken( token );\n\t}\n\n\twpcomFactory.call( this, token, function( params, fn ) {\n\t\tif ( this.isTokenLoaded() ) {\n\t\t\t// authToken is used in wpcom-xhr-request,\n\t\t\t// which is used for the signup flow in the REST Proxy\n\t\t\tparams = assign( {}, params, { authToken: this._token, token: this._token } );\n\t\t}\n\n\t\treturn reqHandler( params, fn );\n\t} );\n\n\tdebug( 'Extending wpcom with undocumented endpoints.' );\n}",
  "function(process){\n\t\tvar subSection = new TextSection();\n\t\tthis.last().add({process: process, truthy: subSection});\n\t\tthis.stack.push(subSection);\n\t}",
  "function(p, angle) {\n            p = point(p);\n\t    var center = point(this.x + this.width/2, this.y + this.height/2);\n            var result;\n            if (angle) p.rotate(center, angle);\n            \n\t    // (clockwise, starting from the top side)\n\t    var sides = [\n\t        line(this.origin(), this.topRight()),\n\t        line(this.topRight(), this.corner()),\n\t        line(this.corner(), this.bottomLeft()),\n\t        line(this.bottomLeft(), this.origin())\n\t    ];\n\t    var connector = line(center, p);\n            \n\t    for (var i = sides.length - 1; i >= 0; --i){\n\t        var intersection = sides[i].intersection(connector);\n\t        if (intersection !== null){\n\t\t    result = intersection;\n                    break;\n\t        }\n\t    }\n            if (result && angle) result.rotate(center, -angle);\n            return result;\n        }",
  "function RunNextSetup() {\n    if (index < length) {\n      try {\n        suite.benchmarks[index].Setup();\n      } catch (e) {\n        suite.NotifyError(e);\n        return null;\n      }\n      return RunNextBenchmark;\n    }\n    suite.NotifyResult();\n    return null;\n  }",
  "function subOf(child, mixin) {\n  if(child === mixin) return true;\n  if(child && child.constructors) {\n    for(var i in child.constructors) {\n      var parent = child.constructors[i];\n\n      // avoid dead loop\n      if(parent === child) continue;\n\n      if(parent === mixin) return true;\n      if(subOf(parent, mixin)) return true;\n    }\n  }\n  return false;\n}",
  "function(match, value, index, length) {\n  if (!this.currentMacro) return;\n  this.currentMacro.args.push({\n    start: index + value.length,\n    index: index,\n    length: length,\n    value: value\n  });\n}",
  "function(elementToChange) {\n      var that        = this,\n          firstField  = this.container.querySelector(SELECTOR_FORM_ELEMENTS);\n      this.elementToChange = elementToChange;\n      this._observe();\n      this._interpolate();\n      if (elementToChange) {\n        this.interval = setInterval(function() { that._interpolate(true); }, 500);\n      }\n      dom.addClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = \"\";\n      this.fire(\"show\");\n      if (firstField && !elementToChange) {\n        try {\n          firstField.focus();\n        } catch(e) {}\n      }\n    }",
  "function isValid(message) {\n  if (!Constants.equals(message.slice(4, 16))) return false;\n\n  var checksum = message.readUInt16BE(message.length - 2);\n\n  return checksum === crc(message.slice(16, -2));\n}",
  "function( participle, sentencePart, attributes ) {\n\tthis.setParticiple( participle );\n\tthis.setSentencePart( sentencePart );\n\tthis._determinesSentencePartIsPassive = false;\n\n\tattributes = attributes || {};\n\n\tdefaults( attributes, defaultAttributes );\n\n\tvalidateAttributes( attributes );\n\n\tthis._attributes = attributes;\n}",
  "function getComponentDescendants (root, component, onlyChildren, includeSelf) {\n    var node = rquery_getDOMNode(component),\n        descendants = [];\n\n    if (onlyChildren) {\n      descendants = node.children;\n    } else {\n      descendants = node.getElementsByTagName('*');\n    }\n\n    // convert to array\n    descendants = _.toArray(descendants);\n\n    if (includeSelf) {\n      descendants.unshift(rquery_getDOMNode(component));\n    }\n\n    injectCompositeComponents(root, descendants);\n\n    return descendants;\n  }",
  "function _positionForIndex(index) {\n    var textTillIndex = el.value.substring(0,index);\n    var row = (textTillIndex.match(/\\n/g) || []).length + 1;\n    var col = textTillIndex.length - textTillIndex.lastIndexOf(\"\\n\");\n\n    return {\n      row: row,\n      column: col\n    }\n  }",
  "function Polling (objGoogleCheckout) {\n\tvar self = this;\n\t\n\t//todo: check the constructor name\n\tassert.ok(objGoogleCheckout, \"A GoogleCheckout object is the only required argument\");\n\t\n\tself.gc = objGoogleCheckout;\n\tself.settings = self.gc.settings;\n\tself.continueToken = null;\n}",
  "function get(option) {\n    if (option && option.resolvePaths && Array.isArray(option.resolvePaths)) {\n        return option.resolvePaths.map(String)\n    }\n    return null\n}",
  "function whip(gulp, taste, opts) {\n    opts = getOptions(opts);\n    opts.taste = taste;\n\n    var tasks = _.extend({}, opts.tasksets);\n\n    // loop through plugins so we can get tasks from them\n    _.each(getPlugins(opts), function (plugin) {\n        var pluginRoot = plugin.rootDir;\n        var pluginBuildDir = pluginRoot + delim + 'build';\n\n        // look through files in the plugin build directory to try and find tasks\n        if (fs.existsSync(pluginBuildDir)) {\n            _.each(fs.readdirSync(pluginBuildDir), function (pluginFile) {\n                var taskName, task;\n\n                // if the file name starts with 'task.' then it is a task file\n                if (taskRegex.test(pluginFile)) {\n\n                    // the task name is the middle part of the file name (i.e. blah for task.blah.js)\n                    taskName = pluginFile.match(taskRegex)[1];\n                    task = require(pluginBuildDir + delim + pluginFile)(gulp, opts);\n\n                    // if task is function or an object with deps and task\n                    if (_.isFunction(task) || (task.deps && task.task)) {\n                        tasks[taskName] = task;\n                    }\n                    // else if it's an object, then there are subtasks\n                    else if (_.isObject(task)) {\n                        _.each(task, function (subtask, subtaskName) {\n                            var fullTaskName = subtaskName === '' ? taskName : taskName + '.' + subtaskName;\n                            tasks[fullTaskName] = subtask;\n                        });\n                    }\n                    else {\n                        throw new Error(pluginBuildDir + delim + pluginFile + ' is invalid');\n                    }\n                }\n            });\n        }\n    });\n\n    // now we have all the tasks in an object so let's add them to gulp\n    _.each(tasks, function (task, taskName) {\n        if (_.isFunction(task) || _.isArray(task)) {\n            gulp.task(taskName, task);\n        }\n        else if (task.deps && task.task) {\n            gulp.task(taskName, task.deps, task.task);\n        }\n        else {\n            throw new Error('Invalid task for ' + taskName);\n        }\n    });\n}",
  "function(elem, ignoreScroll) {\n        var rect = elem.getBoundingClientRect();\n        var result = {\n          top:    rect.top | 0,\n          left:   rect.left | 0,\n          right:  rect.right | 0,\n          bottom: rect.bottom | 0,\n          width:  (rect.right - rect.left) | 0,\n          height: (rect.bottom - rect.top) | 0\n        };\n\n        if (ignoreScroll) { return result; }\n\n        var body = env.doc.body;\n        result.top += env.root.pageYOffset || body.scrollTop;\n        result.top += env.root.pageXOffset || body.scrollLeft;\n        return result;\n    }",
  "function encodePath(path) {\n  var segments = path.split('/'),\n      i = segments.length;\n\n  while (i--) {\n    // decode forward slashes to prevent them from being double encoded\n    segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, '/'));\n  }\n\n  return segments.join('/');\n}",
  "function isTrackingPixel( image ) {\n\tif ( ! image || ! image.src ) {\n\t\treturn false;\n\t}\n\n\tconst edgeLength = image.height + image.width;\n\treturn edgeLength === 1 || edgeLength === 2;\n}",
  "function localeComparator(model1, model2) {\n    var a1 = model1.get(this.sortField),\n        a2 = model2.get(this.sortField);\n\n    if (a1 !== undefined && a1.localeCompare) {\n        var result = a1.localeCompare(a2) * this.sortDir;\n        if (result || !this.secondarySortField) {\n            return result;\n        }\n        a1 = model1.get(this.secondarySortField);\n        a2 = model2.get(this.secondarySortField);\n        return a1.localeCompare(a2) * this.sortDir;\n    }\n\n    return a1 > a2 ? this.sortDir : (a1 < a2 ? -this.sortDir : 0);\n}",
  "function extraIndentVal(nodes, i) {\n    var subset = [];\n    var declaration = nodes.get(i);\n    if (!declaration.is('declaration')) return;\n\n    for (var x = declaration.length; x--;) {\n      if (!declaration.get(x).is('value')) continue;\n\n      x--;\n\n      while (!declaration.get(x).is('propertyDelimiter')) {\n        subset.push(declaration.get(x));\n        x--;\n      }\n\n      break;\n    }\n    return extraIndent(subset);\n  }",
  "function(args) {\n    var opts = {\n      auth: null,\n      headers: {},\n    };\n    if (args.length > 0) {\n      var arg = args[args.length - 1];\n      if (utils.isAuthKey(arg)) {\n        opts.auth = args.pop();\n      } else if (utils.isOptionsHash(arg)) {\n        var params = args.pop();\n\n        var extraKeys = Object.keys(params).filter(function(key) {\n          return OPTIONS_KEYS.indexOf(key) == -1;\n        });\n\n        if (extraKeys.length) {\n          emitWarning('Invalid options found (' + extraKeys.join(', ') + '); ignoring.');\n        }\n\n        if (params.api_key) {\n          opts.auth = params.api_key;\n        }\n        if (params.idempotency_key) {\n          opts.headers['Idempotency-Key'] = params.idempotency_key;\n        }\n        if (params.stripe_account) {\n          opts.headers['Stripe-Account'] = params.stripe_account;\n        }\n        if (params.stripe_version) {\n          opts.headers['Stripe-Version'] = params.stripe_version;\n        }\n      }\n    }\n    return opts;\n  }",
  "function(value) {\n            value = value || '';\n            return this.setStyle({\n                left : value,\n                right : value,\n                top : value,\n                bottom : value,\n                'z-index' : '',\n                position : STATIC\n            });\n        }",
  "function (autoRender, config) {\n            if (!tip) {\n                if (!Ext.isReady) {\n                    Ext.onReady(function(){\n                        Ext.tip.QuickTipManager.init(autoRender, config);\n                    });\n                    return;\n                }\n\n                var tipConfig = Ext.apply({ disabled: disabled, id: 'ext-quicktips-tip' }, config),\n                    className = tipConfig.className,\n                    xtype = tipConfig.xtype;\n\n                if (className) {\n                    delete tipConfig.className;\n                } else if (xtype) {\n                    className = 'widget.' + xtype;\n                    delete tipConfig.xtype;\n                }\n\n                if (autoRender !== false) {\n                    tipConfig.renderTo = document.body;\n\n                    //<debug>\n                    if (tipConfig.renderTo.tagName.toUpperCase() != 'BODY') { // e.g., == 'FRAMESET'\n                        Ext.Error.raise({\n                            sourceClass: 'Ext.tip.QuickTipManager',\n                            sourceMethod: 'init',\n                            msg: 'Cannot init QuickTipManager: no document body'\n                        });\n                    }\n                    //</debug>\n                }\n\n                tip = Ext.create(className || 'Ext.tip.QuickTip', tipConfig);\n\n                // private.\n                // Need a globally accessble way of testing whether QuickTipsManager is both loaded AND initialized.\n                Ext.quickTipsActive = true;\n            }\n        }",
  "function toggleNativeControls() {\n\t    var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t    if (toggle && this.isHTML5) {\n\t      this.media.setAttribute('controls', '');\n\t    } else {\n\t      this.media.removeAttribute('controls');\n\t    }\n\t  }",
  "function KeyboardShortcuts( keyBindings ) {\n\tif ( ! ( this instanceof KeyboardShortcuts ) ) {\n\t\treturn new KeyboardShortcuts( keyBindings );\n\t}\n\n\t// the last key and when it was pressed\n\tthis.lastKey = undefined;\n\tthis.lastKeyTime = undefined;\n\n\t// the time limit for determining whether two keys in order represent a key sequence\n\tthis.timeLimit = 2000;\n\n\t// save a copy of the bound last-key-pressed handler so it can be removed later\n\tthis.boundKeyHandler = this.handleKeyPress.bind( this );\n\n\t// is the notifications panel open? If so we don't fire off key-handlers\n\tthis.isNotificationsOpen = false;\n\n\t// bind the shortcuts if this is a browser environment\n\tif ( typeof window !== 'undefined' ) {\n\t\tkeymaster.filter = ignoreDefaultAndContentEditableFilter;\n\n\t\tthis.bindShortcuts( keyBindings );\n\t}\n}",
  "function (command, parameters, callback) {\n      if (typeof parameters === 'function') {\n        callback = parameters;\n        parameters = {};\n      }\n\n      parameters || (parameters = {});\n      parameters.command = command;\n      \n      const options = {\n        method: 'GET',\n        url: PUBLIC_API_URL,\n        qs: parameters\n      };\n\n      options.qs.command = command;\n\n      return this._request(options, callback);\n    }",
  "function convert(report) {\n  return []\n    .concat(\n      Parsers.parse('headers', report),\n      Parsers.parse('reason',  report),\n      Parsers.parse('threads', report),\n      Parsers.parse('cpu',     report),\n      Parsers.parse('images',  report),\n      Parsers.parse('extras',  report)\n    )\n    .join('\\n')\n}",
  "function loadStylesheet(href) {\n  return new Promise(resolve => {\n    const link = document.createElement('link');\n    link.onload = resolve;\n    link.rel = 'stylesheet'\n    link.type = 'text/css';\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}",
  "function() {\n        this.addEvents(\n            /**\n             * @event change\n             * Fires when the value of a field is changed via the {@link #setValue} method.\n             * @param {Ext.form.field.Field} this\n             * @param {Object} newValue The new value\n             * @param {Object} oldValue The original value\n             */\n            'change',\n            /**\n             * @event validitychange\n             * Fires when a change in the field's validity is detected.\n             * @param {Ext.form.field.Field} this\n             * @param {Boolean} isValid Whether or not the field is now valid\n             */\n            'validitychange',\n            /**\n             * @event dirtychange\n             * Fires when a change in the field's {@link #isDirty} state is detected.\n             * @param {Ext.form.field.Field} this\n             * @param {Boolean} isDirty Whether or not the field is now dirty\n             */\n            'dirtychange'\n        );\n\n        this.initValue();\n        \n        //<debug>\n        var badNames = [\n            'tagName',\n            'nodeName',\n            'children',\n            'childNodes'\n        ], name = this.name;\n            \n        if (name && Ext.Array.indexOf(badNames, name) > -1) {\n            Ext.log.warn(\n                ['It is recommended to not use \"', name, '\" as a field name, because it ',\n                'can cause naming collisions during form submission.'].join('')\n            );\n        }\n        //</debug>\n    }",
  "function(qName, data, opts) {\n    var q = queue.get(qName);\n    return q.add(data, opts).then(function(job) {\n      if (!job) {\n        return job;\n      }\n      return job.getState().then(function(state) {\n        job.state = state;\n        return job;\n      });\n    });\n  }",
  "function reverse (s) {\n                    if(s.length < 64) {\n                        var str = '';\n                        for(var i = s.length; i >= 0; i--) str += s.charAt(i);\n                        return str;\n                    }\n                    else {\n                        return s.split('').reverse().join('');\n                    }\n                }",
  "function repeat(times) {\r\n    return function* (it) {\r\n        const buffer = [];\r\n        for (const item of it) {\r\n            buffer.push(item);\r\n            yield item;\r\n        }\r\n        for (let i = 0; i < times; ++i) {\r\n            yield* buffer;\r\n        }\r\n    };\r\n}",
  "function(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\t\t\n\t\t\t\t\tif (data.placeholder)\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\n\t\t\t\t\telse\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t_.each(['start', 'end', 'content'], function(p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn maxNum;\n\t\t}",
  "function clamp() {\n\t  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 255;\n\t  return Math.min(Math.max(input, min), max);\n\t}",
  "function ExecutionContext(options) {\n    EventEmitter.call(this);\n\n    this.stringVars = {};\n    this.numberVars = {};\n    this.pointers = {};\n    this.gosubs = [];\n    this.private = {\n        rnd_seed: Math.random(),\n        sprites: [],\n        data: []\n    };\n    this.constants = require('./constants');\n    this.running = false;\n    options = options || {};\n    this.options = options;\n\n    if (typeof options.delay === 'undefined') options.delay = false;\n\n    // Copy all functions as constants\n    for (var k in functions) {\n        if (!functions.hasOwnProperty(k)) continue;\n        this.constants[k] = functions[k];\n    }\n\n    // Stop multiple contexts conflicting with constants\n    this.constants = pUtil.shallowClone(this.constants);\n}",
  "function IdleTask(scheduler, v1, count) {\n  this.scheduler = scheduler;\n  this.v1 = v1;\n  this.count = count;\n}",
  "function loadFormatter(formatterPath) {\n    try {\n        // @TODO: deprecate\n        formatterPath = (formatterPath === 'jslint_xml') ? 'jslint' : formatterPath;\n        return require('./lib/' + formatterPath + '_emitter');\n    } catch (e) {\n        console.error('Unrecognized format: %s', formatterPath);\n        console.error('This emitter was not found on lib folder.\\nYou can always create yours :)\\n');\n        throw e;\n    }\n}",
  "function(forModel) {\n      let model = {\n        model: app.models[forModel],\n        prop: app.models[forModel].definition.properties,\n        settings: app.models[forModel].settings,\n        meta: app.models[forModel].settings.zlMeta,\n        ns: ''\n      };\n      if (model.meta && model.meta['Namespace']) {\n        model.ns = model.meta['Namespace'];\n      }\n      return model;\n    }",
  "function hmacSign (input, algorithm, secret) {\n  return crypto.createHmac(algorithm, secret).update(input).digest('base64')\n}",
  "function() {\n      var t = this;\n\n      var p;\n      if (!this.__opened) {\n        this.__opened = true;\n\n        var resManager = null;\n        if (this.isProcessResources()) {\n          resManager = new qx.tool.compiler.resources.Manager(this);\n        }\n        this.__resManager = resManager;\n        p = Promise.all(\n            [ \n              util.promisifyThis(t.loadDatabase, t),\n              new Promise((resolve, reject) => {\n                if (resManager) {\n                  log.debug(\"Loading resource database\");\n                  return util.promisifyThis(resManager.loadDatabase, resManager)\n                    .then(resolve)\n                    .catch(reject);\n                }\n                resolve();\n                return undefined;\n              })\n            ]);\n      } else {\n        p = Promise.resolve(); \n      }\n\n      return p.then(() => {\n          log.debug(\"Scanning source code\");\n          return util.promisifyThis(t.initialScan, t);\n        })\n        .then(() => {\n          log.debug(\"Saving database\");\n          return t.saveDatabase();\n        });\n    }",
  "function makeDefine(mapping, id) {\n  var require = function(id) { return mapping[id]; };\n  var exports = mapping[id] = {};\n  var module = null; // Unused arg. Included for completeness.\n  return function(factory) {\n    factory(require, exports, module);\n  };\n}",
  "function mounted () {\n    if (!inBrowser) {\n      return;\n    }\n\n    /**\n     * Center the popup on dual screens\n     * http://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen/32261263\n     */\n    var dualScreenLeft = $window.screenLeft !== undefined ? $window.screenLeft : screen.left;\n    var dualScreenTop = $window.screenTop !== undefined ? $window.screenTop : screen.top;\n\n    var width = $window.innerWidth ? $window.innerWidth : (document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width);\n    var height = $window.innerHeight ? $window.innerHeight : (document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height);\n\n    this.popup.left = ((width / 2) - (this.popup.width / 2)) + dualScreenLeft;\n    this.popup.top = ((height / 2) - (this.popup.height / 2)) + dualScreenTop;\n  }",
  "function( array, language ) {\n\tif ( isUndefined( language ) || language === \"\" ) {\n\t\tlanguage = \"en\";\n\t}\n\n\tconst functionWords = get( getFunctionWords, [ language ], [] );\n\n\tif ( array.length > 1 ) {\n\t\tconst arrayFiltered = filter( array, function( word ) {\n\t\t\treturn ( ! includes( functionWords.all, word.trim().toLocaleLowerCase() ) );\n\t\t} );\n\n\t\tif ( arrayFiltered.length > 0 ) {\n\t\t\treturn arrayFiltered;\n\t\t}\n\t}\n\n\treturn array;\n}",
  "function(key) {\n        var num = parseInt(this.loadVar(key));\n        if (isNaN(num)) {\n            exitProcess('the value of ' +key+' is a necessary int ,but get ' + num, this.alarm);\n            return false;\n        }\n        return num;\n    }",
  "function TimerEvent(label, color, pause, thread_id) {\n    assert(thread_id >= 0 && thread_id < kNumThreads, \"invalid thread id\");\n    this.label = label;\n    this.color = color;\n    this.pause = pause;\n    this.ranges = [];\n    this.thread_id = thread_id;\n    this.index = ++num_timer_event;\n  }",
  "function workaround() {\n    var node = document.createElement('div');\n\n    function matches(element, selector) {\n        if (method.call(element, selector)) {\n            return true;\n        } else if (!element.parentNode) {\n            // If node is not attached, temporarily attach to node\n            node.appendChild(element);\n            var result = method.call(element, selector);\n            node.removeChild(element);\n            return result;\n        } else {\n            return false;\n        }\n    }\n\n    return matches;\n}",
  "function(client){\n  this.settings = client.settings;\n  this.client = client;\n  this.accessTokenInactiveTimer = null;\n  this.accessTokenCreationTimer = null;\n}",
  "function() {\n    const result = this.node(\"if\");\n    let body = null;\n    let alternate = null;\n    let shortForm = false;\n    let test = null;\n    test = this.next().read_if_expr();\n\n    if (this.token === \":\") {\n      shortForm = true;\n      this.next();\n      body = this.node(\"block\");\n      const items = [];\n      while (this.token !== this.EOF && this.token !== this.tok.T_ENDIF) {\n        if (this.token === this.tok.T_ELSEIF) {\n          alternate = this.read_elseif_short();\n          break;\n        } else if (this.token === this.tok.T_ELSE) {\n          alternate = this.read_else_short();\n          break;\n        }\n        items.push(this.read_inner_statement());\n      }\n      body = body(null, items);\n      this.expect(this.tok.T_ENDIF) && this.next();\n      this.expectEndOfStatement();\n    } else {\n      body = this.read_statement();\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_if();\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.next().read_statement();\n      }\n    }\n    return result(test, body, alternate, shortForm);\n  }",
  "function parseRecord(req, res, record) {\n  for (var associationName in res.locals.Model.associations) {\n    if (!record[associationName]) {\n      if ( record.dataValues[ associationName + 'Id' ] ) {\n        record.dataValues[ associationName ] = record[ associationName + 'Id' ];\n      }\n    } else {\n      if (record.dataValues[ associationName + 'Id' ]) {\n        record.dataValues[ associationName ] = record[ associationName + 'Id' ];\n      } else if ( isObject(record[ associationName ] && record[ associationName ].id) ) {\n        record.dataValues[ associationName ] = record[ associationName ].id;\n      // if is a NxN association\n      } else if( req.we.utils.isNNAssoc ( record[ associationName ] ) ) {\n        record.dataValues[ associationName ] = record[ associationName ].id;\n      } else {\n        for (var i = record.dataValues[ associationName ].length - 1; i >= 0; i--) {\n          record.dataValues[ associationName ][i] = record.dataValues[ associationName ][i].id;\n        }\n      }\n    }\n  }\n  return record;\n}",
  "function checkIndentInFunctionBlock(node) {\n\n\t\t// Search first caller in chain.\n\t\t// Ex.:\n\t\t//\n\t\t// Models <- Identifier\n\t\t//   .User\n\t\t//   .find()\n\t\t//   .exec(function() {\n\t\t//   // function body\n\t\t// });\n\t\t//\n\t\t// Looks for 'Models'\n\t\tvar calleeNode = node.parent; // FunctionExpression\n\t\tvar indent;\n\n\t\tif (calleeNode.parent &&\n\t\t\t(calleeNode.parent.type === \"Property\" ||\n\t\t\tcalleeNode.parent.type === \"ArrayExpression\")) {\n\t\t\t// If function is part of array or object, comma can be put at left\n\t\t\tindent = getNodeIndent(calleeNode, false, false);\n\t\t} else {\n\t\t\t// If function is standalone, simple calculate indent\n\t\t\tindent = getNodeIndent(calleeNode);\n\t\t}\n\n\t\tif (calleeNode.parent.type === \"CallExpression\") {\n\t\t\tvar calleeParent = calleeNode.parent;\n\n\t\t\tif (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n\t\t\t\tif (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n\t\t\t\t\tindent = getNodeIndent(calleeParent);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n\t\t\t\t\tcalleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {\n\t\t\t\t\tindent = getNodeIndent(calleeParent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// function body indent should be indent + indent size\n\t\tindent += indentSize;\n\n\t\t// check if the node is inside a variable\n\t\tvar parentVarNode = getVariableDeclaratorNode(node);\n\t\tif (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n\t\t\tindent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n\t\t}\n\n\t\tif (node.body.length > 0) {\n\t\t\tcheckNodesIndent(node.body, indent);\n\t\t}\n\n\t\tcheckLastNodeLineIndent(node, indent - indentSize);\n\t}",
  "function makeUnique (a) {\n                    if(!(a instanceof Array)) return a;\n\n                    var visited = [];\n                    for(var i = 0; i < a.length; i++) {\n                        if(visited.indexOf(a[i]) === -1) {\n                            visited.push(a[i]);\n                        }\n                        else {\n                            a.splice(i, 1);\n                            i--; // Splice will affect the internal array pointer, so fix it...\n                        }\n                    }\n                    return a;\n                }",
  "function listPrivateKey(keyType, folder, name, noRetry) {\n    let privateKeyName;\n\n    // Try with .key suffix first. If unsuccessful, retry without the .key suffix\n    if (noRetry) {\n        // If present, remove '.key' suffix\n        privateKeyName = name.replace(REG_EXPS.KEY_SUFFIX, '');\n    } else {\n        // Append '.key' suffix, if not present\n        privateKeyName = (name.match(REG_EXPS.KEY_SUFFIX)) ? name : `${name}.key`;\n    }\n\n    return util.runTmshCommand(`list sys ${keyType} /${folder}/${privateKeyName}`)\n        .then((keyData) => {\n            // If no result, retry if a retry hasn't occurred yet.\n            if (!keyData) {\n                if (!noRetry) {\n                    return listPrivateKey(keyType, folder, name, true);\n                }\n                return q();\n            }\n            return q({ privateKeyName, keyData });\n        })\n        .catch((err) => {\n            // If the object is not found (code: 01020036:3), retry if a retry hasn't occurred yet.\n            const notFoundRegex = /01020036:3/;\n            if (err.message.match(notFoundRegex) && !noRetry) {\n                return listPrivateKey(keyType, folder, name, true);\n            }\n            return q.reject(err);\n        });\n}",
  "function(ev) {\n        var handled;\n        /*\n        var handled = keyboardManager.processKeyEvent(ev, this, {\n            isCommandLine: true, isKeyUp: true\n        });\n        */\n\n        // RETURN does a special exec/highlight thing\n        if (ev.keyCode === keys.RETURN) {\n            var worst = this.cli.getWorstHint();\n            // Deny RETURN unless the command might work\n            if (worst.status === Status.VALID) {\n                this.cli.exec();\n                this.element.value = '';\n            }\n            else {\n                // If we've denied RETURN because the command was not VALID,\n                // select the part of the command line that is causing problems\n                // TODO: if there are 2 errors are we picking the right one?\n                dom.setSelectionStart(this.element, worst.start);\n                dom.setSelectionEnd(this.element, worst.end);\n            }\n        }\n\n        this.update();\n\n        // Special actions which delegate to the assignment\n        var current = this.cli.getAssignmentAt(dom.getSelectionStart(this.element));\n        if (current) {\n            // TAB does a special complete thing\n            if (ev.keyCode === keys.TAB) {\n                current.complete();\n                this.update();\n            }\n\n            // UP/DOWN look for some history\n            if (ev.keyCode === keys.UP) {\n                current.increment();\n                this.update();\n            }\n            if (ev.keyCode === keys.DOWN) {\n                current.decrement();\n                this.update();\n            }\n        }\n\n        return handled;\n    }",
  "function (key, value, priority) {\n            var normalizedPriority = this.normalizePriority(priority),\n                serial = this._internalSerialNumbers++;\n            if (this.wrapItems) {\n                return new (this.itemWrapperConstructor) (key, value, normalizedPriority, serial);\n            }\n            try {\n                value.key = key;\n                value.priority = priority;\n                value.serial = serial;\n            }\n            catch (e) {\n                throw new TypeError('PriorityList can only work in \"unwrapped\" mode with values/objects' +\n                    ' that can have properties created/set on them.  Type encountered: `' + sjl.classOf(value) + '`;' +\n                    '  Original error: ' + e.message);\n            }\n            return value;\n        }",
  "function() {\n        var me = this,\n            mon = me.monitor;\n        \n        if (mon) {\n            mon.unbind();\n            me.monitor = null;\n        }\n        me.clearListeners();\n        me.checkValidityTask.cancel();\n        me.checkDirtyTask.cancel();\n    }",
  "function (obj) {\n    var res = _.assign(_.assign({}, this), obj);\n    for (var f in this) {\n      if (_.isFunction(this[f])) {\n        res[f] = this[f];\n      }\n    }\n    if (_.isFunction(res.checkConnection)) {\n      res.checkConnection();\n    }\n    return res;\n  }",
  "function changePosition(el, index) {\n\n            var HTMLElement = el.el;\n            if (HTMLElement && HTMLElement.parentNode) {\n\n                var parentNode = HTMLElement.parentNode,\n                    elGroup = el.elGroup,\n                    size = elGroup.size,\n                    target = elGroup.getKeyByIndex(index) || elGroup.getLast();\n\n                if (target !== HTMLElement) {\n                    if (size - 1 >= index) {\n                        parentNode.insertBefore(HTMLElement, target);\n                    } else if (target.nextSibling !== null) {\n                        parentNode.insertBefore(HTMLElement, target.nextSibling);\n                    } else {\n                        parentNode.appendChild(HTMLElement);\n                    }\n\n                    el.elGroup.changeIndex(HTMLElement, index);\n                }\n            }\n        }",
  "function (kb, x, displayables) {\n      var t = kb.findTypeURIs(subject)\n      for (var k = 0; k < displayables.length; k++) {\n        if ($rdf.Util.mediaTypeClass(displayables[k]).uri in t) {\n          return true\n        }\n      }\n      return false\n    }",
  "function proceedToFetch(loader, load, p) {\n      proceedToTranslate(loader, load, \n        p\n        // 15.2.4.4.1 CallFetch\n        .then(function(address) {\n          if (load.linkSets.length == 0)\n            return;\n          load.address = address;\n\n          return loader.loaderObj.fetch({ name: load.name, metadata: load.metadata, address: address });\n        })\n      );\n    }",
  "function markVersions(instances) {\n        let highestVersion = '0.0.0';\n        let instance;\n\n        Object.keys(instances).forEach((instanceId) => {\n            instance = instances[instanceId];\n            if (instance.version && util.versionCompare(instance.version, highestVersion) > 0) {\n                highestVersion = instance.version;\n            }\n        });\n\n        Object.keys(instances).forEach((instanceId) => {\n            instance = instances[instanceId];\n            if (!instance.version || util.versionCompare(instance.version, highestVersion) === 0) {\n                instance.versionOk = true;\n            } else {\n                instance.versionOk = false;\n            }\n        });\n    }",
  "function(dest, source, names, usePrototypeKeys){\n            if(typeof names == 'string'){\n                names = names.split(/[,;\\s]/);\n            }\n\n            var n,\n                nLen = names? names.length : 0,\n                name;\n\n            for(n = 0; n < nLen; n++) {\n                name = names[n];\n\n                if(usePrototypeKeys || source.hasOwnProperty(name)){\n                    dest[name] = source[name];\n                }\n            }\n\n            return dest;\n        }",
  "function _goToSequence(viewSequence, next, noAnimation) {\n        if (noAnimation) {\n            this._viewSequence = viewSequence;\n            this._scroll.springPosition = undefined;\n            _updateSpring.call(this);\n            this.halt();\n            this._scroll.scrollDelta = 0;\n            _setParticle.call(this, 0, 0, '_goToSequence');\n            this._scroll.scrollDirty = true;\n        }\n        else {\n            this._scroll.scrollToSequence = viewSequence;\n            this._scroll.scrollToRenderNode = viewSequence.get();\n            this._scroll.ensureVisibleRenderNode = undefined;\n            this._scroll.scrollToDirection = next;\n            this._scroll.scrollDirty = true;\n        }\n    }",
  "function first (o, n) {\n                    var gotN = (n === 0 ? true : !!n),\n                        v;\n\n                    n = parseInt(n, 10);\n                    n = isNaN(n) || !isFinite(n) ? 1 : n;\n\n                    if(typeof o === 'boolean') {\n                        return o;\n                    }\n                    else if(typeof o !== 'object') {\n                        if(n !== 0) v = o.toString().slice(0, n); else return undefined;\n                    }\n                    else if(o instanceof Array) {\n                        if(n === 1 && !gotN) return o[0];\n                        if(n === 0 && !gotN) return undefined;\n\n                        return n !== 0 ? o.slice(0, n) :  [];\n                    }\n                    else {\n                        v = {};\n                        libs.object.each(o, 0, n - 1, function (item, key) { v[key] = item; });\n                        var keys = getKeys(v);\n                        if(n === 1 && !gotN && keys.length === 0) return undefined;\n\n                        return keys.length === 1 && !gotN ? v[keys[0]] : v;\n                    }\n                    return v.length === 1 && !gotN ? v[0] : v;\n                }",
  "function(elem, appendElem, stylesToAdd) {\n    // glue to DOM element\n    // elem can be ID or actual DOM element object\n    this.domElement = ZeroClipboard.$(elem);\n    \n    // float just above object, or zIndex 99 if dom element isn't set\n    var zIndex = 99;\n    if (this.domElement.style.zIndex) {\n      zIndex = parseInt(this.domElement.style.zIndex, 10) + 1;\n    }\n    \n    if (typeof(appendElem) == 'string') {\n      appendElem = ZeroClipboard.$(appendElem);\n    }\n    else if (typeof(appendElem) == 'undefined') {\n      appendElem = document.getElementsByTagName('body')[0];\n    }\n    \n    // find X/Y position of domElement\n    var box = ZeroClipboard.getDOMObjectPosition(this.domElement, appendElem);\n    \n    // create floating DIV above element\n    this.div = document.createElement('div');\n    var style = this.div.style;\n    style.position = 'absolute';\n    style.left = '' + box.left + 'px';\n    style.top = '' + box.top + 'px';\n    style.width = '' + box.width + 'px';\n    style.height = '' + box.height + 'px';\n    style.zIndex = zIndex;\n\n    style.left = '0px';\n    style.top = '0px';\n    \n    if (typeof(stylesToAdd) == 'object') {\n      for (addedStyle in stylesToAdd) {\n        style[addedStyle] = stylesToAdd[addedStyle];\n      }\n    }\n    \n    // style.backgroundColor = '#f00'; // debug\n    \n    appendElem.appendChild(this.div);\n    \n    this.div.innerHTML = this.getHTML( box.width, box.height );\n  }",
  "function $SnifferProvider() {\n  this.$get = ['$window', '$document', function($window, $document) {\n    var eventSupport = {},\n        android =\n          int((/android (\\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),\n        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),\n        document = $document[0] || {},\n        documentMode = document.documentMode,\n        vendorPrefix,\n        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,\n        bodyStyle = document.body && document.body.style,\n        transitions = false,\n        animations = false,\n        match;\n\n    if (bodyStyle) {\n      for(var prop in bodyStyle) {\n        if(match = vendorRegex.exec(prop)) {\n          vendorPrefix = match[0];\n          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);\n          break;\n        }\n      }\n\n      if(!vendorPrefix) {\n        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';\n      }\n\n      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));\n      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));\n\n      if (android && (!transitions||!animations)) {\n        transitions = isString(document.body.style.webkitTransition);\n        animations = isString(document.body.style.webkitAnimation);\n      }\n    }\n\n\n    return {\n      // Android has history.pushState, but it does not update location correctly\n      // so let's not use the history API at all.\n      // http://code.google.com/p/android/issues/detail?id=17471\n      // https://github.com/angular/angular.js/issues/904\n\n      // older webkit browser (533.9) on Boxee box has exactly the same problem as Android has\n      // so let's not use the history API also\n      // We are purposefully using `!(android < 4)` to cover the case when `android` is undefined\n      // jshint -W018\n      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),\n      // jshint +W018\n      hashchange: 'onhashchange' in $window &&\n                  // IE8 compatible mode lies\n                  (!documentMode || documentMode > 7),\n      hasEvent: function(event) {\n        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have\n        // it. In particular the event is not fired when backspace or delete key are pressed or\n        // when cut operation is performed.\n        if (event == 'input' && msie == 9) return false;\n\n        if (isUndefined(eventSupport[event])) {\n          var divElm = document.createElement('div');\n          eventSupport[event] = 'on' + event in divElm;\n        }\n\n        return eventSupport[event];\n      },\n      csp: csp(),\n      vendorPrefix: vendorPrefix,\n      transitions : transitions,\n      animations : animations,\n      android: android,\n      msie : msie,\n      msieDocumentMode: documentMode\n    };\n  }];\n}",
  "function (input) {\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if (this.manager.session.prevented) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n            if (hasNone) {\n                //do not prevent defaults if this is a tap gesture\n\n                var isTapPointer = input.pointers.length === 1;\n                var isTapMovement = input.distance < 2;\n                var isTapTouchTime = input.deltaTime < 250;\n\n                if (isTapPointer && isTapMovement && isTapTouchTime) {\n                    return;\n                }\n            }\n\n            if (hasPanX && hasPanY) {\n                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n                return;\n            }\n\n            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n                return this.preventSrc(srcEvent);\n            }\n        }",
  "function () {\n    var exists = fs.existsSync(configHelpers.getConfigPath());\n    if (!exists) {\n      config = { apps: {}, plugins: {} };\n      configHelpers.saveConfig();\n    }\n  }",
  "function _removeLineBreakBeforeAndAfter(node) {\n    var nextSibling     = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && _isLineBreak(nextSibling)) {\n      nextSibling.parentNode.removeChild(nextSibling);\n    }\n    if (previousSibling && _isLineBreak(previousSibling)) {\n      previousSibling.parentNode.removeChild(previousSibling);\n    }\n  }",
  "function(url, val){\n\n        // Create a new object that we can manipulate safely.\n        var object = extend({}, val);\n\n        // Flag so we remember to append any attributes that can't be bound.\n        var append = false;\n\n        // If there are still parameters to bind, pull them out.\n        // Note: We use a different regex here because we need the global flag to ensure we pull all remaining bindings.\n        var remaining = url.match(/:\\w+/ig);\n        if (remaining && remaining.length > 0){\n\n            // Iterate over the remaining potential bindings, looking for matches by name.\n            for (var j = 0; j < remaining.length; j++){\n\n                // Grab the key, stripping the : character.\n                var key = remaining[j].replace(':', '');\n\n                // Does our object contain that key?\n                if (object[key] !== undefined){\n\n                    // Is it a type we can serialise?\n                    if (this.canSerialise(object[key])){\n\n                        // If it is, replace that value.\n                        var keyRegex = new RegExp(':' + key);\n                        url = url.replace(keyRegex, object[key]);\n                    }\n\n                    // Even if it wasn't, delete the value so we don't try again later.\n                    delete object[key];\n                }\n            }\n\n            // If there are still fields left on our object, they need to become query parameters.\n            if (object !== {}){\n                append = true;\n            }\n        }\n\n        // Otherwise, we're going to append the object's values as key/value pairs.\n        else {\n            append = true;\n        }\n\n        // If we need to append key/values, do so.\n        if (append){\n\n            for (var attr in object){\n\n                // If the value is an object or a function, ignore it.\n                if (this.canSerialise(object[attr])){\n\n                    // How are we appending?\n                    var joiner = (url.indexOf('?') >= 0) ? \"&\" : \"?\";\n\n                    // Append.\n                    url += joiner + attr + \"=\" + object[attr];\n                }\n            }\n        }\n\n        return url;\n    }",
  "function(sub) {\n    var Super = this;\n    var Constructor = hasOwn.call(sub, 'constructor') ? sub.constructor : function() {\n      Super.apply(this, arguments);\n    };\n\n    // This initialization logic is somewhat sensitive to be compatible with\n    // divergent JS implementations like the one found in Qt. See here for more\n    // context:\n    //\n    // https://github.com/stripe/stripe-node/pull/334\n    Object.assign(Constructor, Super);\n    Constructor.prototype = Object.create(Super.prototype);\n    Object.assign(Constructor.prototype, sub);\n\n    return Constructor;\n  }",
  "function argMax(array) {\n    var maxIndex = 0\n     , i\n     ;\n    for (i = 0; i < array.length; i++) {\n      if (array[i] > array[maxIndex]) {\n        maxIndex = i;\n      }\n    }\n    return maxIndex;\n  }",
  "function isMeta(expression, value = null) {\n  return expression.type === 'Char' &&\n    expression.kind === 'meta' &&\n    (value ? expression.value === value : /^\\\\[dws]$/i.test(expression.value));\n}",
  "function Base(options) {\n        this._eventOutput = new EventHandler();\n        this._pool = [];\n        EventHandler.setOutputHandler(this, this._eventOutput);\n        if (options) {\n            for (var key in options) {\n                this[key] = options[key];\n            }\n        }\n    }",
  "function(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\t\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tvar profile = require('resources').getVariable('profile');\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t}",
  "function() {\n    let location = null;\n    const args = Array.prototype.slice.call(arguments);\n    args.push(docs);\n    if (typeof result.preBuild === \"function\") {\n      result.preBuild(arguments);\n    }\n    if (self.withPositions || self.withSource) {\n      let src = null;\n      if (self.withSource) {\n        src = parser.lexer._input.substring(start.offset, parser.prev[2]);\n      }\n      if (self.withPositions) {\n        location = new Location(\n          src,\n          start,\n          new Position(parser.prev[0], parser.prev[1], parser.prev[2])\n        );\n      } else {\n        location = new Location(src, null, null);\n      }\n      // last argument is allways the location\n      args.push(location);\n    }\n    // handle lazy kind definitions\n    if (!kind) {\n      kind = args.shift();\n    }\n    // build the object\n    const node = self[kind];\n    if (typeof node !== \"function\") {\n      throw new Error('Undefined node \"' + kind + '\"');\n    }\n    const astNode = Object.create(node.prototype);\n    node.apply(astNode, args);\n    result.instance = astNode;\n    if (result.trailingComments) {\n      // buffer of trailingComments\n      astNode.trailingComments = result.trailingComments;\n    }\n    if (typeof result.postBuild === \"function\") {\n      result.postBuild(astNode);\n    }\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n    return self.resolvePrecedence(astNode, parser);\n  }",
  "function getPropType(propValue) {\n  const propType = typeof propValue;\n  if (Array.isArray(propValue)) {\n    return 'array';\n  }\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return 'object';\n  }\n  return propType;\n}",
  "function fixPath(string){\n  if(string.length < 1){\n    return string;\n  }\n  \n  if(string.charAt(string.length-1) !== path.sep){\n    string += path.sep;\n  }\n  return string;\n}",
  "function(args) {\n    if (args.length < 1 || !isPlainObject(args[0])) {\n      return {};\n    }\n\n    if (!utils.isOptionsHash(args[0])) {\n      return args.shift();\n    }\n\n    var argKeys = Object.keys(args[0]);\n\n    var optionKeysInArgs = argKeys.filter(function(key) {\n      return OPTIONS_KEYS.indexOf(key) > -1;\n    });\n\n    // In some cases options may be the provided as the first argument.\n    // Here we're detecting a case where there are two distinct arguments\n    // (the first being args and the second options) and with known\n    // option keys in the first so that we can warn the user about it.\n    if (optionKeysInArgs.length > 0 && optionKeysInArgs.length !== argKeys.length) {\n      emitWarning(\n        'Options found in arguments (' + optionKeysInArgs.join(', ') + '). Did you mean to pass an options ' +\n        'object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.'\n      );\n    }\n\n    return {};\n  }",
  "function processLibPhoneNumberMetadata( libPhoneNumberData ) {\n\tconst data = {};\n\tfor ( let countryCode in libPhoneNumberData ) {\n\t\tif ( libPhoneNumberData.hasOwnProperty( countryCode ) ) {\n\t\t\tconst countryCodeUpper = countryCode.toUpperCase();\n\t\t\tconst country = libPhoneNumberData[ countryCode ];\n\t\t\tdata[ countryCodeUpper ] = {\n\t\t\t\tisoCode: countryCodeUpper,\n\t\t\t\tdialCode: String(\n\t\t\t\t\tcountry[ libPhoneNumberIndexes.COUNTRY_DIAL_CODE ] +\n\t\t\t\t\t\t( country[ libPhoneNumberIndexes.REGION_AREA_CODE ] || '' )\n\t\t\t\t),\n\t\t\t\tcountryDialCode: String( country[ libPhoneNumberIndexes.COUNTRY_DIAL_CODE ] ),\n\t\t\t\tregionCode: country[ libPhoneNumberIndexes.REGION_AREA_CODE ] || '',\n\t\t\t\tareaCodes: areaCodes[ countryCode ],\n\t\t\t\tnationalPrefix: country[ libPhoneNumberIndexes.NATIONAL_PREFIX ],\n\t\t\t\tpatterns: ( country[ libPhoneNumberIndexes.NUMBER_FORMAT ] || [] ).map(\n\t\t\t\t\tprocessNumberFormat\n\t\t\t\t),\n\t\t\t\tinternationalPatterns: (\n\t\t\t\t\tcountry[ libPhoneNumberIndexes.INTERNATIONAL_NUMBER_FORMAT ] || []\n\t\t\t\t).map( processNumberFormat ),\n\t\t\t\tpriority: priorityData[ countryCodeUpper ],\n\t\t\t};\n\t\t}\n\t}\n\n\tconst noPattern = _.filter( data, _.conforms( { patterns: patterns => patterns.length === 0 } ) );\n\t_.forIn( noPattern, function( country ) {\n\t\tcountry.patternRegion = (\n\t\t\t_.maxBy( _.values( _.filter( data, { dialCode: country.dialCode } ) ), 'priority' ) || {}\n\t\t).isoCode;\n\t\tconsole.log(\n\t\t\t'Info: ' +\n\t\t\t\tcountry.isoCode +\n\t\t\t\t\" didn't have a pattern\" +\n\t\t\t\t( country.patternRegion ? ' so we use ' + country.patternRegion : '.' )\n\t\t);\n\t} );\n\treturn data;\n}",
  "function bind(func, thisArg) {\n        var curryArgs = Array.prototype.slice.call(arguments, 2);\n        return function() {\n            var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));\n            return func.apply(thisArg, args);\n        };\n    }",
  "function _setCopy(sourceRef, copyRef, rc) {\r\n    return _instanceCopy(sourceRef, copyRef, rc, (set, val) => {\r\n        set.add(_clone(val, rc));\r\n    });\r\n}",
  "function (program, callback) {\n    var cozyLight = require('./cozy-light');\n\n    applicationHelpers.resetDefaultPort();\n    cozyLight.setStarted();\n\n    // start app\n    var app = express();\n    var morgand = morgan('combined');\n    if (expressLog) {\n      app.use(morgand);\n    }\n\n    pluginHelpers.startAll(program, app, function(){\n      mainAppHelper.start(app);\n      applicationHelpers.startAll(function() {\n\n        // always connect it after the proxy\n        // https://github.com/nodejitsu/node-http-proxy/issues/180\n        var jsonParser = bodyParser.json();\n        var urlencodedParser = bodyParser.urlencoded({extended: false});\n        app.use(urlencodedParser);\n        app.use(jsonParser);\n        nodeHelpers.invoke(callback, null, app, server);\n      });\n    });\n  }",
  "function urlSafeBase64DecodeString( str ) {\n\tconst decodeMap = {\n\t\t'-': '+',\n\t\t_: '/',\n\t\t'.': '=',\n\t};\n\n\treturn atob( str.replace( /[-_.]/g, ch => decodeMap[ ch ] ) );\n}",
  "function notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {\n  var watchingArraySubscription = null;\n  ko.computed(function() {\n    // Unsubscribe to any earlier array instance\n    if (watchingArraySubscription) {\n      watchingArraySubscription.dispose();\n      watchingArraySubscription = null;\n    }\n\n    // Subscribe to the new array instance\n    var newarray = observable();\n    if (newarray instanceof Array) {\n      watchingArraySubscription = startWatchingarray(ko, observable, newarray);\n    }\n  });\n}",
  "function (options) {\n\tthis.astStack = new ASTStack();\n\tthis.tags = options.customTags;\n\tthis.raw = '';\n\tthis.disableParseTag = false;\n\tthis.line = 1;\n\tthis.lineStart = 0;\n\tthis.position = 0;\n\tthis.parseTagStack = [];\n\tthis.forItems = [];\n\tthis.tablerowItems = [];\n\tthis.forItems.test = this.tablerowItems.test = function (name) {\n\t\tvar name = name.split('.')[0];\n\t\treturn this.indexOf(name) === -1 ? false : true;\n\t};\n}",
  "function(toolKey){\n\t\t\tdelete taTools[toolKey];\n\t\t\tangular.forEach(toolbars, function(toolbarScope){\n\t\t\t\tdelete toolbarScope.tools[toolKey];\n\t\t\t\tfor(var i = 0; i < toolbarScope.toolbar.length; i++){\n\t\t\t\t\tvar toolbarIndex;\n\t\t\t\t\tfor(var j = 0; j < toolbarScope.toolbar[i].length; j++){\n\t\t\t\t\t\tif(toolbarScope.toolbar[i][j] === toolKey){\n\t\t\t\t\t\t\ttoolbarIndex = {\n\t\t\t\t\t\t\t\tgroup: i,\n\t\t\t\t\t\t\t\tindex: j\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(toolbarIndex !== undefined) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(toolbarIndex !== undefined){\n\t\t\t\t\t\ttoolbarScope.toolbar[toolbarIndex.group].slice(toolbarIndex.index, 1);\n\t\t\t\t\t\ttoolbarScope._$element.children().eq(toolbarIndex.group).children().eq(toolbarIndex.index).remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}",
  "function formatSize(sizeBytes) {\n    if (sizeBytes < 1024) {\n        return sizeBytes + ' B';\n    }\n    var i, sizeVal = sizeBytes, precision = 1;\n    for (i = 0; sizeVal >= 1024; i += 1) {\n        sizeVal /= 1024;\n    }\n    // If we are just reporting a low number, no need for decimal places.\n    if (sizeVal < 10) {\n        precision = 3;\n    } else if (sizeVal < 100) {\n        precision = 2;\n    }\n    return sizeVal.toFixed(precision) + ' ' +\n        ['B', 'kB', 'MB', 'GB', 'TB'][Math.min(i, 4)];\n}",
  "async function() {\n      let {applications} = await this.getProjectData();\n      if (applications instanceof Array && applications.length) {\n        return path.resolve(process.cwd(), applications[0].path);\n      }\n      throw new qx.tool.cli.Utils.UserError(\"Cannot find application path - are you in the right directory?\");\n    }",
  "function (style) {\n        var rxRgb = /rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\n        var rxRgba = /rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d.]+)\\s*\\)/;\n        var rxTransparent = /transparent|rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*0+\\s*\\)/;\n\n        var r, g, b, a;\n\n        if (style.isCanvasGradient === true) {\n            style = style.getColor();\n        }\n\n        if (!style) {\n            return { r: 0, g: 0, b: 0, a: 0, style: style };\n        }\n\n        if (rxTransparent.test(style)) {\n            r = 0;\n            g = 0;\n            b = 0;\n            a = 0;\n        } else {\n            var matches = rxRgb.exec(style);\n            if (matches !== null) {\n                r = parseInt(matches[1]);\n                g = parseInt(matches[2]);\n                b = parseInt(matches[3]);\n                a = 1;\n            } else {\n                matches = rxRgba.exec(style);\n                if (matches !== null) {\n                    r = parseInt(matches[1]);\n                    g = parseInt(matches[2]);\n                    b = parseInt(matches[3]);\n                    a = parseFloat(matches[4]);\n                } else {\n                    a = 1;\n\n                    if (typeof style === \"string\" && style.charAt(0) !== '#') {\n                        var rgbColor = new RGBColor(style);\n                        if (rgbColor.ok) {\n                            style = rgbColor.toHex();\n                        } else {\n                            style = '#000000';\n                        }\n                    }\n\n                    if (style.length === 4) {\n                        r = style.substring(1, 2);\n                        r += r;\n                        g = style.substring(2, 3);\n                        g += g;\n                        b = style.substring(3, 4);\n                        b += b;\n                    } else {\n                        r = style.substring(1, 3);\n                        g = style.substring(3, 5);\n                        b = style.substring(5, 7);\n                    }\n                    r = parseInt(r, 16);\n                    g = parseInt(g, 16);\n                    b = parseInt(b, 16);\n                }\n            }\n        }\n        return { r: r, g: g, b: b, a: a, style: style };\n    }",
  "function() {\n        Ext.suspendLayouts();\n\n        var me     = this,\n            fields = me.getFields().items,\n            f,\n            fLen   = fields.length;\n\n        for (f = 0; f < fLen; f++) {\n            fields[f].clearInvalid();\n        }\n\n        Ext.resumeLayouts(true);\n        return me;\n    }",
  "function(path, options) {\n\n        var cell = this.options.cellView.model;\n\n        var value = joint.util.getByPath(cell.attributes, path, '/');\n        if (_.isUndefined(value) && !_.isUndefined(options.defaultValue)) {\n            value = options.defaultValue;\n        }\n\n        if (options.valueRegExp) {\n\n            if (_.isUndefined(value)) {\n                \n                throw new Error('Inspector: defaultValue must be present when valueRegExp is used.');\n            }\n            \n            var valueMatch = value.match(new RegExp(options.valueRegExp));\n            value = valueMatch && valueMatch[2];\n        }\n\n        return value;\n    }",
  "function file_path () {\n      pending++\n      for (var i = globs.length; i--;) {\n        const glob = globs[i]\n        const glob_full = glob.glob\n        const glob_base = glob.base\n        const glob_negated = glob.negated\n        const glob_pattern = glob.pattern\n        if (entry === glob_full || mm.isMatch(entry, glob_pattern, ALLOW)) {\n          return done(null, file)\n        }\n      }\n\n      // Did not match globs\n      pending--\n      done(null, null)\n    }",
  "function(attrs, value, opt) {\n\n        var currentAttrs = this.get('attrs');\n        var delim = '/';\n        \n        if (_.isString(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (value) {\n\n                var attr = {};\n                joint.util.setByPath(attr, attrs, value, delim);\n                return this.set('attrs', _.merge({}, currentAttrs, attr), opt);\n                \n            } else {\n                \n                return joint.util.getByPath(currentAttrs, attrs, delim);\n            }\n        }\n        \n        return this.set('attrs', _.merge({}, currentAttrs, attrs), value);\n    }",
  "function isAccessorDescriptor(desc) {\n  return !!desc && (isFunction(desc.get) || isFunction(desc.set)) && isBoolean(desc.configurable) && isBoolean(desc.enumerable) && desc.writable === undefined;\n}",
  "function(index, keys, objects) {\n        var me = this,\n            itemKey,\n            removeIndex,\n            i, len = keys.length,\n            fireAdd = me.hasListeners.add,\n            syncIndices;\n\n        // External key(s) passed. We cannot reliably find an object's index using the key extraction fn.\n        // Set a flag for use by contains, indexOf and remove\n        if (objects != null) {\n            me.useLinearSearch = true\n        }\n        // No external keys: calculate keys array if not passed\n        else {\n            objects = keys;\n            keys = new Array(len);\n            for (i = 0; i < len; i++) {\n                keys[i] = this.getKey(objects[i]);\n            }\n        }\n\n        // First, remove duplicates of the keys. If a removal point is less than insertion index, decr insertion index\n        me.suspendEvents();\n        for (i = 0; i < len; i++) {\n            // Must use indexOf - map might be out of sync\n            removeIndex = me.indexOfKey(keys[i]);\n            if (removeIndex !== -1) {\n                if (removeIndex < index) {\n                    index--;\n                }\n                me.removeAt(removeIndex);\n            }\n        }\n        me.resumeEvents();\n\n        // If we are appending and the indices are in sync, its cheap to kep them that way\n        syncIndices = index === me.length && me.indexGeneration === me.generation;\n\n        // Insert the new items and new keys in at the insertion point\n        Ext.Array.insert(me.items, index, objects);\n        Ext.Array.insert(me.keys,  index, keys);\n        me.length += len;\n        me.generation++;\n        if (syncIndices) {\n            me.indexGeneration = me.generation;\n        }\n        for (i = 0; i < len; i++, index++) {\n            itemKey = keys[i];\n            if (itemKey != null) {\n                me.map[itemKey] = objects[i];\n\n                // If the index is still in sync, keep it that way\n                if (syncIndices) {\n                    me.indexMap[itemKey] = index;\n                }\n            }\n            if (fireAdd) {\n                me.fireEvent('add', index, objects[i], itemKey);\n            }\n        }\n        return objects;\n    }",
  "function(input, it) {\n      var output = input;\n      var expr;\n      while((expr = this.getExpr(output)) !== null) {\n        var evalsTo = $parse(expr.expr)({it: it});\n        output = output.substring(0, expr.start) + evalsTo + output.substring(expr.stop + 1);\n      }\n      return output;\n    }",
  "function(command) {\n\n\t// Backbone.model set() and Backbone.collection add() allow to pass an option parameter.\n\t// That is also kept within the command. It skips validation if requested.\n\tif (command.options && command.options.validation === false) return true;\n\n\tvar handoverErr;\n\n\t_.each(this._map[command.action], function(route) {\n\n\t    var i = 0;\n\n\t    function callbacks(err) {\n\n\t\tvar fn = route[i++];\n\n\t\ttry {\n\t\t    if (fn) {\n\t\t\tfn(err, command, callbacks);\n\t\t    } else {\n\t\t\thandoverErr = err;\n\t\t\treturn;\n\t\t    }\n\t\t} catch (err) {\n\t\t    callbacks(err);\n\t\t}\n\t    };\n\n\t    callbacks(handoverErr);\n\t});\n\n\tif (handoverErr) {\n\n\t    if (this.get('cancelInvalid')) this._commandManager.cancel();\n\t    this.trigger('invalid', handoverErr);\n\t    return false;\n\t}\n\n\t//command is valid\n\treturn true;\n    }",
  "function resolveTreeGreedy (module, opts, cb) {\n    if(!cb) cb = opts, opts = null\n\n    opts = opts || {}\n    opts.filter = function (pkg, root) {\n      if(!pkg) return\n      if(!root.tree[pkg.name]) {\n        root.tree[pkg.name] = pkg\n        pkg.parent = root\n      }\n      else {\n        pkg.parent.tree[pkg.name] = pkg\n      }\n      return pkg\n    }\n\n    resolveTree(module, opts, cb)\n  }",
  "function round(val) {\n    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (!isNumber(val) || isNumericalNaN(val)) {\n        throw new TypeError('Value should be numeric');\n    }\n\n    if (precision === !1 || precision < 1) {\n        return Math.round(val);\n    }\n\n    var exp = Math.pow(10, Math.round(precision));\n    return Math.round(val * exp) / exp;\n}",
  "function () {\n    var url = 'https://api.dropboxapi.com/2/users/get_current_account';\n\n    return this._request('POST', url, {}).then(function (response) {\n      var info = response.responseText;\n\n      try {\n        info = JSON.parse(info);\n      } catch (e) {\n        return Promise.reject(new Error('Could not query current account info: Invalid API response: ' + info));\n      }\n\n      return Promise.resolve({\n        email: info.email\n      });\n    });\n  }",
  "function runSession(evaluator, config) {\n  _session.signer = signers.create(config.signature_scheme, config.key);\n  _session.io = createSocket('pub', config.ip, config.iopub_port);\n  _session.shell = createSocket('xrep', config.ip, config.shell_port, messageHandler);\n  _session.control = createSocket('xrep', config.ip, config.control_port, messageHandler);\n\n  _session.evaluator = evaluator;\n  _session.handlers = handlers.create(_session);\n\n  createSocket('rep', config.ip, config.hb_port, heartbeatHandler);\n}",
  "function(obj) {\n        var i = 0,\n            items = this.items,\n            surface = this.getSurface(),\n            len = this.length;\n        \n        if (surface) {\n            for (; i < len; i++) {\n                surface.addCls(items[i], obj);\n            }\n        }\n    }",
  "function deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}",
  "function addClass(element, value) {\n  if (!value) {\n    return;\n  }\n\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      addClass(elem, value);\n    });\n    return;\n  }\n\n  if (element.classList) {\n    element.classList.add(value);\n    return;\n  }\n\n  var className = element.className.trim();\n\n  if (!className) {\n    element.className = value;\n  } else if (className.indexOf(value) < 0) {\n    element.className = \"\".concat(className, \" \").concat(value);\n  }\n}",
  "function sendMessage( args ){\n    last = new Date();\n    fs.write( tmpfile, JSON.stringify( args ) + '\\n', 'a' );\n    // Exit when all done.\n    if( /^done/.test( args[0] ) ){\n        phantom.exit();\n    }\n}",
  "function render(activities, highlight) {\n    // Top verbs plus 'other'.\n    var verbs = topVerbs(activities);\n\n    var selection = d3.select(selector)\n      .selectAll(\"li\")\n      .data(filterVerbs(activities), function(activity) { return activity.id });\n    var li = selection.enter().append(\"li\");\n\n    li.html(function(activity) {\n        return activity.html.replace(/(<time.*>).*(<\\/time>)/, function(_, head, tail) {\n          var date = Date.create(activity.published)\n            .format(\"{Weekday}, {Mon} {d} {h}:{mm} {TT}\");\n          return head + date + tail;\n        })\n      });\n    li.selectAll(\"div\")\n      .append(\"span\").attr(\"class\", \"color\");\n    if (highlight)\n      li.attr(\"class\", \"highlight\").transition()\n        .delay(1).attr(\"class\", \"\");\n    selection.exit().remove();\n    // Set the color of each activity based on its verb.\n    selection.select(\".color\")\n      .style(\"background-color\", function(d) { return verbColor(verbs, d.verb); })\n    selection.order();\n\n    renderVerbs(verbs);\n  }",
  "function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes\n      .reduce(function(extractedAttributes, attributeObject) {\n        extractedAttributes.push(\n          attributeObject.prop + ':' + attributeObject.value\n        );\n        return extractedAttributes;\n      }, [])\n      .join(';');\n  }",
  "function hashish() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.floor(Math.random() * 100);\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 36;\n\n  return _createHash(id, _createSalts(n, base), base);\n}",
  "function(ctl) {\n    var len = ctl.items && ctl.items.length;\n    return utils.sha256(ctl.id + ':' + len).substring(0, 8);\n  }",
  "function define(type, Model) {\n  if (arguments.length === 1) {\n    Model = type;\n    type = Model.prototype.__type || Model.modelName;\n  }\n\n  var factory = new Factory(Model);\n  factories.set(type, factory)\n\n  return factory;\n}",
  "function($scope, element, attrs) {\n        var src = attrs.ngMessagesInclude || attrs.src;\n        $templateRequest(src).then(function(html) {\n          if ($scope.$$destroyed) return;\n\n          if (isString(html) && !html.trim()) {\n            // Empty template - nothing to compile\n            replaceElementWithMarker(element, src);\n          } else {\n            // Non-empty template - compile and link\n            $compile(html)($scope, function(contents) {\n              element.after(contents);\n              replaceElementWithMarker(element, src);\n            });\n          }\n        });\n      }",
  "function(view, initial){\n        var me = this,\n            checkbox = me.injectCheckbox,\n            headerCt = view.headerCt;\n\n        // Preserve behaviour of false, but not clear why that would ever be done.\n        if (checkbox !== false) {\n            if (checkbox == 'first') {\n                checkbox = 0;\n            } else if (checkbox == 'last') {\n                checkbox = headerCt.getColumnCount();\n            }\n            Ext.suspendLayouts();\n            if (view.getStore().buffered) {\n                me.showHeaderCheckbox = false;\n            }\n            headerCt.add(checkbox,  me.getHeaderConfig());\n            Ext.resumeLayouts();\n        }\n\n        if (initial !== true) {\n            view.refresh();\n        }\n    }",
  "function setCursorPositionToOriginalLi(li) {\n\t\t\t\tvar list = ed.dom.getParent(li, 'ol,ul');\n\t\t\t\tif (list != null) {\n\t\t\t\t\tvar lastLi = list.lastChild;\n\t\t\t\t\t// Removed this line since IE9 would report an DOM character error and placing the caret inside an empty LI is handled and should be handled by the selection logic\n\t\t\t\t\t//lastLi.appendChild(ed.getDoc().createElement(''));\n\t\t\t\t\ted.selection.setCursorLocation(lastLi, 0);\n\t\t\t\t}\n\t\t\t}",
  "function isInViewportRange( elementStart, elementEnd ) {\n\tlet viewportStart = window.scrollY,\n\t\tviewportEnd = document.documentElement.clientHeight + window.scrollY;\n\treturn elementStart > viewportStart && elementEnd < viewportEnd;\n}",
  "function inputHandler(manager, eventType, input) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\n        input.isFirst = !!isFirst;\n        input.isFinal = !!isFinal;\n\n        if (isFirst) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData(manager, input);\n\n        // emit secret event\n        manager.emit('hammer.input', input);\n\n        manager.recognize(input);\n        manager.session.prevInput = input;\n    }",
  "function eatBraces(stream, root) {\n\tif (stream.eat(LBRACE)) {\n\t\tlet stack = 1, token;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (stream.eat(RBRACE)) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (stream.eat(LBRACE)) {\n\t\t\t\tstack++;\n\t\t\t} else if (eatUrl(stream) || eatString(stream)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (token = comment(stream)) {\n\t\t\t\troot.addComment(token);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
  "function getSession (profileId) {\n  return fetch(`${SESSION_API}/session/minecraft/profile/${profileId}`, {\n    headers: {\n      'user-agent': USER_AGENT,\n      'accept': 'application/json'\n    }\n  })\n    .then(handleErrors)\n    .then(res => {\n      if (res.status === 204) throw new Error('no such profile')\n      return res.json()\n    })\n    .then(({id, name, properties}) => {\n      const {timestamp, textures} = JSON.parse(Base64.decode(properties[0].value))\n      const {SKIN, CAPE} = textures\n      return {\n        id,\n        name,\n        timestamp,\n        skin: SKIN && SKIN.url,\n        cape: CAPE && CAPE.url,\n        isSlim: SKIN && SKIN.metadata && SKIN.metadata.model === 'slim'\n      }\n    })\n}",
  "function initialize(component) {\n  if (typeof component.update !== 'function') {\n    throw new Error('Etch components must implement `update(props, children)`.')\n  }\n\n  let virtualNode = component.render()\n  if (!isValidVirtualNode(virtualNode)) {\n    let namePart = component.constructor && component.constructor.name ? ' in ' + component.constructor.name : ''\n    throw new Error('invalid falsy value ' + virtualNode + ' returned from render()' + namePart)\n  }\n\n  applyContext(component, virtualNode)\n\n  component.refs = {}\n  component.virtualNode = virtualNode\n  component.element = render(component.virtualNode, {\n    refs: component.refs, listenerContext: component\n  })\n}",
  "function parseUncssrc(filename) {\n    let options = JSON.parse(fs.readFileSync(filename, 'utf-8'));\n\n    /* RegExps can't be stored as JSON, therefore we need to parse them manually.\n     * A string is a RegExp if it starts with '/', since that wouldn't be a valid CSS selector.\n     */\n    options.ignore = options.ignore ? options.ignore.map(strToRegExp) : undefined;\n    options.ignoreSheets = options.ignoreSheets ? options.ignoreSheets.map(strToRegExp) : undefined;\n\n    return options;\n}",
  "function (mod) {\n\t\tself.res = getProcessed( self.processing, mod, self.raw.settings );\n\t\tself.resolved = true;\n\t\tcallback();\n\t}",
  "function isDefaultOrNullQueryValue( value, key ) {\n\treturn value === undefined || value === null || DEFAULT_THEME_QUERY[ key ] === value;\n}",
  "function insertNode(parent, index, newNode, replace) {\n  if (!parent.childNodes) {\n    parent.childNodes = [];\n  }\n  var newNodes = [];\n  var removedNode = replace ? parent.childNodes[index] : null;\n  if (newNode) {\n    if (isDocumentFragment(newNode)) {\n      if (newNode.childNodes) {\n        newNodes = Array.from(newNode.childNodes);\n        newNode.childNodes.length = 0;\n      }\n    } else {\n      newNodes = [newNode];\n      remove(newNode);\n    }\n  }\n  if (replace) {\n    removedNode = parent.childNodes[index];\n  }\n  Array.prototype.splice.apply(parent.childNodes, [index, replace ? 1 : 0].concat(newNodes));\n  newNodes.forEach(function(n) {\n    n.parentNode = parent;\n  });\n  if (removedNode) {\n    removedNode.parentNode = undefined;\n  }\n}",
  "function loadSuites(files) {\n    files.forEach(function (file) {\n        if (/\\.js(\\?.*)?$/.test(file)) {\n            jsSuites$1.push(file);\n        }\n        else if (/\\.html(\\?.*)?$/.test(file)) {\n            htmlSuites$1.push(file);\n        }\n        else {\n            throw new Error('Unknown resource type: ' + file);\n        }\n    });\n}",
  "async function getFiles(paths, options) {\n\tconst files = (await getVinylFiles(paths, options))\n\t\t.map(file=>[file, ...getRequires(file, options)]);\n\treturn (await promiseFlatten(files)).filter(file=>file).filter(filterDuplicateFiles());\n}",
  "function initMatic() {\n  if (!matic) {\n    matic = new Matic({\n      maticProvider: process.env.MATIC_PROVIDER,\n      parentProvider: process.env.PARENT_PROVIDER,\n      rootChainAddress: process.env.ROOTCHAIN_ADDRESS,\n      maticWethAddress: process.env.MATIC_WETH_ADDRESS,\n      syncerUrl: process.env.SYNCER_URL,\n      watcherUrl: process.env.WATCHER_URL,\n      withdrawManagerAddress: process.env.WITHDRAWMANAGER_ADDRESS,\t\n    })\n\n    matic.wallet = '<private-key>' // your private key\n  }\n}",
  "function removeLibraryFromPrototypes () {\n            Object.defineProperty(Object.prototype, handle, { value: undefined });\n            delete Object.prototype[handle];\n            attached = false;\n            return self;\n        }",
  "function parse_status_block(block) {\n  var match;\n\n  var parsed = {\n    interface: block.match(/^([^\\s]+)/)[1]\n  };\n\n  if ((match = block.match(/Link encap:\\s*([^\\s]+)/))) {\n    parsed.link = match[1].toLowerCase();\n  }\n\n  if ((match = block.match(/HWaddr\\s+([^\\s]+)/))) {\n    parsed.address = match[1].toLowerCase();\n  }\n\n  if ((match = block.match(/inet6\\s+addr:\\s*([^\\s]+)/))) {\n    parsed.ipv6_address = match[1];\n  }\n\n  if ((match = block.match(/inet\\s+addr:\\s*([^\\s]+)/))) {\n    parsed.ipv4_address = match[1];\n  }\n\n  if ((match = block.match(/Bcast:\\s*([^\\s]+)/))) {\n    parsed.ipv4_broadcast = match[1];\n  }\n\n  if ((match = block.match(/Mask:\\s*([^\\s]+)/))) {\n    parsed.ipv4_subnet_mask = match[1];\n  }\n\n  if ((match = block.match(/UP/))) {\n    parsed.up = true;\n  }\n\n  if ((match = block.match(/BROADCAST/))) {\n    parsed.broadcast = true;\n  }\n\n  if ((match = block.match(/RUNNING/))) {\n    parsed.running = true;\n  }\n\n  if ((match = block.match(/MULTICAST/))) {\n    parsed.multicast = true;\n  }\n\n  if ((match = block.match(/LOOPBACK/))) {\n    parsed.loopback = true;\n  }\n\n  return parsed;\n}",
  "function _setParticle(position, velocity, phase) {\n        if (position !== undefined) {\n            //var oldPosition = this._scroll.particle.getPosition1D();\n            this._scroll.particleValue = position;\n            this._scroll.particle.setPosition1D(position);\n            //_log.call(this, 'setParticle.position: ', position, ' (old: ', oldPosition, ', delta: ', position - oldPosition, ', phase: ', phase, ')');\n            if (this._scroll.springValue !== undefined) {\n                this._scroll.pe.wake();\n            }\n        }\n        if (velocity !== undefined) {\n            var oldVelocity = this._scroll.particle.getVelocity1D();\n            if (oldVelocity !== velocity) {\n                this._scroll.particle.setVelocity1D(velocity);\n                //_log.call(this, 'setParticle.velocity: ', velocity, ' (old: ', oldVelocity, ', delta: ', velocity - oldVelocity, ', phase: ', phase, ')');\n            }\n        }\n    }",
  "function onWindowKeyPressed(event) {\n      ctrlDown = event.ctrlKey;\n      if (!ctrlDown) {\n        drag.start.x = null;\n        drag.start.y = null;\n      }\n    }",
  "function cleanCallback(errorCallback, callback){\n  var self = this || {};\n  if(!callback){\n    return function(err){ // remove other variables\n      if(err && self.log){\n        self.log('error',err);\n      }\n      errorCallback(err);\n    }\n  }\n  \n  return function(err){\n    if(err){\n      if(self.log){\n        self.log('error',err);\n      }\n      errorCallback(err);\n      return;\n    }\n    callback.apply(callback, Array.prototype.slice.call(arguments,1));\n  }\n}",
  "function checkResults (cb) {\n  // fetch the new account from the trie.\n  stateTrie.get(createdAddress, function (err, val) {\n    var account = new Account(val)\n\n    storageRoot = account.stateRoot // used later! :)\n    console.log('------results------')\n    console.log('nonce: ' + account.nonce.toString('hex'))\n    console.log('balance in wei: ' + account.balance.toString('hex'))\n    console.log('stateRoot: ' + storageRoot.toString('hex'))\n    console.log('codeHash:' + account.codeHash.toString('hex'))\n    console.log('-------------------')\n    cb(err)\n  })\n}",
  "function (iterator, context) {\n    var list = new ArrayList;\n    return list.add(_.map(this, iterator, context));\n  }",
  "function Keycloak (config, keycloakConfig) {\n  // If keycloakConfig is null, Config() will search for `keycloak.json`.\n  this.config = new Config(keycloakConfig);\n\n  this.grantManager = new GrantManager(this.config);\n\n  this.stores = [ BearerStore ];\n\n  if (!config) {\n    throw new Error('Adapter configuration must be provided.');\n  }\n\n  // Add the custom scope value\n  this.config.scope = config.scope;\n\n  if (config && config.store && config.cookies) {\n    throw new Error('Either `store` or `cookies` may be set, but not both');\n  }\n\n  if (config && config.store) {\n    this.stores.push(new SessionStore(config.store));\n  } else if (config && config.cookies) {\n    this.stores.push(CookieStore);\n  }\n\n  this.config.idpHint = config.idpHint;\n}",
  "function(config) {\n        var me = this,\n            comp;\n\n        if (arguments.length === 2) {\n            //<debug>\n            if (Ext.isDefined(Ext.global.console)) {\n                Ext.global.console.warn('Ext.LoadMask: LoadMask now uses a standard 1 arg constructor: use the target config');\n            }\n            //</debug>\n            comp = config;\n            config = arguments[1];\n        } else {\n            comp = config.target;\n        }\n\n        // Element support to be deprecated\n        if (!comp.isComponent) {\n            //<debug>\n            if (Ext.isDefined(Ext.global.console)) {\n                Ext.global.console.warn('Ext.LoadMask: LoadMask for elements has been deprecated, use Ext.dom.Element.mask & Ext.dom.Element.unmask');\n            }\n            //</debug>\n            comp = Ext.get(comp);\n            this.isElement = true;\n        }\n\n        me.ownerCt = comp;\n        if (!this.isElement) {\n            me.bindComponent(comp);\n        }\n        me.callParent([config]);\n\n        if (me.store) {\n            me.bindStore(me.store, true);\n        }\n    }",
  "function clone(o){\n  var c = {};\n  var h = Object.keys(o);\n  for(var i = 0, co = h.length; i < co; i++){\n    c[h[i]] = o[h[i]];\n  }\n  return c;\n}",
  "function(name, obj) {\n  obj._namespace = name;\n  observers = observers.concat(obj._observers);\n  obj._emitter = caramel;\n}",
  "function Popper(reference, popper) {\n      var _this = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      classCallCheck(this, Popper);\n\n      this.scheduleUpdate = function () {\n        return requestAnimationFrame(_this.update);\n      }; // make update() debounced, so that it only runs at most once-per-tick\n\n\n      this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it\n\n      this.options = _extends({}, Popper.Defaults, options); // init state\n\n      this.state = {\n        isDestroyed: false,\n        isCreated: false,\n        scrollParents: []\n      }; // get reference and popper elements (allow jQuery wrappers)\n\n      this.reference = reference && reference.jquery ? reference[0] : reference;\n      this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options\n\n      this.options.modifiers = {};\n      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n      }); // Refactoring modifiers' list (Object => Array)\n\n      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n        return _extends({\n          name: name\n        }, _this.options.modifiers[name]);\n      }) // sort the modifiers by order\n      .sort(function (a, b) {\n        return a.order - b.order;\n      }); // modifiers have the ability to execute arbitrary code when Popper.js get inited\n      // such code is executed in the same order of its modifier\n      // they could add new properties to their options configuration\n      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n\n      this.modifiers.forEach(function (modifierOptions) {\n        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n        }\n      }); // fire the first update to position the popper in the right place\n\n      this.update();\n      var eventsEnabled = this.options.eventsEnabled;\n\n      if (eventsEnabled) {\n        // setup event listeners, they will take care of update the position in specific situations\n        this.enableEventListeners();\n      }\n\n      this.state.eventsEnabled = eventsEnabled;\n    }",
  "function DimCommand(args) {\n    var parsed = new statements.ArgumentStatement(args, {\n        parseArgs: false\n    });\n\n    this.creates = [];\n\n    for (var i = 0; i < parsed.args.length; i++) {\n        var dimDef = parsed.args[i];\n        var startBracket = dimDef.indexOf('(');\n        var endBracket = dimDef.indexOf(')');\n\n        if (startBracket === -1) throw new SyntaxError('Expected start bracket');\n        if (endBracket === -1) throw new SyntaxError('Expected end bracket');\n\n        var arrayName = dimDef.substring(0, startBracket).trim();\n        var arrayLengthName = dimDef.substring(startBracket + 1, endBracket);\n        var arrayLengthArg = new statements.ArgumentStatement(arrayLengthName);\n\n        this.creates.push({\n            name: arrayName,\n            lengths: arrayLengthArg.args\n        })\n    }\n}",
  "function _recordKey(key) {\n        var i;\n\n        // one-off implementation of Array.indexOf, since IE6-9 don't support it\n        for (i = 0; i < _currentRecordedKeys.length; ++i) {\n            if (_currentRecordedKeys[i] === key) {\n                return;\n            }\n        }\n\n        _currentRecordedKeys.push(key);\n\n        if (key.length === 1) {\n            _recordedCharacterKey = true;\n        }\n    }",
  "function updateLocation(method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return {\n      type: _constants.CALL_HISTORY_METHOD,\n      payload: { method: method, args: args }\n    };\n  };\n}",
  "function _getViewSpec(item, view, id, callback) {\n        if (!item.view) {\n            return;\n        }\n        var spec = view.getSpec(id);\n        if (spec && !spec.trueSizeRequested) {\n            callback(spec);\n        }\n        else {\n            Timer.after(_getViewSpec.bind(this, item, view, id, callback), 1);\n        }\n    }",
  "function runStoppableQueue(queue) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  var step = function step(index) {\n    if (index >= queue.length) {\n      return true;\n    }\n    var result = isFunction(queue[index]) ? queue[index].apply(queue, _toConsumableArray(args)) : queue[index];\n    if (result === false) return false;\n    return step(++index);\n  };\n  return step(0);\n}",
  "function insertHandler(string, selectionRange, snippet) {\n  const start = selectionRange[0];\n  const end = selectionRange[1];\n  const value = string.substring(0, start) + snippet + string.substring(end, string.length);\n\n  return { value, range: [start, start + snippet.length] };\n}",
  "function(withoutTransformations, target) {\n\n            // If the element is not in the live DOM, it does not have a bounding box defined and\n            // so fall back to 'zero' dimension element.\n            if (!this.node.ownerSVGElement) return { x: 0, y: 0, width: 0, height: 0 };\n            \n            var box;\n            try {\n\n                box = this.node.getBBox();\n\n\t\t// Opera returns infinite values in some cases.\n\t\t// Note that Infinity | 0 produces 0 as opposed to Infinity || 0.\n\t\t// We also have to create new object as the standard says that you can't\n\t\t// modify the attributes of a bbox.\n\t\tbox = { x: box.x | 0, y: box.y | 0, width: box.width | 0, height: box.height | 0};\n\n            } catch (e) {\n\n                // Fallback for IE.\n                box = {\n                    x: this.node.clientLeft,\n                    y: this.node.clientTop,\n                    width: this.node.clientWidth,\n                    height: this.node.clientHeight\n                };\n            }\n\n            if (withoutTransformations) {\n\n                return box;\n            }\n\n            var matrix = this.node.getTransformToElement(target || this.node.ownerSVGElement);\n            var corners = [];\n            var point = this.node.ownerSVGElement.createSVGPoint();\n\n\n            point.x = box.x;\n            point.y = box.y;\n            corners.push(point.matrixTransform(matrix));\n            \n            point.x = box.x + box.width;\n            point.y = box.y;\n            corners.push(point.matrixTransform(matrix));\n            \n            point.x = box.x + box.width;\n            point.y = box.y + box.height;\n            corners.push(point.matrixTransform(matrix));\n            \n            point.x = box.x;\n            point.y = box.y + box.height;\n            corners.push(point.matrixTransform(matrix));\n\n            var minX = corners[0].x;\n            var maxX = minX;\n            var minY = corners[0].y;\n            var maxY = minY;\n            \n            for (var i = 1, len = corners.length; i < len; i++) {\n                \n                var x = corners[i].x;\n                var y = corners[i].y;\n\n                if (x < minX) {\n                    minX = x;\n                } else if (x > maxX) {\n                    maxX = x;\n                }\n                \n                if (y < minY) {\n                    minY = y;\n                } else if (y > maxY) {\n                    maxY = y;\n                }\n            }\n\n            return {\n                x: minX,\n                y: minY,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        }",
  "function(node) {\n      var old = this.__scope;\n      var scope = this.__scope = this.__scope.parent;\n      var unresolved = scope.unresolved;\n\n      for (var name in old.unresolved) {\n        var entry = unresolved[name];\n        if (!entry) {\n          entry = unresolved[name] = {\n            name: name,\n            locations: []\n          };\n        }\n        entry.locations.push.apply(entry.locations, old.unresolved[name].locations);\n      }\n    }",
  "function _destroyNode(node) {\n\n        // Remove node from linked-list\n        if (node._next) {\n            node._next._prev = node._prev;\n        }\n        if (node._prev) {\n            node._prev._next = node._next;\n        }\n        else {\n            this._first = node._next;\n        }\n\n        // Destroy the node\n        node.destroy();\n\n        // Add node to pool\n        if (this._pool.layoutNodes.size < MAX_POOL_SIZE) {\n            this._pool.layoutNodes.size++;\n            node._prev = undefined;\n            node._next = this._pool.layoutNodes.first;\n            this._pool.layoutNodes.first = node;\n        }\n    }",
  "function bufferContents(file, enc, cb) {\n    // ignore empty files\n    if (file.isNull()) {\n      return cb();\n    }\n\n    // no streams\n    if (file.isStream()) {\n      this.emit('error', new PluginError('gulp-livingcss', 'Streaming not supported'));\n      return cb();\n    }\n\n    files.push(file.path);\n\n    cb();\n  }",
  "function(endType) {\n\n        function watchEnd(link, end) {\n\n            end = end || {};\n\n            var previousEnd = link.previous(endType) || {};\n\n            // Pick updateMethod this._sourceBboxUpdate or this._targetBboxUpdate.\n            var updateEndFunction = this['_' + endType + 'BBoxUpdate'];\n\n            if (this._isModel(previousEnd)) {\n                this.stopListening(this.paper.getModelById(previousEnd.id), 'change', updateEndFunction);\n            }\n\n            if (this._isModel(end)) {\n                // If the observed model changes, it caches a new bbox and do the link update.\n                this.listenTo(this.paper.getModelById(end.id), 'change', updateEndFunction);\n            }\n\n            _.bind(updateEndFunction, this)({ cacheOnly: true });\n\n            return this;\n        }\n\n        return watchEnd;\n    }",
  "function getNumeric () {\n                    var vals = [];\n                    libs.object.every(arguments, function (o) {\n                        vals.push(libs.object.isNumeric(o) ? parseFloat(o) : NaN);\n                    });\n                    return vals.length === 1 ? vals[0] : vals;\n                }",
  "function getAdjustedSizes(_ref4) // or 'cover'\n{\n  var aspectRatio = _ref4.aspectRatio,\n      height = _ref4.height,\n      width = _ref4.width;\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';\n  var isValidWidth = isPositiveNumber(width);\n  var isValidHeight = isPositiveNumber(height);\n\n  if (isValidWidth && isValidHeight) {\n    var adjustedWidth = height * aspectRatio;\n\n    if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n      height = width / aspectRatio;\n    } else {\n      width = height * aspectRatio;\n    }\n  } else if (isValidWidth) {\n    height = width / aspectRatio;\n  } else if (isValidHeight) {\n    width = height * aspectRatio;\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}",
  "function(opts) {\n    this._client = Promise.promisifyAll(redis.createClient(opts));\n    if (opts.db) {\n      this._client.selectAsync(opts.db);\n    }\n    this.redisOpts = opts;\n  }",
  "function initComponentData(instance, options, isPage) {\n    let data = instance.data;\n    if (isFunction(data)) {\n        instance.data = instance.data();\n    }\n\n    instance.$init && instance.$init(isPage, options);\n}",
  "function rateTitleLength( titleLength ) {\n\tvar rating;\n\n\tswitch ( true ) {\n\t\tcase titleLength > 0 && titleLength <= 399:\n\t\tcase titleLength > 600:\n\t\t\trating = \"ok\";\n\t\t\tbreak;\n\n\t\tcase titleLength >= 400 && titleLength <= 600:\n\t\t\trating = \"good\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trating = \"bad\";\n\t\t\tbreak;\n\t}\n\n\treturn rating;\n}",
  "function parse(report) {\n  var sys  = report['system'] || {};\n  var info = report['report'] || {};\n\n  function _i(x) {\n    return info[x] || '';\n  }\n\n  function _s(x) {\n    return sys[x] || '';\n  }\n\n  var error  = report['crash']['error'];\n  var thread = Utils.get_crash_thread(report);\n\n  return [\n    Utils.header('Incident Identifier:', _i('id'), 4),\n    Utils.header('CrashReporter Key:'  , _s('device_app_hash'), 4),\n    Utils.header('Hardware Model:'     , _s('machine'), 4),\n    Utils.header('Process:'            , `${_s('process_name')} [${_s('process_id')}]`),\n    Utils.header('Path:'               , _s('CFBundleExecutablePath')),\n    Utils.header('Identifier:'         , _s('CFBundleIdentifier')),\n    Utils.header('Version:'            , `${_s('CFBundleShortVersionString')} (${_s('CFBundleVersion')})`),\n    Utils.header('Code Type:'          , get_cpu_arch(report)),\n    Utils.header('Parent Process:'     , `${_s('parent_process_name')} [${_s('parent_process_id')}]`),\n    Utils.header(''                    , ''),\n    Utils.header('Date/Time:'          , get_time(report)),\n    Utils.header('OS Version:'         , `${_s('system_name')} ${_s('system_version')} (${_s('os_version')})`),\n    Utils.header('Report Version:'     , 104),\n    Utils.header(''                    , '')\n  ].concat(\n    Errors.parse_errors(error, thread)\n  );\n}",
  "function( i18n, options = {} ) {\n\tAssessor.call( this, i18n, options );\n\tthis.type = \"ContentAssessor\";\n\tconst locale = ( options.hasOwnProperty( \"locale\" ) ) ? options.locale : \"en_US\";\n\n\tthis._assessments = [\n\n\t\tnew FleschReadingEase( contentConfiguration( locale ).fleschReading ),\n\t\tnew SubheadingDistributionTooLong(),\n\t\tparagraphTooLong,\n\t\tnew SentenceLengthInText( contentConfiguration( locale ).sentenceLength ),\n\t\ttransitionWords,\n\t\tpassiveVoice,\n\t\ttextPresence,\n\t\tsentenceBeginnings,\n\t\t// Temporarily disabled: wordComplexity,\n\t];\n}",
  "function Transaction(config) {\n      _classCallCheck(this, Transaction);\n\n      this._web3 = config.parent._web3;\n      this._logger = config.parent._logger;\n      this._hash = config.hash;\n    }",
  "function isIterator(obj) {\n\treturn Boolean(obj && (typeof Symbol === 'function' ? obj[Symbol.iterator] : isFunction(obj['@@iterator'])));\n}",
  "function requestPosts( siteId, query = {} ) {\n\treturn dispatch => {\n\t\tdispatch( {\n\t\t\ttype: POSTS_REQUEST,\n\t\t\tsiteId,\n\t\t\tquery,\n\t\t} );\n\n\t\tconst source = siteId ? wpcom.site( siteId ) : wpcom.me();\n\n\t\treturn source\n\t\t\t.postsList( { ...query } )\n\t\t\t.then( ( { found, posts } ) => {\n\t\t\t\tdispatch( receivePosts( posts ) );\n\t\t\t\tdispatch( {\n\t\t\t\t\ttype: POSTS_REQUEST_SUCCESS,\n\t\t\t\t\tsiteId,\n\t\t\t\t\tquery,\n\t\t\t\t\tfound,\n\t\t\t\t\tposts,\n\t\t\t\t} );\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\tdispatch( {\n\t\t\t\t\ttype: POSTS_REQUEST_FAILURE,\n\t\t\t\t\tsiteId,\n\t\t\t\t\tquery,\n\t\t\t\t\terror,\n\t\t\t\t} );\n\t\t\t} );\n\t};\n}",
  "function(msgId, ...args) {\n      for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        if (typeof arg !== \"string\" && typeof arg !== \"number\" && arg !== null) {\n          args[i] = String(arg); \n        }\n      }\n      if (this.isMachineReadable()) {\n        let str = \"##\" + msgId + \":\" + JSON.stringify(args);\n        console.log(str);\n      } else {\n        var writer = this.getWriter();\n        let str = this.decode(msgId, ...args);\n        if (writer) {\n          writer(str, msgId, ...args); \n        } else {\n          console.log(str); \n        }\n      }\n    }",
  "function(collectionName, criterion, key, parentKey) {\r\n        var queryPart = '';\r\n\r\n\r\n        if (parentKey) {\r\n            return sql.prepareCriterion(collectionName, criterion, key, parentKey);\r\n        }\r\n\r\n        // OR\r\n        if (key.toLowerCase() === 'or') {\r\n            queryPart = sql.build(collectionName, criterion, sql.where, ' OR ');\r\n            return ' ( ' + queryPart + ' ) ';\r\n        }\r\n\r\n        // AND\r\n        else if (key.toLowerCase() === 'and') {\r\n            queryPart = sql.build(collectionName, criterion, sql.where, ' AND ');\r\n            return ' ( ' + queryPart + ' ) ';\r\n        }\r\n\r\n        // IN\r\n        else if (_.isArray(criterion)) {\r\n            queryPart = sql.prepareAttribute(collectionName, null, key) + \" IN (\" + sql.values(collectionName, criterion, key) + \")\";\r\n            return queryPart;\r\n        }\r\n\r\n        // LIKE\r\n        else if (key.toLowerCase() === 'like') {\r\n            return sql.build(collectionName, criterion, function(collectionName, value, attrName) {\r\n                var attrStr = sql.prepareAttribute(collectionName, value, attrName);\r\n\r\n                attrStr = attrStr.replace(/'/g, '\"');\r\n\r\n                // TODO: Handle regexp criterias\r\n                if (_.isRegExp(value)) {\r\n                    throw new Error('RegExp LIKE criterias not supported by the MySQLAdapter yet.  Please contribute @ http://github.com/balderdashy/sails-mysql');\r\n                }\r\n\r\n                var valueStr = sql.prepareValue(collectionName, value, attrName);\r\n\r\n                // Handle escaped percent (%) signs [encoded as %%%]\r\n                valueStr = valueStr.replace(/%%%/g, '\\\\%');\r\n                var condition = (attrStr + \" LIKE \" + valueStr);\r\n\r\n                //condition = condition.replace(/'/g, '\"');\r\n\r\n                return condition;\r\n            }, ' AND ');\r\n        }\r\n\r\n        // NOT\r\n        else if (key.toLowerCase() === 'not') {\r\n            throw new Error('NOT not supported yet!');\r\n        }\r\n\r\n        // Basic criteria item\r\n        else {\r\n            return sql.prepareCriterion(collectionName, criterion, key);\r\n        }\r\n\r\n    }",
  "function getAssetDir() {\r\n\tvar dir = path.dirname(process.argv[1]);\r\n\r\n\tif (isDev()) {\r\n\t\tlet epeiosPath = getEpeiosPath();\r\n\t\treturn path.resolve(epeiosPath, \"tools/xdhq/examples/common/\", path.relative(path.resolve(epeiosPath, \"tools/xdhq/examples/NJS/\"), path.resolve(dir)));\t// No final '/'.\r\n\t} else\r\n\t\treturn path.resolve(dir);\r\n}",
  "function () {\n    this.rs.setBackend('googledrive');\n    this.rs.authorize({ authURL: AUTH_URL, scope: AUTH_SCOPE, clientId: this.clientId });\n  }",
  "function(key) {\n    var pos = key.indexOf('[');\n    if (pos === -1) return { type: 'string', val: key };\n    return { type: 'array', val: key.substr(0, pos) };\n  }",
  "function CommonJSResolverStrategy(config) {\n\tBasicResolverStrategy.call(this, config);\n\tthis.config = extend(true, this.config, {}, config);\n}",
  "function getShortlinker() {\n\tif ( globalScope.yoast.shortlinker === null ) {\n\t\tglobalScope.yoast.shortlinker = new Shortlinker();\n\t}\n\treturn globalScope.yoast.shortlinker;\n}",
  "function(transaction, event) {\n        var success = !!event.status,\n            funcName = success ? 'success' : 'failure',\n            callback, options, result;\n        \n        if (transaction && transaction.callback) {\n            callback = transaction.callback;\n            options  = transaction.callbackOptions;\n            result   = typeof event.result !== 'undefined' ? event.result : event.data;\n\n            if (Ext.isFunction(callback)) {\n                callback(result, event, success, options);\n            }\n            else {\n                Ext.callback(callback[funcName], callback.scope, [result, event, success, options]);\n                Ext.callback(callback.callback,  callback.scope, [result, event, success, options]);\n            }\n        }\n    }",
  "function parseId(url) {\n    if (is.empty(url)) {\n        return null;\n    }\n\n    const regex = /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/;\n    return url.match(regex) ? RegExp.$2 : url;\n}",
  "function shouldPolyfill(importName, name, path) {\n    let result;\n    if (Array.isArray(importName)) {\n        result = importName.some(item => (item === name));\n    }\n    else {\n        result = importName === name;\n    }\n\n    // ignore global variable, e.g., Array/Number/Promise etc.\n    return result && !path.scope.hasBinding(name, true);\n}",
  "function(redraw) {\n        var i = 0,\n            items = this.items,\n            len = this.length;\n            \n        for (; i < len; i++) {\n            items[i].hide(redraw);\n        }\n        return this;\n    }",
  "function () {\n        var renderData = this.callParent();\n\n        if (this.owner.getHierarchyState().rtl) {\n            renderData.innerCtCls =\n                (renderData.innerCtCls || '') + ' ' + Ext.baseCSSPrefix + 'rtl';\n        }\n        \n        return renderData;\n    }",
  "function(e, record) {\n        var me = this,\n            recIdx,\n            fromIdx,\n            isSelected = me.isSelected(record),\n            from = (me.selectionStart && me.isSelected(me.lastFocused)) ? me.selectionStart : (me.selectionStart = me.lastFocused),\n            key = e.getCharCode(),\n            isSpace = key === e.SPACE,\n            direction = key === e.UP || key === e.PAGE_UP ? 'up' : (key === e.DOWN || key === e.DOWN ? 'down' : null);\n\n        switch (me.selectionMode) {\n            case 'MULTI':\n                \n                if (isSpace) {\n                    // SHIFT+SPACE, select range\n                    if (e.shiftKey) {\n                        me.selectRange(from, record, e.ctrlKey);\n                    } else {\n                        // SPACE pessed on a selected item: deselect but leave it focused.\n                        // e.ctrlKey means \"keep existing\"\n                        if (isSelected) {\n                            me.doDeselect(record, e.ctrlKey);\n\n                            // This record is already focused. To get the focus effect put on it (as opposed to selected)\n                            // we have to focus null first.\n                            me.setLastFocused(null);\n                            me.setLastFocused(record);\n                        }\n                        // SPACE on an unselected item: select it\n                        else {\n                            me.doSelect(record, e.ctrlKey);\n                        }\n                    }\n                }\n\n                // SHIFT-navigate selects intervening rows from the last selected (or last focused) item and target item\n                else if (e.shiftKey && from) {\n\n                    // If we are going back *into* the selected range, we deselect.\n                    fromIdx = me.store.indexOf(from);\n                    recIdx = me.store.indexOf(record);\n\n                    // If we are heading back TOWARDS the start rec - deselect skipped range...\n                    if (direction === 'up' && fromIdx <= recIdx) {\n                        me.deselectRange(me.lastFocused, recIdx + 1);\n                    }\n                    else if (direction === 'down' && fromIdx >= recIdx) {\n                        me.deselectRange(me.lastFocused, recIdx - 1);\n                    }\n\n                    // If we are heading AWAY from start point, or no CTRL key, so just select the range and let the CTRL control \"keepExisting\"...\n                    else if (from !== record) {\n                        me.selectRange(from, record, e.ctrlKey);\n                    }\n                    me.lastSelected = record;\n                    me.setLastFocused(record);\n                }\n\n                // CTRL-navigate onto a selected item just focuses it\n                else if (e.ctrlKey && isSelected) {\n                    me.setLastFocused(record);\n                }\n\n                // CTRL-navigate, just move focus\n                else if (e.ctrlKey) {\n                    me.setLastFocused(record);\n                }\n\n                // Just navigation - select the target\n                else {\n                    me.doSelect(record, false);\n                }\n                break;\n            case 'SIMPLE':\n                if (isSelected) {\n                    me.doDeselect(record);\n                } else {\n                    me.doSelect(record, true);\n                }\n                break;\n            case 'SINGLE':\n                // Space hit\n                if (isSpace) {\n                    if (isSelected) {\n                        me.doDeselect(record);\n                        me.setLastFocused(record);\n                    } else {\n                        me.doSelect(record);\n                    }\n                }\n\n                // CTRL-navigation: just move focus\n                else if (e.ctrlKey) {\n                    me.setLastFocused(record);\n                }\n\n                // if allowDeselect is on and this record isSelected, deselect it\n                else if (me.allowDeselect && isSelected) {\n                    me.doDeselect(record);\n                }\n                \n                // select the record and do NOT maintain existing selections\n                else {\n                    me.doSelect(record, false);\n                }\n                break;\n        }\n\n        // selectionStart is a start point for shift/mousedown to create a range from.\n        // If the mousedowned record was not already selected, then it becomes the\n        // start of any range created from now on.\n        // If we drop to no records selected, then there is no range start any more.\n        if (!e.shiftKey) {\n            if (me.isSelected(record)) {\n                me.selectionStart = record;\n            }\n        }\n    }",
  "function disjunctionToList(node) {\n  if (node.type !== 'Disjunction') {\n    throw new TypeError(`Expected \"Disjunction\" node, got \"${node.type}\"`);\n  }\n\n  const list = [];\n\n  if (node.left && node.left.type === 'Disjunction') {\n    list.push(...disjunctionToList(node.left), node.right);\n  } else {\n    list.push(node.left, node.right);\n  }\n\n  return list;\n}",
  "function trsv (A, x, isLower) {\n  var dot = blas1.dot;\n  var n = A.shape[1];\n  var i = 0;\n  if (isLower) {\n    x.set(0, x.get(0) / A.get(0, 0));\n    for (i = 1; i < n; i++) {\n      x.set(i, (x.get(i) - dot(A.pick(i, null).hi(i), x.hi(i))) / A.get(i, i));\n    }\n  } else {\n    x.set(n - 1, x.get(n - 1) / A.get(n - 1, n - 1));\n    for (i = n - 2; i >= 0; i--) {\n      x.set(i, (x.get(i) - dot(A.pick(i, null).lo(i + 1), x.lo(i + 1))) / A.get(i, i));\n    }\n  }\n  return true;\n}",
  "function homedir(username) {\n  return username ? path.resolve(path.dirname(home), username) : home;\n}",
  "function(nameOrNumber) {\n        var name = (typeof nameOrNumber === 'string') ?\n            nameOrNumber :\n            Object.keys(this._assignments)[nameOrNumber];\n        return this._assignments[name];\n    }",
  "function(pos, isAbsolute) {\n\t\t\treturn _.find(this.list(), function(elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t}",
  "function distinctUntilKeyChanged(keySelector) {\r\n    return function* (it) {\r\n        let prev = undefined;\r\n        for (const item of it) {\r\n            const key = keySelector(item);\r\n            if (key === prev) {\r\n                continue;\r\n            }\r\n            prev = key;\r\n            yield item;\r\n        }\r\n    };\r\n}",
  "function () {\n        var me = this,\n            layouts = me.layoutQueue.clear(),\n            length = layouts.length,\n            i;\n\n        ++me.cycleCount;\n\n        // This value is incremented by ContextItem#setProp whenever new values are set\n        // (thereby detecting forward progress):\n        me.progressCount = 0;\n\n        for (i = 0; i < length; ++i) {\n            me.runLayout(me.currentLayout = layouts[i]);\n        }\n\n        me.currentLayout = null;\n\n        return me.progressCount > 0;\n    }",
  "function(abbr, syntax, profile, contextNode) {\n\t\t\tif (!abbr) return '';\n\t\t\t\n\t\t\tsyntax = syntax || defaultSyntax;\n//\t\t\tprofile = profile || defaultProfile;\n\t\t\t\n\t\t\tvar filters = r('filters');\n\t\t\tvar parser = r('abbreviationParser');\n\t\t\t\n\t\t\tprofile = r('profile').get(profile, syntax);\n\t\t\tr('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar outputTree = parser.parse(data[0], {\n\t\t\t\tsyntax: syntax, \n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\t\n\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, profile);\n\t\t\treturn outputTree.toString();\n\t\t}",
  "function processPointerPosition(e) {\n    var prevValue = this.value,\n        sliderNum = void 0;\n\n    if (this.style === 'horizontal') {\n      sliderNum = Math.floor(e.clientY / this.rect.height / (1 / this.count));\n      this.__value[sliderNum] = (e.clientX - this.rect.left) / this.rect.width;\n    } else {\n      sliderNum = Math.floor(e.clientX / this.rect.width / (1 / this.count));\n      this.__value[sliderNum] = 1 - (e.clientY - this.rect.top) / this.rect.height;\n    }\n\n    for (var i = 0; i < this.count; i++) {\n      if (this.__value[i] > 1) this.__value[i] = 1;\n      if (this.__value[i] < 0) this.__value[i] = 0;\n    }\n\n    var shouldDraw = this.output();\n\n    if (shouldDraw) this.draw();\n  }",
  "function getFiles(config) {\n\n\treturn new Promise((resolve, reject) => {\n\n\t\tconst src = config.src;\n\t\tlet files = [];\n\t\tlet i = 0;\n\n\t\t(function proceed(error, moreFiles) {\n\n\t\t\tif(error !== null) {\n\n\t\t\t\treject(error);\n\n\t\t\t} else {\n\n\t\t\t\tfiles = files.concat(moreFiles);\n\n\t\t\t\tif(i === src.length) {\n\n\t\t\t\t\tif(files.length === 0) {\n\n\t\t\t\t\t\treject(\"No input files found\");\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresolve([config, files]);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglob(src[i++], proceed);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}(null, []));\n\n\t});\n\n}",
  "function formatMessage(message) {\n  var lines = message.split('\\n');\n\n  // line #0 is filename\n  // line #1 is the main error message\n  if (!lines[0] || !lines[1]) {\n    return message;\n  }\n\n  // Remove webpack-specific loader notation from filename.\n  // Before:\n  // ./~/css-loader!./~/postcss-loader!./src/App.css\n  // After:\n  // ./src/App.css\n  if (lines[0].lastIndexOf('!') !== -1) {\n    lines[0] = lines[0].substr(lines[0].lastIndexOf('!') + 1);\n  }\n\n  // Cleans up verbose \"module not found\" messages for files and packages.\n  if (lines[1].indexOf('Module not found: ') === 0) {\n    lines = [\n      lines[0],\n      // Clean up message because \"Module not found: \" is descriptive enough.\n      lines[1].replace(\n        'Cannot resolve \\'file\\' or \\'directory\\' ', ''\n      ).replace(\n        'Cannot resolve module ', ''\n      ).replace(\n        'Error: ', ''\n      ),\n      // Skip all irrelevant lines.\n      // (For some reason they only appear on the client in browser.)\n      '',\n      lines[lines.length - 1] // error location is the last line\n    ]\n  }\n\n  // Cleans up syntax error messages.\n  if (lines[1].indexOf('Module build failed: ') === 0) {\n    // For some reason, on the client messages appear duplicated:\n    // https://github.com/webpack/webpack/issues/3008\n    // This won't happen in Node but since we share this helpers,\n    // we will dedupe them right here. We will ignore all lines\n    // after the original error message text is repeated the second time.\n    var errorText = lines[1].substr('Module build failed: '.length);\n    var cleanedLines = [];\n    var hasReachedDuplicateMessage = false;\n    // Gather lines until we reach the beginning of duplicate message.\n    lines.forEach(function(line, index) {\n      if (\n        // First time it occurs is fine.\n        index !== 1 &&\n        // line.endsWith(errorText)\n        line.length >= errorText.length &&\n        line.indexOf(errorText) === line.length - errorText.length\n      ) {\n        // We see the same error message for the second time!\n        // Filter out repeated error message and everything after it.\n        hasReachedDuplicateMessage = true;\n      }\n      if (\n        !hasReachedDuplicateMessage ||\n        // Print last line anyway because it contains the source location\n        index === lines.length - 1\n      ) {\n        // This line is OK to appear in the output.\n        cleanedLines.push(line);\n      }\n    });\n    // We are clean now!\n    lines = cleanedLines;\n    // Finally, brush up the error message a little.\n    lines[1] = lines[1].replace(\n      'Module build failed: SyntaxError:',\n      friendlySyntaxErrorLabel\n    );\n  }\n\n  // Reassemble the message.\n  message = lines.join('\\n');\n  // Internal stacks are generally useless so we strip them\n  message = message.replace(\n    /^\\s*at\\s.*:\\d+:\\d+[\\s\\)]*\\n/gm, ''\n  ); // at ... ...:x:y\n\n  return message;\n}",
  "function removeCurrent() {\n\t        var className = player.config.classNames.tabFocus;\n\t        var current = getElements.call(player, \".\".concat(className));\n\t        toggleClass(current, className, false);\n\t      }",
  "function() {\n    return this.read_list(function() {\n      const node = this.node(\"staticvariable\");\n      let variable = this.node(\"variable\");\n      // plain variable name\n      if (this.expect(this.tok.T_VARIABLE)) {\n        const name = this.text().substring(1);\n        this.next();\n        variable = variable(name, false, false);\n      } else {\n        variable = variable(\"#ERR\", false, false);\n      }\n      if (this.token === \"=\") {\n        return node(variable, this.next().read_expr());\n      } else {\n        return variable;\n      }\n    }, \",\");\n  }",
  "function (path) {\n    let id;\n\n    if (path === '/') {\n      // \"root\" is a special alias for the fileId of the root folder\n      return Promise.resolve('root');\n    } else if ((id = this._fileIdCache.get(path))) {\n      // id is cached.\n      return Promise.resolve(id);\n    }\n    // id is not cached (or file doesn't exist).\n    // load parent folder listing to propagate / update id cache.\n    return this._getFolder(parentPath(path)).then(() => {\n      id = this._fileIdCache.get(path);\n      if (!id) {\n        if (path.substr(-1) === '/') {\n          return this._createFolder(path).then(() => {\n            return this._getFileId(path);\n          });\n        } else {\n          return Promise.resolve();\n        }\n      }\n      return Promise.resolve(id);\n    });\n  }",
  "function _runMocha(reporter, done, waited) {\n    if (get('waitForFrameworks') && !waited) {\n        var waitFor = (get('waitFor') || whenFrameworksReady).bind(window);\n        waitFor(_runMocha.bind(null, reporter, done, true));\n        return;\n    }\n    debug('_runMocha');\n    var mocha = window.mocha;\n    var Mocha = window.Mocha;\n    mocha.reporter(reporter.childReporter(window.location));\n    mocha.suite.title = reporter.suiteTitle(window.location);\n    mocha.grep(GREP);\n    // We can't use `mocha.run` because it bashes over grep, invert, and friends.\n    // See https://github.com/visionmedia/mocha/blob/master/support/tail.js#L137\n    var runner = Mocha.prototype.run.call(mocha, function (_error) {\n        if (document.getElementById('mocha')) {\n            Mocha.utils.highlightTags('code');\n        }\n        done(); // We ignore the Mocha failure count.\n    });\n    // Mocha's default `onerror` handling strips the stack (to support really old\n    // browsers). We upgrade this to get better stacks for async errors.\n    //\n    // TODO(nevir): Can we expand support to other browsers?\n    if (navigator.userAgent.match(/chrome/i)) {\n        window.onerror = null;\n        window.addEventListener('error', function (event) {\n            if (!event.error)\n                return;\n            if (event.error.ignore)\n                return;\n            runner.uncaught(event.error);\n        });\n    }\n}",
  "function createGlobals(shell) {\n  var globals = {\n    Buffer: Buffer,\n    console: console,\n    clearImmediate: clearImmediate,\n    clearInterval: clearInterval,\n    clearTimeout: clearTimeout,\n    setImmediate: setImmediate,\n    setInterval: setInterval,\n    setTimeout: setTimeout,\n    _: ijsrt\n  };\n\n  globals.global = globals;\n\n  return globals;\n}",
  "function advance_exec_cursor() {\n\t\t\t\tif (chain_is_corked) return;\n\t\t\t\twhile (exec_cursor < chain.length) {\n\t\t\t\t\tif (is_func(chain[exec_cursor])) {\n\t\t\t\t\t\tif (chain_opts[_Debug]) log_msg(\"$LAB.wait() executing: \"+chain[exec_cursor]);\n\t\t\t\t\t\ttry { chain[exec_cursor++](); } catch (err) {\n\t\t\t\t\t\t\tif (chain_opts[_Debug]) log_error(\"$LAB.wait() error caught: \",err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!chain[exec_cursor].finished) {\n\t\t\t\t\t\tif (check_chain_group_scripts_ready(chain[exec_cursor])) continue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\texec_cursor++;\n\t\t\t\t}\n\t\t\t\t// we've reached the end of the chain (so far)\n\t\t\t\tif (exec_cursor == chain.length) {\n\t\t\t\t\tscripts_currently_loading = false;\n\t\t\t\t\tgroup = false;\n\t\t\t\t}\n\t\t\t}",
  "function DescribeChangeTree(old_code_tree) {\n\n    function ProcessOldNode(node) {\n      var child_infos = [];\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        if (child.status != FunctionStatus.UNCHANGED) {\n          child_infos.push(ProcessOldNode(child));\n        }\n      }\n      var new_child_infos = [];\n      if (node.textually_unmatched_new_nodes) {\n        for (var i = 0; i < node.textually_unmatched_new_nodes.length; i++) {\n          var child = node.textually_unmatched_new_nodes[i];\n          new_child_infos.push(ProcessNewNode(child));\n        }\n      }\n      var res = {\n        name: node.info.function_name,\n        positions: DescribePositions(node),\n        status: node.status,\n        children: child_infos,\n        new_children: new_child_infos\n      };\n      if (node.status_explanation) {\n        res.status_explanation = node.status_explanation;\n      }\n      if (node.textual_corresponding_node) {\n        res.new_positions = DescribePositions(node.textual_corresponding_node);\n      }\n      return res;\n    }\n\n    function ProcessNewNode(node) {\n      var child_infos = [];\n      // Do not list ancestors.\n      if (false) {\n        for (var i = 0; i < node.children.length; i++) {\n          child_infos.push(ProcessNewNode(node.children[i]));\n        }\n      }\n      var res = {\n        name: node.info.function_name,\n        positions: DescribePositions(node),\n        children: child_infos,\n      };\n      return res;\n    }\n\n    function DescribePositions(node) {\n      return {\n        start_position: node.info.start_position,\n        end_position: node.info.end_position\n      };\n    }\n\n    return ProcessOldNode(old_code_tree);\n  }",
  "function findHeader(aoa) {\n  const {i} = aoa.reduce(\n    (prev, row, i) => {\n      const len = rowLength(row)\n      if (prev.len < len) {\n        return {i, len}\n      }\n      return prev\n    },\n    {i: -1, len: 0}\n  )\n  return i\n}",
  "function processIconTemplate(srcFile, destFile, data, cb) {\n  fs.readFile(srcFile, 'utf8', (err, srcFileContents) => {\n    if (err) throw err;\n    const result = template(srcFileContents, {\n      // Use custom template delimiters of `{{` and `}}`.\n      interpolate: /{{([\\s\\S]+?)}}/g,\n      // Use custom evaluate delimiters of `{%` and `%}`.\n      evaluate: /{%([\\s\\S]+?)%}/g,\n    })(data);\n    fs.writeFile(destFile, result, cb);\n  });\n}",
  "function saveWallet(filename, walletData) {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(filename, JSON.stringify(walletData, null, 2), function(err) {\n      if (err) return reject(console.error(err))\n\n      //console.log(`${name}.json written successfully.`)\n      return resolve()\n    })\n  })\n}",
  "function addInterfaceMethod(interfaceName, funcName, fN) {\n\n    // Store a reference to every interface/method\n    if (Steam.INTERFACES[interfaceName] === undefined) {\n        Steam.INTERFACES[interfaceName] = {};\n    }\n    Steam.INTERFACES[interfaceName][funcName] = fN;\n\n    // Camel case the method name\n    var name = funcName.substr(0,1).toLowerCase() + funcName.substr(1);\n\n    // Add method to Steam's prototype\n    if (!isMultiGameInterface(interfaceName)) {\n        steam[name] = fN;\n    }\n    // If multiple interfaces use the same method name\n    // Create a new method that requires a gameid property to find the correct method\n    //  and call the steam method automatically\n    else {\n        // We only need to do this once\n        if (steam[name] !== undefined) return;\n\n        // e.g. Turns 'IEconItems_440' into 'IEconItems'\n        var multi_interface_name = interfaceName.split('_')[0];\n\n        // Add method to Steam's prototype\n        steam[name] = function(steamObj, callback) {\n            var gameid = get(this, steamObj, 'gameid');\n\n            var interface_name = multi_interface_name + '_' + gameid;\n\n            Steam.INTERFACES[interface_name][funcName].call(this, steamObj, callback);\n        };\n    }\n\n}",
  "function extractSection( content ) {\n\t\t\tvar depth = 0;\t\t\t// tracks how difference between found opening and closing tags\n\t\t\tvar start = 0;\t\t\t// character position in `content` where inner-content starts\n\t\t\tvar position = 0;\t\t// current character position within _original_ content\n\t\t\tvar length = 0;\t\t\t// length section (= spacing plus bake-tag) we currently evaluate\n\t\t\tvar remain = content;\t// content left for further extraction\n\t\t\tvar section = {};\n\n\t\t\tdo {\n\n\t\t\t\tvar result = remain.match( regex );\n\n\t\t\t\tif( ! result ) break;\n\n\t\t\t\tlength = result[ 0 ].length;\n\t\t\t\tposition += result.index;\n\n\t\t\t\tif( depth === 0 ) {\n\n\t\t\t\t\tstart = position + length;\n\n\t\t\t\t\tsection = mout.object.merge( section, parseSignature( result[ 4 ] ), {\n\t\t\t\t\t\tbefore: content.slice( 0, position ),\n\t\t\t\t\t\tlinebreak: result[ 1 ],\n\t\t\t\t\t\tindent: result[ 2 ]\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tremain = remain.slice( result.index + length );\n\n\t\t\t\tdepth += ( result[ 3 ] === \"-start\" );\n\t\t\t\tdepth -= ( result[ 3 ] === \"-end\" );\n\n\t\t\t\tif( depth === 0 ) {\n\t\t\t\t\treturn mout.object.merge( section, {\n\t\t\t\t\t\tinner: content.slice( start, position ),\n\t\t\t\t\t\tafter: content.slice( position + length )\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tposition += length;\n\n\t\t\t} while( true );\n\n\t\t\treturn null;\n\t\t}",
  "function (eventName, handler) {\n    this._validateEvent(eventName);\n    var hl = this._handlers[eventName].length;\n    for (var i=0;i<hl;i++) {\n      if (this._handlers[eventName][i] === handler) {\n        this._handlers[eventName].splice(i, 1);\n        return;\n      }\n    }\n  }",
  "function(cell) {\n\n        var id = _.isString(cell) ? cell : cell.id;\n        \n        var $view = this.$('[model-id=\"' + id + '\"]');\n        if ($view.length) {\n\n            return $view.data('view');\n        }\n        return undefined;\n    }",
  "function trailer(file, fn) {\n  return through({objectMode: true}, function (a, e, cb) {\n    this.push(a)\n    cb()\n  }, function (cb) {\n    var self = this\n    fn(function (err, val) {\n      if (err) { return cb(err) }\n      if (val) {\n\n        if (typeof val === 'string') {\n          val = new Buffer(string)\n        }\n        \n        var f = new File({\n          path: file,\n          contents: val\n        })\n\n        self.push(f)\n      }\n      cb()  \n    })\n    \n  })\n}",
  "function assert(that, success, actualValue, expectedValue, type, functionName/*=\"ok\"*/, lineInfo/*=dynamic*/, stackIncrease/*=0*/) {\n        if(!stackIncrease) stackIncrease = 1\n        if(!functionName) functionName = \"ok\"\n        if(!lineInfo)\n            var lineInfoFuture = getLineInformation(functionName, stackIncrease, that.doSourcemappery, that.warningHandler)\n        else\n            var lineInfoFuture = Future(lineInfo)\n\n        // reste timeouts up the chain\n        var cur = that\n        while(cur !== undefined) {\n            setTesterTimeout(cur)\n            cur = cur.parentTester\n        }\n\n        var emitData = lineInfoFuture.then(function(lineInfo) {\n            var result = lineInfo\n            result.type = 'assert'\n            if(type !=='count') result.success = success === true\n\n            if(actualValue !== undefined)     result.actual = actualValue\n            if(expectedValue !== undefined)   result.expected = expectedValue\n\n            result.parent = that.id\n            result.time = now()\n\n           return Future(result)\n        })\n\n        return that.manager.emit(type, emitData)\n    }",
  "function componentDidUpdate(prevProps, prevState) {\n      var el = this.el;\n      var props = this.props;\n\n      // Update events.\n      updateEventListeners(el, prevProps.events, props.events);\n\n      // Update entity.\n      if (options.runSetAttributeOnUpdates) {\n        updateAttributes(el, prevProps, props);\n      }\n    }",
  "function match(name, regexps){\n  for (let regexp of regexps)\n    if (regexp.test(name))\n      return true;\n  return false;\n}",
  "function(source) {\n        \t// transform tokens\n\t \t\tvar pos = 0;\n\t \t\treturn _.map(this.lex(source), function(token) {\n\t \t\t\tif (token.type == 'line') {\n\t \t\t\t\ttoken.value = getNewline(source, pos);\n\t \t\t\t}\n\t \t\t\t\n\t \t\t\treturn {\n\t \t\t\t\ttype: token.type,\n\t \t\t\t\tstart: pos,\n\t \t\t\t\tend: (pos += token.value.length)\n\t \t\t\t};\n\t\t\t});\n\t\t}",
  "function findByIdQueryParams (request, config) {\n    return typeof config.baseQuery === 'undefined' ? {'id': request.params.id} : _.merge({'id': request.params.id}, underscore(config.baseQuery(request)))\n}",
  "function(record, columnHeader) {\n        var me = this,\n            grid = me.editingPlugin.grid,\n            store = grid.store,\n            view = grid.getView(),\n            context = me.context = Ext.apply(me.editingPlugin.context, {\n                view: view,\n                store: store\n            });\n\n        if (!me.rendered) {\n            me.render(view.el);\n        }\n        // make sure our row is selected before editing\n        context.grid.getSelectionModel().select(record);\n\n        // Reload the record data\n        me.loadRecord(record);\n\n        if (!me.isVisible()) {\n            me.show();\n        }\n        me.reposition({\n            callback: this.focusContextCell\n        });\n    }",
  "function pbkdf2 (password, salt, iterations, keySize, hash) {\n  const hasher = hashName[hash]\n  if (!hasher) {\n    throw new Error(`Hash '${hash}' is unknown or not supported`)\n  }\n  const dek = forgePbkdf2(\n    password,\n    salt,\n    iterations,\n    keySize,\n    hasher)\n  return forgeUtil.encode64(dek)\n}",
  "function ifStatusOk(response, fulfill, reject) {\n    var responseCode = response.code;\n    if (isClientError(responseCode)) {\n        reject({name : \"ClientErrorException\", message : response.body});\n    } else if (isServerError(responseCode)) {\n        reject({name : \"ServerErrorException\", message : response.error});\n    } else if (isOtherErrorResponse(responseCode)) {\n        reject({name : \"OtherCommunicationException\", message : response.error});\n    } else {\n        fulfill(response.body)\n    }\n}",
  "function escapeRegexString( token ) {\n\t// taken from: https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n\tconst matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\treturn token.update( str => str.replace( matchOperatorsRe, '\\\\$&' ) );\n}",
  "function(selector, context, skipFiltering) {\n\n        // quick return for #id case\n        var match;\n        if (!context && (match = selector.match(idRegexp))) {\n            var element = require('./view').byId(match[1]);\n            return new Collection(element ? [element] : []);\n        }\n        context = context || require('./attaching').Attaching.instances();\n        if (context.length === undefined) { context = [context]; }\n\n        var tokens = Selector.tokenize(selector),\n            expr   = tokens[0],\n            extra  = tokens[1],\n            result = context,\n            mapper;\n\n        while (expr.length > 0) {\n            mapper = mappers[expr[0]] ? mappers[expr.shift()] : mappers[''];\n            result = mapper(result);\n            if (expr.length === 0) { break; }\n            result = Selector.reduce(expr.shift(), result);\n        }\n\n        if (extra) {\n            result = result.concat(Selector.find(extra, context, true));\n        }\n\n        return skipFiltering ? result : new Collection(utils.unique(result));\n    }",
  "function makeOrdinal(words) {\n    // Ends with *00 (100, 1000, etc.) or *teen (13, 14, 15, 16, 17, 18, 19)\n    if (ENDS_WITH_DOUBLE_ZERO_PATTERN.test(words) || ENDS_WITH_TEEN_PATTERN.test(words)) {\n        return words + 'th';\n    }\n    // Ends with *y (20, 30, 40, 50, 60, 70, 80, 90)\n    else if (ENDS_WITH_Y_PATTERN.test(words)) {\n        return words.replace(ENDS_WITH_Y_PATTERN, 'ieth');\n    }\n    // Ends with one through twelve\n    else if (ENDS_WITH_ZERO_THROUGH_TWELVE_PATTERN.test(words)) {\n        return words.replace(ENDS_WITH_ZERO_THROUGH_TWELVE_PATTERN, replaceWithOrdinalVariant);\n    }\n    return words;\n}",
  "function findOctantsByLevel(octant, level, depth, result) {\n\n\tconst children = octant.children;\n\n\tlet i, l;\n\n\tif(depth === level) {\n\n\t\tresult.push(octant);\n\n\t} else if(children !== null) {\n\n\t\t++depth;\n\n\t\tfor(i = 0, l = children.length; i < l; ++i) {\n\n\t\t\tfindOctantsByLevel(children[i], level, depth, result);\n\n\t\t}\n\n\t}\n\n}",
  "function BlockSerializer(props) {\n    const {node, serializers, options, isInline, children} = props\n    const blockType = node._type\n    const serializer = serializers.types[blockType]\n    if (!serializer) {\n      throw new Error(\n        `Unknown block type \"${blockType}\", please specify a serializer for it in the \\`serializers.types\\` prop`\n      )\n    }\n\n    return h(serializer, {node, options, isInline}, children)\n  }",
  "function GroupRefOrDecChar(text, textLoc) {\n  const reference = Number(text.slice(1));\n\n  if (reference > 0 && reference <= capturingGroupsCount) {\n    return Node({\n      type: 'Backreference',\n      kind: 'number',\n      number: reference,\n      reference,\n    }, textLoc);\n  }\n\n  return Char(text, 'decimal', textLoc);\n}",
  "function toCamelcase(val, strict) {\n    if (strict === void 0) { strict = true; }\n    if (!strict || !/\\S+\\.[^\\.]\\S+/.test(val))\n        return chek_1.camelcase(val);\n    return val;\n}",
  "function replaceIdsRecursively(doc) {\n                _.each(doc, function(val, key) {\n                  if (key === 'workflowGuidAndLocaleDuplicates') {\n                  // Do not alter ids inside the historical archive of\n                  // the original orphaned docs. -Tom\n                    return;\n                  }\n                  if ((typeof (val) === 'string') && (val.length < 100)) {\n                    if (idsToNew[val]) {\n                      self.apos.utils.warn('Correcting ' + doc[key] + ' to ' + idsToNew[val] + ' in join');\n                      doc[key] = idsToNew[val];\n                      modified = true;\n                    }\n                  } else if (val && (typeof (val) === 'object')) {\n                    replaceIdsRecursively(val);\n                  }\n                });\n              }",
  "function loadJsSuites(_reporter, done) {\n    debug('loadJsSuites', jsSuites$1);\n    var loaders = jsSuites$1.map(function (file) {\n        // We only support `.js` dependencies for now.\n        return loadScript.bind(util, file);\n    });\n    parallel(loaders, done);\n}",
  "function readMessage(socketData, signer) {\n  var identities = socketData[0];\n  var signature = socketData[2].toString();\n  var header = socketData[3];\n  var parentHeader = socketData[4];\n  var metadata = socketData[5];\n  var content = socketData[6];\n\n  if (!signer.validate(signature, [ header, parentHeader, metadata, content ])) {\n    return null;\n  }\n\n  return createMessage(identities,\n                       JSON.parse(header),\n                       JSON.parse(parentHeader),\n                       JSON.parse(metadata),\n                       JSON.parse(content));\n}",
  "function _snapToPage() {\n\n        // Check whether pagination is active\n        if (!this.options.paginated ||\n            this._scroll.scrollForceCount || //don't paginate while moving\n            (this._scroll.springPosition !== undefined)) {\n            return;\n        }\n\n        // When the energy is below the thresshold, paginate to the current page\n        var item;\n        switch (this.options.paginationMode) {\n            case PaginationMode.SCROLL:\n                if (!this.options.paginationEnergyThreshold || (Math.abs(this._scroll.particle.getEnergy()) <= this.options.paginationEnergyThreshold)) {\n                    item = this.options.alignment ? this.getLastVisibleItem() : this.getFirstVisibleItem();\n                    if (item && item.renderNode) {\n                        this.goToRenderNode(item.renderNode);\n                    }\n                }\n                break;\n            case PaginationMode.PAGE:\n                item = this.options.alignment ? this.getLastVisibleItem() : this.getFirstVisibleItem();\n                if (item && item.renderNode) {\n                    this.goToRenderNode(item.renderNode);\n                }\n                break;\n        }\n    }",
  "function implementsOwn (o, method) {\n                    var args = libs.object.toArray(arguments),\n                        a    = args.shift();\n\n                    if(!a) return false;\n                    return libs.object.every(args, function (m) {\n                        if(!(a[m] instanceof Function) || !o.hasOwnProperty(method)) return false;\n                    });\n                }",
  "function define(Class, constructor, type) {\n  if (!client) { throw new Error('Usergrid not configured'); }\n  if (typeof Class === 'function') {\n    type = constructor;\n    constructor = Class;\n    Class = {};\n  }\n  Class._usergrid = {\n    constructor: constructor,\n    type: (type) ? type : constructor.name.toLowerCase()\n  };\n  _.mixin(Class, usergridStatics(client));\n  return Class;\n}",
  "function runRejectableQueue(queue) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new _Promise(function (resolve, reject) {\n    var step = function step(index) {\n      if (index >= queue.length) {\n        resolve();\n        return;\n      }\n      var result = isFunction(queue[index]) ? queue[index].apply(queue, _toConsumableArray(args)) : queue[index];\n      if (result === false) return reject('stop');\n      return _Promise.resolve(result).then(function () {\n        return step(index + 1);\n      }).catch(function (err) {\n        return reject(err || 'stop');\n      });\n    };\n    step(0);\n  });\n}",
  "function(rec){\n        var me          = this,\n            node        = me.getNode(rec, true),\n            el          = me.el,\n            adjustmentY = 0,\n            adjustmentX = 0,\n            elRegion    = el.getRegion(),\n            nodeRegion;\n\n        // Viewable region must not include scrollbars, so use\n        // DOM client dimensions\n        elRegion.bottom = elRegion.top + el.dom.clientHeight;\n        elRegion.right = elRegion.left + el.dom.clientWidth;\n        if (node) {\n            nodeRegion = Ext.fly(node).getRegion();\n            // node is above\n            if (nodeRegion.top < elRegion.top) {\n                adjustmentY = nodeRegion.top - elRegion.top;\n            // node is below\n            } else if (nodeRegion.bottom > elRegion.bottom) {\n                adjustmentY = nodeRegion.bottom - elRegion.bottom;\n            }\n\n            // node is left\n            if (nodeRegion.left < elRegion.left) {\n                adjustmentX = nodeRegion.left - elRegion.left;\n            // node is right\n            } else if (nodeRegion.right > elRegion.right) {\n                adjustmentX = nodeRegion.right - elRegion.right;\n            }\n\n            if (adjustmentX || adjustmentY) {\n                me.scrollBy(adjustmentX, adjustmentY, false);\n            }\n            el.focus();\n        }\n    }",
  "function $$SanitizeUriProvider() {\n\n  var aHrefSanitizationWhitelist = /^\\s*(https?|s?ftp|mailto|tel|file):/,\n    imgSrcSanitizationWhitelist = /^\\s*((https?|ftp|file|blob):|data:image\\/)/;\n\n  /**\n   * @description\n   * Retrieves or overrides the default regular expression that is used for whitelisting of safe\n   * urls during a[href] sanitization.\n   *\n   * The sanitization is a security measure aimed at prevent XSS attacks via HTML anchor links.\n   *\n   * Any url due to be assigned to an `a[href]` attribute via interpolation is marked as requiring\n   * the $sce.URL security context. When interpolation occurs a call is made to `$sce.trustAsUrl(url)`\n   * which in turn may call `$$sanitizeUri(url, isMedia)` to sanitize the potentially malicious URL.\n   *\n   * If the URL matches the `aHrefSanitizationWhitelist` regular expression, it is returned unchanged.\n   *\n   * If there is no match the URL is returned prefixed with `'unsafe:'` to ensure that when it is written\n   * to the DOM it is inactive and potentially malicious code will not be executed.\n   *\n   * @param {RegExp=} regexp New regexp to whitelist urls with.\n   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for\n   *    chaining otherwise.\n   */\n  this.aHrefSanitizationWhitelist = function(regexp) {\n    if (isDefined(regexp)) {\n      aHrefSanitizationWhitelist = regexp;\n      return this;\n    }\n    return aHrefSanitizationWhitelist;\n  };\n\n\n  /**\n   * @description\n   * Retrieves or overrides the default regular expression that is used for whitelisting of safe\n   * urls during img[src] sanitization.\n   *\n   * The sanitization is a security measure aimed at prevent XSS attacks via HTML image src links.\n   *\n   * Any URL due to be assigned to an `img[src]` attribute via interpolation is marked as requiring\n   * the $sce.MEDIA_URL security context. When interpolation occurs a call is made to\n   * `$sce.trustAsMediaUrl(url)` which in turn may call `$$sanitizeUri(url, isMedia)` to sanitize\n   * the potentially malicious URL.\n   *\n   * If the URL matches the `aImgSanitizationWhitelist` regular expression, it is returned unchanged.\n   *\n   * If there is no match the URL is returned prefixed with `'unsafe:'` to ensure that when it is written\n   * to the DOM it is inactive and potentially malicious code will not be executed.\n   *\n   * @param {RegExp=} regexp New regexp to whitelist urls with.\n   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for\n   *    chaining otherwise.\n   */\n  this.imgSrcSanitizationWhitelist = function(regexp) {\n    if (isDefined(regexp)) {\n      imgSrcSanitizationWhitelist = regexp;\n      return this;\n    }\n    return imgSrcSanitizationWhitelist;\n  };\n\n  this.$get = function() {\n    return function sanitizeUri(uri, isMediaUrl) {\n      // if (!uri) return uri;\n      var regex = isMediaUrl ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;\n      var normalizedVal = urlResolve(uri && uri.trim()).href;\n      if (normalizedVal !== '' && !normalizedVal.match(regex)) {\n        return 'unsafe:' + normalizedVal;\n      }\n      return uri;\n    };\n  };\n}",
  "function isNumeric () {\n                    return libs.object.every(arguments, function (item) {\n                        return !isNaN(parseFloat(item)) && isFinite(item);\n                    });\n                }",
  "function getHighlightOptions(config, arg) {\n\n  let lang = '';\n  if (rLang.test(arg)) {\n    arg = arg.replace(rLang, (match, _lang) => {\n      lang = _lang;\n      return '';\n    });\n  }\n\n  let line_number = config.line_number;\n  if (rLineNumber.test(arg)) {\n    arg = arg.replace(rLineNumber, (match, _line_number) => {\n      line_number = _line_number === 'true';\n      return '';\n    });\n  }\n\n  let first_line = 1;\n  if (rFirstLine.test(arg)) {\n    arg = arg.replace(rFirstLine, (match, _first_line) => {\n      first_line = _first_line;\n      return '';\n    });\n  }\n\n  let mark = [];\n  if (rMark.test(arg)) {\n    arg = arg.replace(rMark, (match, _mark) => {\n      mark = _mark.split(',').reduce(function getMarkedLines(prev, cur) {\n        if (/-/.test(cur)) {\n          let a = Number(cur.substr(0, cur.indexOf('-')));\n          let b = Number(cur.substr(cur.indexOf('-') + 1));\n          if (b < a) { // switch a & b\n            const temp = a;\n            a = b;\n            b = temp;\n          }\n\n          for (; a <= b; a++) {\n            prev.push(a);\n          }\n\n          return prev;\n        }\n\n        prev.push(Number(cur));\n        return prev;\n      }, []);\n\n      return '';\n    });\n  }\n\n  let caption = '';\n  if (rCaptionUrlTitle.test(arg)) {\n    const match = arg.match(rCaptionUrlTitle);\n    caption = `<span>${match[1]}</span><a href=\"${match[2]}${match[3]}\">${match[4]}</a>`;\n  } else if (rCaptionUrl.test(arg)) {\n    const match = arg.match(rCaptionUrl);\n    caption = `<span>${match[1]}</span><a href=\"${match[2]}${match[3]}\">link</a>`;\n  } else if (rCaption.test(arg)) {\n    const match = arg.match(rCaption);\n    caption = `<span>${match[1]}</span>`;\n  }\n\n  return {\n    lang,\n    firstLine: first_line,\n    caption,\n    gutter: line_number,\n    hljs: config.hljs,\n    mark,\n    tab: config.tab_replace,\n    autoDetect: config.auto_detect\n  };\n}",
  "function scrollSidebar(event) {\n            if (event.handled !== true) {\n                var scrollTop = $window.scrollTop(),\n                    maxScrollTop = $document.height() - $window.height();\n                if (scrollTop >= 0 && prevScrollTop >= 0 && scrollTop <= maxScrollTop && prevScrollTop <= maxScrollTop) {  // for Mac scrolling\n                    $sidebar.scrollTop($sidebar.scrollTop() + (scrollTop - prevScrollTop));\n                }\n                prevScrollTop = scrollTop;\n                event.handled = true;\n            }\n            else {\n                return false;\n            }\n        }",
  "function drawFaviconArc(context, total, start, length, color) {\n    var arcStart = ARC_OFFSET + Math.PI * 2 * (start / total);\n    var arcEnd = ARC_OFFSET + Math.PI * 2 * ((start + length) / total);\n    context.beginPath();\n    context.strokeStyle = color;\n    context.lineWidth = ARC_WIDTH;\n    context.arc(16, 16, 16 - ARC_WIDTH / 2, arcStart, arcEnd);\n    context.stroke();\n}",
  "function HelperOptions(scope, nodeList, exprData, stringOnly) {\n\tthis.metadata = { rendered: false };\n\tthis.stringOnly = stringOnly;\n\tthis.scope = scope;\n\tthis.nodeList = nodeList;\n\tthis.exprData = exprData;\n}",
  "function defaultArgsProvider(request, callback) {\n    var args  = request.args,\n        params = request.command.params;\n\n    for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n\n        // If the parameter is already valid, then don't ask for it anymore.\n        if (request.getParamStatus(param) != Status.VALID ||\n            // Ask for optional parameters as well.\n            param.defaultValue === null) \n        {\n            var paramPrompt = param.description;\n            if (param.defaultValue === null) {\n                paramPrompt += \" (optional)\";\n            }\n            var value = prompt(paramPrompt, param.defaultValue || \"\");\n            // No value but required -> nope.\n            if (!value) {\n                callback();\n                return;\n            } else {\n                args[param.name] = value;\n            }           \n        }\n    }\n    callback();\n}",
  "function isSingleLineNode(node) {\n\t\tvar lastToken = context.getLastToken(node),\n\t\t\tstartLine = node.loc.start.line,\n\t\t\tendLine = lastToken.loc.end.line;\n\n\t\treturn startLine === endLine;\n\t}",
  "function __decode(raw, key) {\n\n  var res = []; // output buffer\n  var len = _.size(key);\n  var cc = len; // key switch counter\n  for (var i = 0, ii = _.size(raw); i < ii; ++i) {\n    if (cc-- > 0) {\n      res[i] = (raw[i] - key.shift()) % 256;\n    } else {\n      res[i] = (raw[i] - res[i - len]) % 256;\n    }\n  }\n  return new Buffer(res);\n}",
  "function createDefaultSetter(key) {\n  return function set(newValue) {\n    _Object$defineProperty(this, key, {\n      configurable: true,\n      writable: true,\n      // IS enumerable when reassigned by the outside word\n      enumerable: true,\n      value: newValue\n    });\n    return newValue;\n  };\n}",
  "function whitespace(rule, value, source, errors, options) {\n  if (/^\\s+$/.test(value) || value === '') {\n    errors.push(util.format(options.messages.whitespace, rule.fullField));\n  }\n}",
  "function parseNode(str, parseList, currentIndex, fileInfo, callback) {\n        var result, returnNodes = [];\n        var parser = parserInput;\n\n        try {\n            parser.start(str, false, function fail(msg, index) {\n                callback({\n                    message: msg,\n                    index: index + currentIndex\n                });\n            });\n            for (var x = 0, p, i; (p = parseList[x]); x++) {\n                i = parser.i;\n                result = parsers[p]();\n                if (result) {\n                    result._index = i + currentIndex;\n                    result._fileInfo = fileInfo;\n                    returnNodes.push(result);\n                }\n                else {\n                    returnNodes.push(null);\n                }\n            }\n\n            var endInfo = parser.end();\n            if (endInfo.isFinished) {\n                callback(null, returnNodes);\n            }\n            else {\n                callback(true, null);\n            }\n        } catch (e) {\n            throw new LessError({\n                index: e.index + currentIndex,\n                message: e.message\n            }, imports, fileInfo.filename);\n        }\n    }",
  "function decodeParams(names, types, data, useNumberedParams = true) {\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    data = types;\n    types = names;\n    names = [];\n  }\n\n  data = utils.hexOrBuffer(data);\n  var values = new Result();\n\n  var offset = 0;\n  types.forEach(function(type, index) {\n    var coder = getParamCoder(type);\n\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, dynamicOffset.value.toNumber());\n      offset += dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n      offset += result.consumed;\n    }\n\n    if (useNumberedParams) {\n      values[index] = result.value;\n    }\n\n    if (names[index]) {\n      values[names[index]] = result.value;\n    }\n  });\n  return values;\n}",
  "function valueShouldBeInsertedAsHTML(value) {\n\treturn value !== null && typeof value === \"object\" && (\n\t\ttypeof value[toDOMSymbol] === \"function\" ||\n\t\ttypeof value[viewInsertSymbol] === \"function\" ||\n\t\ttypeof value.nodeType === \"number\" );\n}",
  "function (yaw, pitch, roll) {\n    \n    var Rx, Ry, Rz;\n    if (roll == 0) Rx = [[1,0,0],[0,1,0],[0,0,1]];\n    else Rx = [[1, 0, 0], [0, Math.cos(roll), Math.sin(roll)], [0, -Math.sin(roll), Math.cos(roll)]];\n    if (pitch == 0) Ry = [[1,0,0],[0,1,0],[0,0,1]];\n    else Ry = [[Math.cos(pitch), 0, -Math.sin(pitch)], [0, 1, 0], [Math.sin(pitch), 0, Math.cos(pitch)]];\n    if (yaw == 0) Rz = [[1,0,0],[0,1,0],[0,0,1]];\n    else Rz = [[Math.cos(yaw), Math.sin(yaw), 0], [-Math.sin(yaw), Math.cos(yaw), 0], [0, 0, 1]];\n    \n    var R = numeric.dotMMsmall(Ry,Rz);\n    R = numeric.dotMMsmall(Rx,R);\n    return R;\n}",
  "function binb_sha1 (x, len) {\n  // append padding\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n  var t, oa, ob, oc, od, oe, i = 0, j = 0;\n\n  for (i; i < x.length; i += 16) {\n    oa = a;\n    ob = b;\n    oc = c;\n    od = d;\n    oe = e;\n\n    for (j; j < 80; j++) {\n      if (j < 16) w[j] = x[i + j];\n      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = bit_rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, oa);\n    b = safe_add(b, ob);\n    c = safe_add(c, oc);\n    d = safe_add(d, od);\n    e = safe_add(e, oe);\n  }\n\n  return Array(a, b, c, d, e);\n}",
  "function makeSubclass(getSignatureFunction) {\n        var superClass = OAuth.SignatureMethod;\n        var subClass = function() {\n            superClass.call(this);\n        };\n        subClass.prototype = new superClass();\n        // Delete instance variables from prototype:\n        // delete subclass.prototype... There aren't any.\n        subClass.prototype.getSignature = getSignatureFunction;\n        subClass.prototype.constructor = subClass;\n        return subClass;\n    }",
  "function walk(args) {\n    args.node.forEach(function(item, i) {\n      var name = args.selector(item);\n      var namespace = args.namespaceSelector &&\n                      makeNamespace(args.namespaceSelector(item));\n      var extraSymbols = args.getExtraSymbols(args.node, i);\n\n      var info = name && getPrefixInfo(name, namespace, extraSymbols);\n      if (!info) return;\n      args.payload(info, i);\n    });\n  }",
  "function _forEachRenderable(callback) {\n        if (this._nodesById) {\n            for (var key in this._nodesById) {\n                callback(this._nodesById[key]);\n            }\n        }\n        else {\n            var sequence = this._viewSequence.getHead();\n            while (sequence) {\n                var renderable = sequence.get();\n                if (renderable) {\n                    callback(renderable);\n                }\n                sequence = sequence.getNext();\n            }\n        }\n    }",
  "function filterFunctionWordsAtBeginningAndEnding( wordCombinations, functionWords ) {\n\twordCombinations = filterFunctionWordsAtBeginning( wordCombinations, functionWords );\n\twordCombinations = filterFunctionWordsAtEnding( wordCombinations, functionWords );\n\treturn wordCombinations;\n}",
  "function(url) {\n\t        // TODO reuse source from script tags?\n\t        if (!(url in this.sourceCache)) {\n\t            this.sourceCache[url] = this.ajax(url).split('\\n');\n\t        }\n\t        return this.sourceCache[url];\n\t    }",
  "function() {\n        var me = this,\n            picker;\n\n        if (me.isExpanded) {\n            picker = me.getPicker();\n            if (me.matchFieldWidth) {\n                // Auto the height (it will be constrained by max height)\n                picker.setWidth(me.bodyEl.getWidth());\n            }\n            if (picker.isFloating()) {\n                me.doAlign();\n            }\n        }\n    }",
  "function bi_flush() {\n      if (bi_valid == 16) {\n        put_short(bi_buf);\n        bi_buf = 0;\n        bi_valid = 0;\n      } else if (bi_valid >= 8) {\n        put_byte(bi_buf & 0xff);\n        bi_buf >>>= 8;\n        bi_valid -= 8;\n      }\n    }",
  "function() {\n        var me = this,\n            copy = new this.self(me.initialConfig);\n\n        copy.add(me.keys, me.items);\n        return copy;\n    }",
  "function listener(element, selector, type, callback) {\n    return function(e) {\n        e.delegateTarget = closest_1(e.target, selector);\n\n        if (e.delegateTarget) {\n            callback.call(element, e);\n        }\n    }\n}",
  "function domHandler(e) {\n    e = e || env.root.event;\n    var wrapped = wrapDomEvent(e);\n    evt.trigger(this, normalize(wrapped));\n}",
  "function(type, walk) {\n    if (!this.atGroupMarker(type, walk))\n      return false;\n    // Find the end of the block, checking for adjacent blocks\n    var startIdx = walk.position;\n    var found = false;\n    while (walk.hasCurrent() && !found) {\n      walk.scrollToTerm().skipWhitespaces();\n      if (!this.atGroupMarker(type, walk))\n        found = true;\n    }\n    var g = this.stripSelector(new SubWalker(walk, startIdx, walk.position));\n    this.emitGroup(type, g);\n    return true;\n  }",
  "function interceptPromiseResponse(hasIntercepted, promise, doneHookInfo) {\n    let {hook} = doneHookInfo;\n    return promise.then(\n        res => (hasIntercepted ? doneHookInfo.resData : hook(null, res)),\n        err => {\n            // check whether is intercepted to avoid repeated interception\n            if (hasIntercepted) {\n                let {resException, resData} = doneHookInfo;\n                if (resException) {\n                    throw resData;\n                }\n                return resData;\n            }\n\n            return hook(err || /* istanbul ignore next */ 'err');\n        }\n    );\n}",
  "function addListElementFontSize(element)\n    {\n      var hDataWeight = -9007199254740992;\n      var lDataWeight = 9007199254740992;\n      $.each(element.find(\"li\"), function(){\n        cDataWeight = getDataWeight(this);\n        if (cDataWeight == undefined)\n        {\n          logWarning(\"No \\\"data-weight\\\" attribut defined on <li> element\");\n        }\n        else\n        {\n          hDataWeight = cDataWeight > hDataWeight ? cDataWeight : hDataWeight;\n          lDataWeight = cDataWeight < lDataWeight ? cDataWeight : lDataWeight;\n        }\n      });\n      $.each(element.find(\"li\"), function(){\n        var dataWeight = getDataWeight(this);\n        var percent = Math.abs((dataWeight - lDataWeight)/(lDataWeight - hDataWeight));\n        $(this).css('font-size', (1 + (percent * settings['multiplier'])) + \"em\");\n      });\n\n    }",
  "function _extend(a, b) {\r\n    forEach(b, (bVal, key) => {\r\n        let type = typeForExtend(a);\r\n        switch(type) {\r\n            case types.array:\r\n            case types.object:\r\n                if (a[key] === undefined || a[key] === null)\r\n                    a[key] = b[key];\r\n                else if (isExtendable(a[key], b[key]))\r\n                    _extend(a[key], b[key]);\r\n                break;\r\n            case types.set:\r\n                if (!a.has(bVal))\r\n                    a.add(bVal);\r\n                break;\r\n            case types.map:\r\n                if (!a.has(key))\r\n                    a.set(key, bVal);\r\n                else {\r\n                    let aVal = a.get(key);\r\n                    if (aVal === undefined || aVal === null)\r\n                        a.set(key, bVal);\r\n                    else if (isExtendable(aVal, bVal))\r\n                        _extend(aVal, bVal);\r\n                }\r\n                break;\r\n        }\r\n    });\r\n    return a;\r\n}",
  "function(fromClass, members) {\n            //<debug>\n            Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#borrow', arguments);\n            //</debug>\n            \n            var prototype = this.prototype,\n                fromPrototype = fromClass.prototype,\n                //<debug>\n                className = Ext.getClassName(this),\n                //</debug>\n                i, ln, name, fn, toBorrow;\n\n            members = Ext.Array.from(members);\n\n            for (i = 0,ln = members.length; i < ln; i++) {\n                name = members[i];\n\n                toBorrow = fromPrototype[name];\n\n                if (typeof toBorrow == 'function') {\n                    fn = Ext.Function.clone(toBorrow);\n\n                    //<debug>\n                    if (className) {\n                        fn.displayName = className + '#' + name;\n                    }\n                    //</debug>\n\n                    fn.$owner = this;\n                    fn.$name = name;\n\n                    prototype[name] = fn;\n                }\n                else {\n                    prototype[name] = toBorrow;\n                }\n            }\n\n            return this;\n        }",
  "function vhostof (req, regexp, subsite) {\n  var host = req.headers.host\n  var hostname = hostnameof(req)\n\n  if (!hostname) {\n    return\n  }\n\n  var match = regexp.exec(hostname)\n\n  if (!match) {\n    return\n  }\n\n  if (subsite && 'IS_ROUTE' != subsite && !_.startsWith(req.path, subsite+'/', 1)\n    && (req.get('X-Base-Url-Path') != subsite)) {\n    return\n  }\n\n  var obj = Object.create(null)\n\n  obj.host = host\n  obj.hostname = hostname\n  obj.length = match.length - 1\n\n  for (var i = 1; i < match.length; i++) {\n    obj[i - 1] = match[i]\n  }\n\n  return obj\n}",
  "function(className, testFn, scope) {\n        var me = this,\n            dom = me.dom,\n            hasTest = Ext.isFunction(testFn);\n            \n        me.hover(\n            function() {\n                if (hasTest && testFn.call(scope || me, me) === false) {\n                    return;\n                }\n                Ext.fly(dom, INTERNAL).addCls(className);\n            },\n            function() {\n                Ext.fly(dom, INTERNAL).removeCls(className);\n            }\n        );\n        return me;\n    }",
  "function getPlainObjectNodeValue(node, path, t) {\n    let result;\n    if (t.isObjectExpression(node)) {\n        result = {};\n\n        let props = node.properties || [];\n        for (let i = 0, len = props.length; i < len; i++) {\n            let subNode = props[i];\n            let keyNode = subNode.key;\n            let key;\n            if (t.isLiteral(keyNode)) {\n                key = keyNode.value;\n            }\n            else if (t.isIdentifier(keyNode)) {\n                key = keyNode.name;\n            }\n\n            if (!key) {\n                continue;\n            }\n\n            result[key] = getPlainObjectNodeValue(subNode.value, path, t);\n        }\n    }\n    else if (t.isArrayExpression(node)) {\n        result = [];\n        node.elements.forEach(item => {\n            result.push(getPlainObjectNodeValue(item, path, t));\n        });\n    }\n    else if (t.isNullLiteral(node)) {\n        result = null;\n    }\n    else if (t.isLiteral(node)) {\n        result = node.value;\n    }\n    else {\n        throw path.buildCodeFrameError('only constant is supported');\n    }\n    return result;\n}",
  "function ClickTrackingContext(ctx, px, py) {\n  forward(this, ctx);\n\n  var stack = [];\n  this.hits = [];\n  this.hit = null;\n  \n  var that = this;\n  function recordHit() {\n    that.hits.unshift(Array.prototype.slice.call(stack));\n    that.hit = that.hits[0];\n  }\n\n  this.pushObject = function(o) {\n    stack.unshift(o);\n  };\n  \n  this.popObject = function() {\n    stack.shift();\n  };\n\n  this.reset = function() {\n    this.hits = [];\n    this.hit = null;\n  };\n\n  // These are (most of) the canvas methods which draw something.\n  // TODO: would it make sense to purge existing hits covered by this?\n  this.clearRect = function(x, y, w, h) { };\n\n  this.fillRect = function(x, y, w, h) {\n    if (px >= x && px <= x + w && py >= y && py <= y + h) recordHit();\n  };\n\n  this.strokeRect = function(x, y, w, h) {\n    // ...\n  };\n\n  this.fill = function(fillRule) {\n    // TODO: implement fillRule\n    if (ctx.isPointInPath(px, py)) recordHit();\n  };\n\n  this.stroke = function() {\n    if (ctx.isPointInStroke(px, py)) recordHit();\n  };\n\n  this.fillText = function(text, x, y, maxWidth) {\n    // ...\n  };\n\n  this.strokeText = function(text, x, y, maxWidth) {\n    // ...\n  };\n}",
  "function newSource(type, init) {\n\t        // Bail if new type isn't known, it's the current type, or current type is empty (video is default) and new type is video\n\t        if (!(type in types) || !init && type === currentType || !currentType.length && type === types.video) {\n\t          return;\n\t        }\n\n\t        switch (type) {\n\t          case types.video:\n\t            player.source = {\n\t              type: 'video',\n\t              title: 'View From A Blue Moon',\n\t              sources: [{\n\t                src: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-576p.mp4',\n\t                type: 'video/mp4',\n\t                size: 576\n\t              }, {\n\t                src: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-720p.mp4',\n\t                type: 'video/mp4',\n\t                size: 720\n\t              }, {\n\t                src: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-1080p.mp4',\n\t                type: 'video/mp4',\n\t                size: 1080\n\t              }, {\n\t                src: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-1440p.mp4',\n\t                type: 'video/mp4',\n\t                size: 1440\n\t              }],\n\t              poster: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.jpg',\n\t              tracks: [{\n\t                kind: 'captions',\n\t                label: 'English',\n\t                srclang: 'en',\n\t                src: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.en.vtt',\n\t                default: true\n\t              }, {\n\t                kind: 'captions',\n\t                label: 'French',\n\t                srclang: 'fr',\n\t                src: 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.fr.vtt'\n\t              }]\n\t            };\n\t            break;\n\n\t          case types.audio:\n\t            player.source = {\n\t              type: 'audio',\n\t              title: 'Kishi Bashi &ndash; &ldquo;It All Began With A Burst&rdquo;',\n\t              sources: [{\n\t                src: 'https://cdn.plyr.io/static/demo/Kishi_Bashi_-_It_All_Began_With_a_Burst.mp3',\n\t                type: 'audio/mp3'\n\t              }, {\n\t                src: 'https://cdn.plyr.io/static/demo/Kishi_Bashi_-_It_All_Began_With_a_Burst.ogg',\n\t                type: 'audio/ogg'\n\t              }]\n\t            };\n\t            break;\n\n\t          case types.youtube:\n\t            player.source = {\n\t              type: 'video',\n\t              sources: [{\n\t                src: 'https://youtube.com/watch?v=bTqVqk7FSmY',\n\t                provider: 'youtube'\n\t              }]\n\t            };\n\t            break;\n\n\t          case types.vimeo:\n\t            player.source = {\n\t              type: 'video',\n\t              sources: [{\n\t                src: 'https://vimeo.com/76979871',\n\t                provider: 'vimeo'\n\t              }]\n\t            };\n\t            break;\n\n\t          default:\n\t            break;\n\t        } // Set the current type for next time\n\n\n\t        currentType = type; // Remove active classes\n\n\t        Array.from(buttons).forEach(function (button) {\n\t          return toggleClass(button.parentElement, 'active', false);\n\t        }); // Set active on parent\n\n\t        toggleClass(document.querySelector(\"[data-source=\\\"\".concat(type, \"\\\"]\")), 'active', true); // Show cite\n\n\t        Array.from(document.querySelectorAll('.plyr__cite')).forEach(function (cite) {\n\t          cite.setAttribute('hidden', '');\n\t        });\n\t        document.querySelector(\".plyr__cite--\".concat(type)).removeAttribute('hidden');\n\t      }",
  "function(qName, type, offset, limit) {\n    var q = queue.get(qName);\n    if (!(offset >= 0)) {\n      offset = 0;\n    }\n    if (!(limit >= 0)) {\n      limit = 30;\n    }\n    if (type === 'wait' || type === 'active') {\n      return q.getJobs(type, 'LIST', offset, offset + limit - 1).then(function(jobs) {\n        return Promise.all(_.map(jobs, function(job) {\n          if (!job) {\n            return null;\n          }\n          return job.getState().then(function(state) {\n            job.state = state;\n            return job;\n          });\n        }));\n      });\n    } else if (type === 'delayed') {\n      return q.getJobs(type, 'ZSET', offset, offset + limit - 1).then(function(jobs) {\n        return Promise.all(_.map(jobs, function(job) {\n          if (!job) {\n            return null;\n          }\n          return job.getState().then(function(state) {\n            job.state = state;\n            return job;\n          });\n        }));\n      });\n    } else if (type === 'completed' || type === 'failed') {\n      var client = redis.client();\n      var key = 'bull:' + qName + ':' + type;\n      return client.smembersAsync(key).then(function(ids) {\n        var _ids = ids.slice(offset, offset + limit);\n        return Promise.all(_.map(_ids, function(id) {\n          return q.getJob(id).then(function(job) {\n            if (!job) {\n              return null;\n            }\n            return job.getState().then(function(state) {\n              job.state = state;\n              return job;\n            });\n          });\n        }));\n      });\n    }\n    throw new Error('You must provide a valid job type.');\n  }",
  "function getExe() {\n  /* istanbul ignore next: tested on all platform on travis */\n  switch (process.platform) {\n    case \"darwin\":\n      return \"mkcert-\" + MKCERT_VERSION + \"-darwin-amd64\"\n    case \"linux\":\n      return \"mkcert-\" + MKCERT_VERSION + \"-linux-amd64\"\n    case \"win32\":\n      return \"mkcert-\" + MKCERT_VERSION + \"-windows-amd64.exe\"\n    default:\n      console.warn(\"Cannot generate the localhost certificate on your \" +\n        \"platform. Please, consider contacting the developer if you can help.\")\n      process.exit(0)\n  }\n}",
  "function skipWhitespaceNodes(e, next) {\n\t\twhile (e && (e.nodeType === 8 || (e.nodeType === 3 && /^[ \\t\\n\\r]*$/.test(e.nodeValue)))) {\n\t\t\te = next(e);\n\t\t}\n\t\treturn e;\n\t}",
  "function onListening () {\n        let addr = server.address(),\n            bind = typeof addr === 'string'\n          ? 'pipe ' + addr\n          : 'port ' + addr.port;\n        we.log.info('Run in '+we.env+' enviroment and listening on ' + bind);\n\n        if (process.send) {\n          process.send('ready');\n        }\n      }",
  "function defineVisitor(context, options) {\n    const testInfoPrototype = {\n        get isStrict() {\n            return nomalizeScope(context.getScope(), this.node).isStrict\n        },\n    }\n\n    /**\n     * Check whether a given case object is full-supported on the configured node version.\n     * @param {{supported:string}} aCase The case object to check.\n     * @returns {boolean} `true` if it's supporting.\n     */\n    function isNotSupportingVersion(aCase) {\n        return (\n            !aCase.supported ||\n            options.version.intersects(getSemverRange(`<${aCase.supported}`))\n        )\n    }\n\n    /**\n     * Define the predicate function to check whether a given case object is supported on the configured node version.\n     * @param {Node} node The node which is reported.\n     * @returns {function(aCase:{supported:string}):boolean} The predicate function.\n     */\n    function isNotSupportingOn(node) {\n        return aCase =>\n            isNotSupportingVersion(aCase) &&\n            (!aCase.test || aCase.test({ node, __proto__: testInfoPrototype }))\n    }\n\n    return (\n        keywords\n            // Omit full-supported features and ignored features by options\n            // because this rule never reports those.\n            .filter(\n                keyword =>\n                    !options.ignores.has(keyword) &&\n                    features[keyword].cases.some(isNotSupportingVersion)\n            )\n            // Merge remaining features with overriding `context.report()`.\n            .reduce((visitor, keyword) => {\n                const { ruleId, cases } = features[keyword]\n                const rule = esRules[ruleId]\n                const thisContext = {\n                    __proto__: context,\n\n                    // Override `context.report()` then:\n                    // - ignore if it's supported.\n                    // - override reporting messages.\n                    report(descriptor) {\n                        // Set additional information.\n                        if (descriptor.data) {\n                            descriptor.data.version = options.version.raw\n                        } else {\n                            descriptor.data = { version: options.version.raw }\n                        }\n                        descriptor.fix = undefined\n\n                        // Test and report.\n                        const node = descriptor.node\n                        const hitCase = cases.find(isNotSupportingOn(node))\n                        if (hitCase) {\n                            descriptor.messageId = hitCase.messageId\n                            descriptor.data.supported = hitCase.supported\n                            super.report(descriptor)\n                        }\n                    },\n                }\n                return merge(visitor, rule.create(thisContext))\n            }, {})\n    )\n}",
  "function() {\n            Ext.data.flash.BinaryXhr.flashPluginActive = true;\n            Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById(\"ext-flash-polyfill\");\n            Ext.globalEvents.fireEvent(\"flashready\"); // let all pending connections know\n        }",
  "function OneToMany(elements) {\n    return function (targetObject, propertyKey) {\n        var entityMetadata = targetObject;\n        if (!entityMetadata.oneToManyMap) {\n            entityMetadata.oneToManyMap = {};\n        }\n        entityMetadata.oneToManyMap[propertyKey] = elements;\n    };\n}",
  "function getPointersCenter(pointers) {\n  var pageX = 0;\n  var pageY = 0;\n  var count = 0;\n  forEach(pointers, function (_ref3) {\n    var startX = _ref3.startX,\n        startY = _ref3.startY;\n    pageX += startX;\n    pageY += startY;\n    count += 1;\n  });\n  pageX /= count;\n  pageY /= count;\n  return {\n    pageX: pageX,\n    pageY: pageY\n  };\n}",
  "function transformTextNode(transformer, textNode, tplOpts, options) {\n    let handler = findMatchTransformer(transformer, textNode.data, textNode);\n    handler && handler.call(this, textNode, tplOpts, options);\n}",
  "function startConnector(username, apiKey, exitCb) {\n    var jarPath = process.env.SAUCE_JAR || path.join(__dirname, \"thirdparty\", \"Sauce-Connect.jar\")\n    var jcmd = \"java\"\n    var jargs = [\"-Xmx64m\", \"-jar\", jarPath, username, apiKey]\n    var screencmd = \"java -Xmx64m -jar \" + jarPath + \" [USERNAME] [API KEY]\"\n    \n    ctx.comment(\"Starting Sauce Connector\")\n    var opts = {\n      cwd: ctx.workingDir,\n      cmd: {\n        command: jcmd,\n        args: jargs,\n        screen: screencmd\n      }\n    }\n    connectorProc = ctx.cmd(opts, exitCb)\n    // Wait until connector outputs \"You may start your tests\"\n    // before returning\n    connectorProc.stdout.on('data', function(data) {\n      console.log(\">>\", data);\n      if (/Connected! You may start your tests./.exec(data) !== null) {\n          console.log(\">> STRIDER-SAUCE :: TUNNEL READY\")\n          return cb(null, true)\n      }\n    })\n  }",
  "async function(filename, data) {\n      if (!data) {\n        if (await fs.existsAsync(filename)) {\n          fs.unlinkAsync(filename);\n        }\n      } else {\n        await fs.writeFileAsync(filename, JSON.stringify(data, null, 2), \"utf8\");\n      }\n    }"
]