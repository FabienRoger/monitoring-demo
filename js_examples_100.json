[
  "function(query, option) {\n  var result = new RegExp(query, \"i\").exec(option.textContent);\n  if (result) {\n    return option.textContent.replace(result[0], \"<span class='selectr-match'>\" + result[0] + \"</span>\");\n  }\n  return false;\n}",
  "function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (_.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t}",
  "function constructCredentials(password, question, answer) {\n    var credentials = {};\n    if(password) credentials.password = constructPassword(password);\n    if(question && answer) credentials.recovery_question = constructRecoveryQuestion(question, answer);\n    return credentials;\n}",
  "function parseDb(data, cb) {\n              if (data && data.trim().length) {\n                log.debug(\"Parsing database\");\n                t.__db = jsonlint.parse(data);\n              } else {\n                log.debug(\"No database to parse\");\n                t.__db = {};\n              }\n              cb(null, t.__db);\n            }",
  "function attachLibraryToSelf () {\n            for(var i in libs)\n                if(libs.hasOwnProperty(i) && !self[i]) self[i] = libs[i];\n            return self;\n        }",
  "function emit(instance, name) {\n        var args = [].slice.call(arguments, 2);\n        if (events.indexOf(name) > -1) {\n          if (instance.handlers[name] && instance.handlers[name] instanceof Array) {\n            forEach(instance.handlers[name], function (handle) {\n              window.setTimeout(function () {\n                handle.callback.apply(handle.context, args);\n              }, 0);\n            });\n          }\n        } else {\n          throw new Error(name + ' event cannot be found on TreeView.');\n        }\n      }",
  "function ScrollAction(opt_callback, opt_distance_func) {\n    var self = this;\n\n    this.beginMeasuringHook = function() {}\n    this.endMeasuringHook = function() {}\n\n    this.callback_ = opt_callback;\n    this.distance_func_ = opt_distance_func;\n  }",
  "function makeHooksSafe(routes, store) {\n  if (Array.isArray(routes)) {\n    return routes.map(route => makeHooksSafe(route, store));\n  }\n\n  const onEnter = routes.onEnter;\n\n  if (onEnter) {\n    routes.onEnter = function safeOnEnter(...args) {\n      try {\n        store.getState();\n      } catch (err) {\n        if (onEnter.length === 3) {\n          args[2]();\n        }\n\n        // There's no store yet so ignore the hook\n        return;\n      }\n\n      onEnter.apply(null, args);\n    };\n  }\n\n  if (routes.childRoutes) {\n    makeHooksSafe(routes.childRoutes, store);\n  }\n\n  if (routes.indexRoute) {\n    makeHooksSafe(routes.indexRoute, store);\n  }\n\n  return routes;\n}",
  "function(id) {\n            var existing = doc.getElementById(id);\n            if (existing) {\n                existing.parentNode.removeChild(existing);\n            }\n        }",
  "function(target, dd, e, dragData) {\n        delete this.dropOK;\n        if (!target) {\n            return;\n        }\n\n//      Check that a field is being dragged.\n        var f = dragData.field;\n        if (!f) {\n            return;\n        }\n\n//      Check whether the data type of the column being dropped on accepts the\n//      dragged field type. If so, set dropOK flag, and highlight the target node.\n        var type = target.record.fields.get(target.fieldName).type,\n            types = Ext.data.Types;\n        switch(type){\n            case types.FLOAT:\n            case types.INT:\n                if (!f.isXType('numberfield')) {\n                    return;\n                }\n                break;\n            case types.DATE:\n                if (!f.isXType('datefield')) {\n                    return;\n                }\n                break;\n            case types.BOOL:\n                if (!f.isXType('checkbox')) {\n                    return;\n                }\n        }\n        this.dropOK = true;\n        Ext.fly(target.node).addCls('x-drop-target-active');\n    }",
  "function contentsToDisplay(req, res, scsId, scId = 0, cb) {\n  var zlSiteContentIn = app.models.zlSiteContentIn;\n  var Role = app.models.Role;\n  var compMod = require('./helpers/component-from-model')(app);\n\n  // emit that content was requested\n  if (res.locals.emiter.emit(`fetching content ${scsId}`, cb)) {\n    // if a package listen, it is responsible for callback\n    // also enable using scsId that is not in db to not cause error\n    return;\n  }\n\n  var { themeData } = res.locals;\n\n  // first, make sure they are allowed to view page\n  // get role permission for page\n  let filter = {fields: {scsPermission: true, zlSiteId: true}};\n  app.models.zlSiteContentSet.findById(scsId, filter, (err, scs) => {\n    if (err || !scs) return cb(`page does not exist`);\n    let ctx = app.locals.authCtx(req, res);\n    Role.isInRole(scs.scsPermission, ctx, (err, isInRole) => {\n      if (isInRole) {\n        // filter for model search\n        let filter = {\n          fields: {scId: true},\n          include: {\n            relation: 'zlSiteContent',\n            scope: {\n              where: {scStatus: 'publish', zlSiteId: res.locals.zlSite.zsId},\n            },\n          },\n          where: {scsId: scsId},\n        };\n        zlSiteContentIn.find(filter, (err, data) => {\n          // to keep list of promises\n          var promises = [];\n          // functions in component-from-model may need to make promises\n          compMod.promises = promises;\n\n          _.forEach(data, function(val, key) {\n            if (!val || !val.zlSiteContent) return data.splice(key, 1);\n            // converts from loopback object to json\n            val = val.toJSON().zlSiteContent;\n            if ('page content' === val.scType) {\n              // overide data to this value\n              data = val.scContent;\n              // iterate list of page content\n              if (_.isArray(data)) {\n                _.forEach(data, function(subVal, subKey) {\n                  // make sure there is a scId\n                  subVal.scId = (subVal.scId)?subVal.scId:`pg${scsId}-cont${subKey}`;\n\n                  prepContent(req, res, data, subVal, subKey, promises,\n                    compMod, scsId, cb);\n                });\n              }\n              // end here since only 1 active content list is used\n              return false;\n            } else {\n              // other type (like 'post' but not yet used anywhere)\n              data[key] = val.scContent;\n              prepContent(req, res, data, val.scContent, key, promises,\n                compMod, scsId, cb);\n            }\n          });\n          // emit that content loaded; allowing other sources to populate further\n          res.locals.emiter.emit(`loaded content ${scsId}`, data, promises);\n          // when all promise met, callback\n          Promise.all(promises).then(values => {\n            cb(null, data);\n          });\n        });\n      } else cb('Page Authorization failed');\n    });\n  });\n\n  compMod.themeData = themeData;\n}",
  "function sendPacket(socket, srcMAC, type, serverIP, yourIP) {\n  // Request info option\n  const opt55 = {\n    id: 55,\n    bytes: [\n      1, // subnet\n      3, // router\n      6, // dns\n    ],\n  };\n\n  let options;\n  if (serverIP && yourIP) {\n    const opt54 = {\n      id: 54,\n      bytes: [serverIP.a, serverIP.b, serverIP.c, serverIP.d],\n    };\n    const opt50 = {\n      id: 50,\n      bytes: [yourIP.a, yourIP.b, yourIP.c, yourIP.d],\n    };\n    options = [opt55, opt54, opt50];\n  } else {\n    options = [opt55];\n  }\n\n  const u8 = dhcpPacket.create(type, srcMAC, options);\n  socket.send(IP4Address.BROADCAST, 67, u8);\n}",
  "function endsWith(data, str) {\n    if (data.length < str.length) return false;\n    if (data === str) return true;\n    return data.lastIndexOf(str) === data.length - str.length;\n}",
  "function templatesFromStream(templateStream) {\n        var firstTemplate = null;\n        templateStream.on('data', function(file) {\n            var relpath = file.relative;\n            var deferred;\n            if (registry.hasOwnProperty(relpath)) {\n                deferred = registry[relpath];\n            } else {\n                deferred = registry[relpath] = new Deferred();\n            }\n            try {\n                if (!file.isBuffer()) {\n                    throw pluginError('Template source must be buffer');\n                }\n                var template = compile({\n                    data: file.contents.toString(),\n                    name: file.path,\n                    path: file.path\n                });\n                deferred.resolve(template);\n                if (firstTemplate === null) {\n                    firstTemplate = template;\n                } else {\n                    firstTemplate = false;\n                    theOnlyTemplate.reject(pluginError('Multiple templates given, must select one'));\n                }\n            } catch(err) {\n                deferred.reject(err);\n            }\n        }).on('end', function() {\n            if (firstTemplate)\n                theOnlyTemplate.resolve(firstTemplate);\n            else\n                theOnlyTemplate.reject(pluginError('No templates in template stream'));\n            noMoreTemplates();\n        }).on('error', function(err) {\n            templateStreamError = err;\n            noMoreTemplates();\n        });\n    }",
  "function ValidationErrors(errors) {\n  this.errors = errors ? errors : {};\n\n  this.addError = function(field, message) {\n    if (!this.errors[field]) { this.errors[field] = []; }\n    this.errors[field].push(util.format(message, field));\n  };\n\n  // omit field for full hash of errors\n  this.getErrors = function(field) {\n    if (field) {\n      return this.errors[field];\n    } else {\n      return this.errors;\n    }\n  };\n\n  this.hasErrors = function() {\n    return _.keys(this.errors).length > 0;\n  };\n\n  this.isValidationErrors = function() {\n    return true;\n  };\n}",
  "function fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\t\t\n\t\t_.each(colorStops, function(cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i)\n\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs))\n\t\t\t\tcs.position = 1;\n\t\t\t\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function(cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}",
  "function createTableGrid(node) {\n\t\t\t\tvar selection = ed.selection, tblElm = ed.dom.getParent(node || selection.getNode(), 'table');\n\n\t\t\t\tif (tblElm)\n\t\t\t\t\treturn new TableGrid(tblElm, ed.dom, selection);\n\t\t\t}",
  "function get(self, steamObj, key) {\n    steamObj = steamObj || {};\n    if (steamObj[key] !== undefined) {\n        return steamObj[key];\n    }\n    else if (self[key] !== undefined) {\n        return self[key];\n    }\n    else if (Steam[key] !== undefined) {\n        return Steam[key];\n    }\n    else {\n        throw new Error(\"Missing required field: \"+key);\n    }\n}",
  "function constructProfile(firstName, lastName, email, login, mobilePhone, customAttribs) {\n    var profile = {};\n    profile.login = (login ? login : email);\n    profile.email = email;\n    profile.firstName = firstName;\n    profile.lastName = lastName;\n    profile.mobilePhone = mobilePhone;\n    if(customAttribs != undefined) {\n        for(prop in customAttribs) {\n            profile[prop] = customAttribs[prop];\n        }\n    }\n    return profile;\n}",
  "function makeThresholdsSieve(options, defaults) {\n\n\tif (!options) options = {};\n\n\t// Pre-apply defaults.\n\tObject.keys(defaults).forEach(key => options[key] || (options[key] = defaults[key]));\n\n\treturn (key, overrides) => {\n\t\tif (overrides && overrides[key] !== void 0) return overrides[key];\n\t\treturn options[key];\n\t}\n}",
  "function zset(obj, vonly) {\n  var vtype = this.type(3)\n    , key = !vonly ? this.getStringBuffer(obj.key) : new Buffer(0)\n    , length = obj.length !== undefined\n        ? obj.length : Object.keys(obj.value).length\n    , len = this.getLengthEncoding(length, false)\n    , value = this.object(obj.value);\n  return Buffer.concat(\n    [\n      vtype,\n      key,\n      len,\n      value\n    ],\n    vtype.length + key.length + len.length + value.length\n  )\n}",
  "function showValidation(feedback) {\n  feedback.errors.forEach(function (error) {\n    console.log('ERROR: ' + error);\n  });\n  feedback.warnings.forEach(function (warning) {\n    console.log('WARNING: ' + warning);\n  });\n  console.log(\"Validator finished with \" + feedback.warnings.length + \" warnings and \" + feedback.errors.length + \" errors.\");\n  process.exit(feedback.errors.length > 0 ? 2 : 0);\n}",
  "function skipUntil(predicate) {\r\n    return function* (iterable) {\r\n        let i = 0;\r\n        let canReturn = false;\r\n        for (const item of iterable) {\r\n            if (!canReturn) {\r\n                canReturn = predicate(item, i);\r\n                if (canReturn) {\r\n                    yield item;\r\n                }\r\n                i = i + 1;\r\n            }\r\n            else {\r\n                yield item;\r\n            }\r\n        }\r\n    };\r\n}",
  "function findRecorder(div, selector) {\n  if (!div) {\n    if (!RecordingContext.recorders) {\n      throw 'You must call RecordingContext.recordAll() before using other RecordingContext static methods';\n    } else if (RecordingContext.recorders.length == 0) {\n      throw 'Called a RecordingContext method, but no canvases are being recorded.';\n    } else if (RecordingContext.recorders.length > 1) {\n      throw 'Called a RecordingContext method while multiple canvases were being recorded. Specify one using a div and selector.';\n    } else {\n      return RecordingContext.recorders[0][1];\n    }\n  } else {\n    return RecordingContext.recorderForSelector(div, selector);\n  }\n}",
  "function _prepopulate_metadata(_arg, _cb) {\n        var entry;\n        try {\n            entry = JSON.parse(_arg);\n        } catch (e) {\n            _cb();\n            return;\n        }\n\n        var nm = path.join(entry.parent, entry.name);\n\n        var k = sprintf(FILES_KEY_FMT, nm);\n\n        // if already in LRU cache, return\n        var stats = self.cache.get(k);\n        if (stats) {\n            _cb();\n            return;\n        }\n\n        self.db.get(k, function (err, val) {\n            // if already in db, return\n            if (!err) {\n                _cb();\n                return;\n            }\n\n            var fh = uuid.v4();\n            var info;\n            var cfile = path.join(self.location, 'fscache', fh);\n            if (entry.type !== 'directory') {\n                info = {\n                    name: entry.name,\n                    extension: 'bin',\n                    type: 'application/octet-stream',\n                    size: entry.size,\n                    headers: {\n                        'last-modified': entry.mtime\n                    },\n                    _fhandle: fh,\n                    _cacheFile: cfile,\n                    last_stat: now\n                };\n\n            } else {\n                info = {\n                    name: entry.name,\n                    extension: 'directory',\n                    type: 'application/x-json-stream; type=directory',\n                    headers: {\n                        'last-modified': entry.mtime,\n                        'result-set-size': 3\n                    },\n                    last_modified: entry.mtime,\n                    _fhandle: fh,\n                    _cacheFile: cfile,\n                    last_stat: now\n                };\n            }\n\n            var k1 = sprintf(FHANDLE_KEY_FMT, nm);\n            var k2 = sprintf(FNAME_KEY_FMT, fh);\n\n            self.db.batch()\n                .put(k, info)\n                .put(k1, fh)\n                .put(k2, nm)\n                .write(function (err2) {\n                    if (!err2)\n                        self.cache.set(k, info);\n                    _cb();\n                });\n        });\n    }",
  "function processPointerPosition(e) {\n    var xOffset = e.clientX,\n        yOffset = e.clientY;\n\n    var radius = this.rect.width / 2;\n    this.lastValue = this.value;\n\n    if (!this.usesRotation) {\n      if (this.lastPosition !== -1) {\n        //this.__value -= ( yOffset - this.lastPosition ) / (radius * 2);\n        this.__value = 1 - yOffset / this.rect.height;\n      }\n    } else {\n      var xdiff = radius - xOffset;\n      var ydiff = radius - yOffset;\n      var angle = Math.PI + Math.atan2(ydiff, xdiff);\n      this.__value = (angle + Math.PI * 1.5) % (Math.PI * 2) / (Math.PI * 2);\n\n      if (this.lastRotationValue > .8 && this.__value < .2) {\n        this.__value = 1;\n      } else if (this.lastRotationValue < .2 && this.__value > .8) {\n        this.__value = 0;\n      }\n    }\n\n    if (this.__value > 1) this.__value = 1;\n    if (this.__value < 0) this.__value = 0;\n\n    this.lastRotationValue = this.__value;\n    this.lastPosition = yOffset;\n\n    var shouldDraw = this.output();\n\n    if (shouldDraw) this.draw();\n  }",
  "function proxyDataGetter(ctx, prop) {\n    let proxyProps = ctx.__proxyProps;\n    proxyProps || (proxyProps = ctx.__proxyProps = {});\n    if (proxyProps[prop]) {\n        return;\n    }\n\n    proxyProps[prop] = true;\n\n    let descriptor = Object.getOwnPropertyDescriptor(ctx, prop);\n    if (descriptor && descriptor.configurable) {\n        let newDescriptor = Object.assign({}, descriptor, {\n            get() {\n                ctx.__deps && ctx.__deps.push(prop);\n                return descriptor.get && descriptor.get.call(ctx);\n            }\n        });\n        Object.defineProperty(ctx, prop, newDescriptor);\n    }\n    else {\n        console.warn('cannot configure the data prop descriptor info:', prop);\n    }\n}",
  "function readUint64(buffer, offset) {\n  var hi = (buffer[offset] << 24 |\n            buffer[offset + 1] << 16 |\n            buffer[offset + 2] << 8 |\n            buffer[offset + 3] << 0) >>> 0;\n  var lo = (buffer[offset + 4] << 24 |\n            buffer[offset + 5] << 16 |\n            buffer[offset + 6] << 8 |\n            buffer[offset + 7] << 0) >>> 0;\n  return hi * 0x100000000 + lo;\n}",
  "function(type, content, textAfter, state) {\n                  if (this.jsonMode) {\n                    return /^[\\[,{]$/.test(content) || /^}/.test(textAfter);\n                  } else {\n                    if (content == \";\" && state.lexical && state.lexical.type == \")\") return false;\n                    return /^[;{}]$/.test(content) && !/^;/.test(textAfter);\n                  }\n                }",
  "function publish(bundleId, pathsNotFound) {\n\t      // exit if id isn't defined\n\t      if (!bundleId) return;\n\t      var q = bundleCallbackQueue[bundleId]; // cache result\n\n\t      bundleResultCache[bundleId] = pathsNotFound; // exit if queue is empty\n\n\t      if (!q) return; // empty callback queue\n\n\t      while (q.length) {\n\t        q[0](bundleId, pathsNotFound);\n\t        q.splice(0, 1);\n\t      }\n\t    }",
  "function TextfontCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length > 2) {\n        this.family = parsed.args[0];\n        this.style = parsed.args[1];\n        this.size = parsed.args[2];\n    } else if (parsed.args.length > 1) {\n        this.familyOrStyle = parsed.args[0];\n        this.size = parsed.args[1];\n    } else if (parsed.args.length > 0) {\n        var arg = parsed.args[0];\n        if (arg.child.type === 'string' || arg.child instanceof statements.StringStatement) this.familyOrStyle = arg;\n        else this.size = arg;\n    } else {\n        this.reset = true;\n    }\n}",
  "function(columns) {\n        var i,\n            len = columns.length,\n            column;\n\n        for (i = 0; i < len; i++) {\n            column = columns[i];\n            if (!column.processed && column.locked) {\n                return true;\n            }\n        }\n    }",
  "function makePath(dirPath) {\n    dirPath = path.dirname(dirPath).split(path.sep)\n    dirPath.reduce(function(dirPath, p) {\n        dirPath = path.join(dirPath, p)\n        if (! fs.existsSync(dirPath)) {\n            try {\n                fs.mkdirSync(dirPath)\n            } catch (e) {\n                throw 'Could not make path ' + dirPath\n            }\n        }\n        return dirPath\n    }, '')\n}",
  "function TransformStreamCloseReadable(transformStream) {\n  // console.log('TransformStreamCloseReadable()');\n\n  if (transformStream._errored === true) {\n    throw new TypeError('TransformStream is already errored');\n  }\n\n  if (transformStream._readableClosed === true) {\n    throw new TypeError('Readable side is already closed');\n  }\n\n  TransformStreamCloseReadableInternal(transformStream);\n}",
  "function recordOrderInCriteo( cart, orderId ) {\n\tif ( ! isAdTrackingAllowed() || ! isCriteoEnabled ) {\n\t\treturn;\n\t}\n\n\tconst params = [\n\t\t'trackTransaction',\n\t\t{\n\t\t\tid: orderId,\n\t\t\tcurrency: cart.currency,\n\t\t\titem: cartToCriteoItems( cart ),\n\t\t},\n\t];\n\tdebug( 'recordOrderInCriteo:', params );\n\trecordInCriteo( ...params );\n}",
  "function(str, delim) {\n      var res = []; \n      var segs = str.split(delim);\n      var accum = '';\n      for (let i = 0; i < segs.length; i++) {\n        var seg = segs[i];\n        if (seg.endsWith('\\\\')) {\n          accum += seg.substring(0, seg.length - 1) + delim;\n        }\n        else {\n          accum += seg;\n          res.push(accum);\n          accum = '';\n        }\n      }\n      return res;\n    }",
  "function (event) {\n    var target = event.target;\n    if ((target !== absoluteAnchor) && !util.isChildOf(target, absoluteAnchor)) {\n      destroy();\n    }\n  }",
  "function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}",
  "function isObject(obj) {\n  // incase of arrow function and array\n  return Object(obj) === obj && String(obj) === '[object Object]' && !isFunction(obj) && !isArray(obj);\n}",
  "function getTextContent(node) {\n  if (isCommentNode(node)) {\n    return node.data || '';\n  }\n  if (isTextNode(node)) {\n    return node.value || '';\n  }\n  var subtree = nodeWalkAll(node, isTextNode);\n  return subtree.map(getTextContent).join('');\n}",
  "function nextchild(compare, a, i, j) {\n\n  if (j - i < 2) return i;\n\n  if (compare(a[i], a[i + 1]) <= 0) return i;\n\n  return i + 1;\n}",
  "function _getRoundedValue3D(prop, def, precision, lockValue) {\n        if (!prop || !prop.init) {\n            return def;\n        }\n        return [\n            prop.enabled[0] ? (Math.round((prop.curState.x + ((prop.endState.x - prop.curState.x) * lockValue)) / precision) * precision) : prop.endState.x,\n            prop.enabled[1] ? (Math.round((prop.curState.y + ((prop.endState.y - prop.curState.y) * lockValue)) / precision) * precision) : prop.endState.y,\n            prop.enabled[2] ? (Math.round((prop.curState.z + ((prop.endState.z - prop.curState.z) * lockValue)) / precision) * precision) : prop.endState.z\n        ];\n    }",
  "function writeBuffer(buffer) {\n  var written = fs.writeSync(this.fd, buffer, 0, buffer.length, null);\n  fs.fsyncSync(this.fd);\n  return written;\n}",
  "function(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\t\t\t\n\t\t\trequire('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}",
  "function changeData(state, sourceName, data) {\n  const source = state.sources[sourceName];\n  if (!source) {\n    return state;\n  }\n  const src_mixin = {};\n\n  // update the individual source.\n  src_mixin[sourceName] = Object.assign({}, source, {\n    data,\n  });\n\n  // kick back the new state.\n  return Object.assign({}, state, {\n    sources: Object.assign({}, state.sources, src_mixin),\n  }, incrementVersion(state.metadata, dataVersionKey(sourceName)));\n}",
  "function (data, arr, options) {\n  return arr.map(function(lookup) {\n    return expander.process(data, lookup, options);\n  });\n}",
  "function CreateSetPolyfill() {\n            return /** @class */ (function () {\n                function Set() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set.prototype, \"size\", {\n                    get: function () { return this._map.size; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set.prototype.has = function (value) { return this._map.has(value); };\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\n                Set.prototype.clear = function () { this._map.clear(); };\n                Set.prototype.keys = function () { return this._map.keys(); };\n                Set.prototype.values = function () { return this._map.values(); };\n                Set.prototype.entries = function () { return this._map.entries(); };\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n                return Set;\n            }());\n        }",
  "function(ev) {\n        this.cliView.cli.update({\n            typed: this.request.typed,\n            cursor: { start:0, end:0 }\n        });\n        this.cliView.cli.exec();\n    }",
  "function(key) {\n        var me = this,\n            value;\n\n        if (me.containsKey(key)) {\n            value = me.map[key];\n            delete me.map[key];\n            --me.length;\n            if (me.hasListeners.remove) {\n                me.fireEvent('remove', me, key, value);\n            }\n            return true;\n        }\n        return false;\n    }",
  "function pos(el) {\n    var o = { x:el.offsetLeft, y:el.offsetTop }\n    while((el = el.offsetParent))\n      o.x+=el.offsetLeft, o.y+=el.offsetTop\n\n    return o\n  }",
  "function(data) {\n    if (this.app) {\n      data._app = this.app;\n    }\n    if (this.model) {\n      data._model = this.model;\n    }\n    if (this.collection) {\n      data._collection = this.collection;\n    }\n    data._view = this;\n    return data;\n  }",
  "function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t}",
  "function processInitialData(value, name) {\n            if (name == View.prototype.modelName) {\n                options.model = def.models[name].unique(value);\n            } else if (def.models[name]) {\n                    options.data[name] = def.models[name].unique(value);\n            } else {\n                    options.data[name] = value;\n            }\n        }",
  "function parseImports(data, file, extensions) {\n\n\tconst imports = [];\n\n\tlet result = importRegExp.exec(data);\n\tlet encoding;\n\n\twhile(result !== null) {\n\n\t\tencoding = extensions[path.extname(result[2])];\n\n\t\t// Filter irrelevant imports.\n\t\tif(encoding !== undefined) {\n\n\t\t\timports.push(new FileImport(\n\t\t\t\tresult.index,\n\t\t\t\timportRegExp.lastIndex,\n\t\t\t\tresult[1],\n\t\t\t\tpath.resolve(path.dirname(file), result[2]),\n\t\t\t\tencoding\n\t\t\t));\n\n\t\t}\n\n\t\tresult = importRegExp.exec(data);\n\n\t}\n\n\treturn Promise.resolve([imports, data]);\n\n}",
  "function rename(obj) {\n  return rename_(function(parsedPath) {\n    return {\n      extname: obj.extname || parsedPath.extname,\n      dirname: (obj.dirnamePrefix || '') + parsedPath.dirname,\n      basename: parsedPath.basename\n    };\n  });\n}",
  "function _endTransferableAnimations(item) {\n        for (var j = 0; j < item.transferables.length; j++) {\n            var transferable = item.transferables[j];\n            for (var i = 0; i < this._renderables.transferables.length; i++) {\n                if (this._renderables.transferables[i] === transferable.renderNode) {\n                    this._renderables.transferables.splice(i, 1);\n                    break;\n                }\n            }\n            transferable.source.show(transferable.originalSource);\n            transferable.target.show(transferable.originalTarget);\n        }\n        item.transferables = [];\n        this.layout.reflowLayout();\n    }",
  "function(fireEvent) {\n        var me = this;\n        if (fireEvent && !me.bulkChange) {\n            me.fireEvent('selectionchange', me, me.getSelection());\n        }\n    }",
  "function (rootPath) {\n\t// public properties\n\tthis.plugins = {};\n\tthis.mainTree = {};\n\tthis.groups = {};\n\tthis.resolved = false;\n\tif (rootPath) {\n\t\tif (typeof rootPath !== 'string') {\n\t\t\tthrow new Error( 'Invalid rootPath parameter creating tree' );\n\t\t}\n\t\tthis.rootPath = rootPath;\n\t} else {\n\t\t// no argument passed\n\t\tthis.rootPath = '.';\n\t}\n}",
  "function(e) {\n\t\t\te.data.handler.over = true;\n\t\t\t$.iframeTracker.retrieveFocus();\n\t\t\ttry {\n\t\t\t\te.data.handler.overCallback(this, e);\n\t\t\t} catch (ex) {}\n\t\t}",
  "function handleError(req, res, err) {\n    switch (err.name) {\n      case 'NotFoundError':\n        render(req, res, 'error', err, {status: 404});\n        break;\n      default:\n        render(req, res, 'error', err, {status: 500});\n    }\n  }",
  "function patchFileObjects( formData ) {\n\t// There are several landmines to avoid when making file uploads work on all browsers:\n\t// - the `new File()` constructor trick breaks file uploads on Safari 10 in a way that's\n\t//   impossible to detect: it will send empty files in the multipart/form-data body.\n\t//   Therefore we need to detect Chrome.\n\t// - IE11 and Edge don't support the `new File()` constructor at all. It will throw exception,\n\t//   so it's detectable by the `supportsFileConstructor` code.\n\t// - `window.chrome` exists also on Edge (!), `window.chrome.webstore` is only in Chrome and\n\t//   not in other Chromium based browsers (which have the site isolation bug, too).\n\tif ( ! window.chrome || ! supportsFileConstructor ) {\n\t\treturn;\n\t}\n\n\tfor ( let i = 0; i < formData.length; i++ ) {\n\t\tconst val = getFileValue( formData[ i ][ 1 ] );\n\t\tif ( val ) {\n\t\t\tformData[ i ][ 1 ] = new File( [ val ], val.name, { type: val.type } );\n\t\t}\n\t}\n}",
  "function filterFunctionWordsAnywhere( wordCombinations, functionWords ) {\n\treturn wordCombinations.filter( function( combination ) {\n\t\treturn isEmpty(\n\t\t\tintersection( functionWords, combination.getWords() )\n\t\t);\n\t} );\n}",
  "function optOnIconMouseDownListener (e) { // outlineIcons.src.icon_opton  needed?\n    var target = thisOutline.targetOf(e)\n    var p = target.parentNode\n    termWidget.replaceIcon(p.parentNode,\n      outlineIcons.termWidgets.optOn,\n      outlineIcons.termWidgets.optOff, optOffIconMouseDownListener)\n    p.parentNode.parentNode.removeAttribute('optional')\n  }",
  "function forEach(declarations, reqName, callback) {\n        var d;\n        if (reqName === \"*\") {\n            // Iterate over all declarations.\n            for (d in declarations) {\n                callback.call(this, d);\n            }\n        } else if (reqName.charAt(reqName.length - 1) === \"*\") {\n            // Iterate over uncapped `*` declarations.\n            var baseName = reqName.substring(0, reqName.length - 1);\n            for (d in declarations) {\n                if (d.indexOf(baseName) === 0) {\n                    callback.call(this, d);\n                }\n            }\n        } else {\n            // A single dependency iteration.\n            if (declarations[reqName]) {\n                callback.call(this, reqName);\n            } else {\n                error(\"Invalid dependency '\" + reqName + \"'\");\n            }\n        }\n    }",
  "function _processAnimations(event) {\n        var prevItem;\n        for (var i = 0; i < this._viewStack.length; i++) {\n            var item = this._viewStack[i];\n            switch (item.state) {\n                case ItemState.HIDE:\n                    item.state = ItemState.HIDING;\n                    _initHideAnimation.call(this, item, prevItem, event.size);\n                    _updateState.call(this);\n                    break;\n                case ItemState.SHOW:\n                    item.state = ItemState.SHOWING;\n                    _initShowAnimation.call(this, item, prevItem, event.size);\n                    _updateState.call(this);\n                    break;\n            }\n            prevItem = item;\n        }\n    }",
  "function getLogicalPartitions(disk, index, offset, extendedPartitionOffset, limit) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (extendedPartitionOffset === undefined) {\n            extendedPartitionOffset = offset;\n        }\n        if (limit === undefined) {\n            limit = Infinity;\n        }\n        const result = [];\n        if (limit <= 0) {\n            return result;\n        }\n        const buf = yield readFromDisk(disk, offset, MBR_SIZE);\n        for (const p of getPartitionsFromMBRBuf(buf)) {\n            if (!p.extended) {\n                result.push(mbrPartitionDict(p, offset, index));\n            }\n            else if (limit > 0) {\n                const logicalPartitions = yield getLogicalPartitions(disk, index + 1, extendedPartitionOffset + p.byteOffset(), extendedPartitionOffset, limit - 1);\n                result.push(...logicalPartitions);\n                return result;\n            }\n        }\n        return result;\n    });\n}",
  "async function downloadLibtensorflow(callback) {\n  // Ensure dependencies staged directory is available:\n  await ensureDir(depsPath);\n\n  console.warn('* Downloading libtensorflow');\n  resources.downloadAndUnpackResource(\n      getPlatformLibtensorflowUri(), depsPath, async () => {\n        if (platform === 'win32') {\n          // Some windows libtensorflow zip files are missing structure and the\n          // eager headers. Check, restructure, and download resources as\n          // needed.\n          const depsIncludePath = path.join(depsPath, 'include');\n          if (!await exists(depsLibTensorFlowPath)) {\n            // Verify that tensorflow.dll exists\n            const libtensorflowDll = path.join(depsPath, 'tensorflow.dll');\n            if (!await exists(libtensorflowDll)) {\n              throw new Error('Could not find libtensorflow.dll');\n            }\n\n            await ensureDir(depsLibPath);\n            await rename(libtensorflowDll, depsLibTensorFlowPath);\n          }\n\n          // Next check the structure for the C-library headers. If they don't\n          // exist, download and unzip them.\n          if (!await exists(depsIncludePath)) {\n            // Remove duplicated assets from the original libtensorflow package.\n            // They will be replaced by the download below:\n            await unlink(path.join(depsPath, 'c_api.h'));\n            await unlink(path.join(depsPath, 'LICENSE'));\n\n            // Download the C headers only and unpack:\n            resources.downloadAndUnpackResource(\n                TF_WIN_HEADERS_URI, depsPath, () => {\n                  if (callback !== undefined) {\n                    callback();\n                  }\n                });\n          } else {\n            if (callback !== undefined) {\n              callback();\n            }\n          }\n        } else {\n          // No other work is required on other platforms.\n          if (callback !== undefined) {\n            callback();\n          }\n        }\n      });\n}",
  "function(options) {\n          var self = this\n          var result = []\n          if (options._id) {\n            var id = Array.isArray(options._id) ? options._id : [options._id]\n            id.forEach(function(id) {\n              if (self.cache[id]) {\n                result.push(self.cache[id])\n              }\n            })\n          } else {\n            result = Object.keys(this.cache).map(function(k) {\n              return self.cache[k]\n            }).sort(function(count1, count2) {\n              return count1._id - count2._id\n            })\n            if (options.skip || options.limit) {\n              var skip = options.skip || 0\n              var limit = options.limit || 0\n              return result.slice(skip, skip + limit)\n            }\n          }\n          return result\n        }",
  "function(key, value) {\n        // if we have no value, it means we need to get the key from the object\n        if (value === undefined) {\n            value = key;\n            key = this.getKey(value);\n        }\n\n        return [key, value];\n    }",
  "function updateLastSeenTime( proposedTime, fromStorage ) {\n\tlet fromNote = false;\n\tlet mostRecentNoteTime = 0;\n\n\t// Make sure we aren't getting milliseconds\n\t// The check time is Aug 8, 2005 in ms\n\tif ( proposedTime > 1123473600000 ) {\n\t\tproposedTime = proposedTime / 1000;\n\t}\n\n\tdebug( 'updateLastSeenTime 0', {\n\t\tproposedTime: proposedTime,\n\t\tfromStorage: fromStorage,\n\t\tlastSeenTime: this.lastSeenTime,\n\t} );\n\n\t// Event was triggered by another tab's localStorage.setItem; ignore localStorage and remote.\n\tif ( fromStorage ) {\n\t\tif ( proposedTime <= this.lastSeenTime ) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.lastSeenTime = proposedTime;\n\t\treturn true;\n\t}\n\n\tconst notes = getAllNotes( store.getState() );\n\tif ( notes.length ) {\n\t\tmostRecentNoteTime = Date.parse( notes[ 0 ].timestamp ) / 1000;\n\t}\n\n\tdebug( 'updateLastSeenTime 1', {\n\t\tproposedTime: proposedTime,\n\t\tshowing: this.showing,\n\t\tvisible: this.visible,\n\t\tlastSeenTime: this.lastSeenTime,\n\t\tmostRecentNoteTime: mostRecentNoteTime,\n\t} );\n\n\t// Advance proposedTime to the latest visible note time.\n\tif ( this.isShowing && this.isVisible && mostRecentNoteTime > proposedTime ) {\n\t\tproposedTime = mostRecentNoteTime;\n\t\tfromNote = true;\n\t}\n\n\tdebug( 'updateLastSeenTime 2', {\n\t\tproposedTime: proposedTime,\n\t\tfromNote: fromNote,\n\t\toldNews: proposedTime <= this.lastSeenTime,\n\t} );\n\n\t// Ignore old news.\n\tif ( proposedTime <= this.lastSeenTime ) {\n\t\treturn false;\n\t}\n\n\tthis.lastSeenTime = proposedTime;\n\n\ttry {\n\t\tlocalStorage.setItem( 'notesLastMarkedSeen', this.lastSeenTime );\n\t} catch ( e ) {}\n\n\t// Update the database only if an unseen note has become visible.\n\tif ( fromNote ) {\n\t\tdebug( 'updateLastSeenTime 3', this.lastSeenTime );\n\t\tsendLastSeenTime( this.lastSeenTime );\n\t}\n\n\treturn true;\n}",
  "function strip_ignored_bytes(octets) {\n        for (var o=octets.length-1; o>=0; o--) {\n            switch (octets[o]) {\n                case XON:\n                case XON_HIGH:\n                case XOFF:\n                case XOFF_HIGH:\n                    octets.splice(o, 1);\n                    continue;\n            }\n        }\n\n        return octets;\n    }",
  "function moduleCommand(shell, args, data, evaluationId) {\n  var deferred = shell.runtime.q.defer();\n\n  installer.install(args.name, shell.config.userPath, /* quiet */ false, function(error) {\n    if (error) {\n      deferred.reject(shell.createError('Could not install module'));\n    }\n    else {\n      shell.installedModules[args.name] = true;\n      deferred.resolve();\n    }\n  });\n\n  return deferred.promise;\n}",
  "function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    var filteredAST = cloneDeep(abstractSyntaxTree);\n    var astRules = abstractSyntaxTree.nodes[0];\n    var selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = mergeWith(\n        cloneDeep(allowedStyles[astRules.selector]),\n        allowedStyles['*'],\n        function(objValue, srcValue) {\n          if (Array.isArray(objValue)) {\n            return objValue.concat(srcValue);\n          }\n        }\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      filteredAST.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return filteredAST;\n  }",
  "function listRecusively (marker) {\n    options.marker = marker;\n\n    self.listObjectsPage(\n      options,\n      function (error, nextMarker, s3Objects) {\n        if (error) {\n          return callback(error);\n        }\n\n        // Send all of these S3 object definitions to be piped onwards.\n        s3Objects.forEach(function (object) {\n          object.Bucket = options.bucket;\n          self.push(object);\n        });\n\n        if (nextMarker) {\n          listRecusively(nextMarker);\n        }\n        else {\n          callback();\n        }\n      }\n    );\n  }",
  "function setFocus() {\n\t  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t  var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t  if (!is$1.element(element)) {\n\t    return;\n\t  } // Set regular focus\n\n\n\t  element.focus({\n\t    preventScroll: true\n\t  }); // If we want to mimic keyboard focus via tab\n\n\t  if (tabFocus) {\n\t    toggleClass(element, this.config.classNames.tabFocus);\n\t  }\n\t}",
  "function sortCombinations( wordCombinations ) {\n\twordCombinations.sort( function( combinationA, combinationB ) {\n\t\tconst difference = combinationB.getRelevance() - combinationA.getRelevance();\n\t\t// The combination with the highest relevance comes first.\n\t\tif ( difference !== 0 ) {\n\t\t\treturn difference;\n\t\t}\n\t\t// In case of a tie on relevance, the longest combination comes first.\n\t\treturn combinationB.getLength() - combinationA.getLength();\n\t} );\n}",
  "function(store, columns) {\n        var me = this,\n            oldStore = me.store,\n            lockedGrid = me.lockedGrid,\n            normalGrid = me.normalGrid;\n\n        Ext.suspendLayouts();\n        if (columns) {\n            lockedGrid.headerCt.removeAll();\n            normalGrid.headerCt.removeAll();\n\n            columns = me.processColumns(columns);\n\n            // Flag to the locked column add listener to do nothing\n            me.ignoreAddLockedColumn = true;\n            lockedGrid.headerCt.add(columns.locked.items);\n            me.ignoreAddLockedColumn = false;\n            normalGrid.headerCt.add(columns.normal.items);\n\n            // Ensure locked grid is set up correctly with correct width and bottom border,\n            // and that both grids' visibility and scrollability status is correct\n            me.syncLockedWidth();\n        }\n\n        if (store && store !== oldStore) {\n            store = Ext.data.StoreManager.lookup(store);\n            me.store = store;\n            lockedGrid.bindStore(store);\n            normalGrid.bindStore(store);\n        } else {\n            lockedGrid.getView().refresh();\n            normalGrid.getView().refresh();\n        }\n        Ext.resumeLayouts(true);\n    }",
  "function setup_member(context, k) {\n\tvar handler;\n\tvar routes = context.routes;\n\tvar opts = context.opts;\n\tvar middleware = context.middleware;\n\tvar app = context.app;\n\tvar target = context.target;\n\tvar loop_counter = context.loop_counter;\n\tvar v = routes[k];\n\tvar v_is_function = is.func(v) ? true : false;\n\n\t// Special methods\n\tif(_special_methods.indexOf(k) >= 0) {\n\t\thandler = v_is_function ? v : FUNCTION(do_send).curry(opts, v);\n\t\tif(middleware.length === 0) {\n\t\t\tapp[_express_methods[k]](target, build_request(opts, handler) );\n\t\t} else if(k === 'USE') {\n\t\t\t//debug.log('target = ', target);\n\t\t\t//debug.log('k = ', k);\n\t\t\t//debug.log('_express_methods[', k,'] = ', _express_methods[k]);\n\n\t\t\tapp[_express_methods[k]](target, join_plugins( [fix_for_missing_req_route(target, 'use')].concat(middleware).concat([build_request(opts, handler)]) ) );\n\t\t} else {\n\t\t\tapp[_express_methods[k]](target, fix_for_missing_req_route(target, (''+k).toLowerCase() ), middleware, build_request(opts, handler));\n\t\t}\n\t\treturn;\n\t}\n\n\t// Functions\n\tif(process.env.DEBUG_NOR_EXPRESS) {\n\t\tdebug.log( /*(req.id ? '['+req.id+'] ' : '') + */ 'target = ', target);\n\t\tdebug.log( /*(req.id ? '['+req.id+'] ' : '') + */ 'k = ', k);\n\t}\n\n\tvar new_target = (target==='/') ? ('/' + k) : (target + '/' + k);\n\tvar new_route = ROUTES.parse(v);\n\tROUTES.setup(app, new_route, new_target, merge(opts, {'loop_counter': loop_counter+1}));\n}",
  "function executeMainProcessMethod(moduleName, methodChain, args) {\n  const theModule = electron[moduleName];\n  const path = methodChain.join('.');\n  return get(theModule, path).apply(theModule, args);\n}",
  "function(object, options) {\n          return this.collection.findOneAndReplace(\n            {_id: object._id}, object, {returnOriginal: false}).value\n        }",
  "function() {\n            var tip = this.tip;\n            if (!tip) {\n                tip = this.tip = Ext.create('Ext.tip.QuickTip', {\n                    ui: 'form-invalid'\n                });\n                tip.tagConfig = Ext.apply({}, {attribute: 'errorqtip'}, tip.tagConfig);\n            }\n        }",
  "function configureGlobals() {\n\t// Set up the global DirectlyRTM function, required for the RTM widget.\n\t// This snippet is pasted from Directly's setup code.\n\twindow.DirectlyRTM =\n\t\twindow.DirectlyRTM ||\n\t\tfunction() {\n\t\t\t( window.DirectlyRTM.cq = window.DirectlyRTM.cq || [] ).push( arguments );\n\t\t};\n\t// Since we can only configure once per pageload, this library only provides a\n\t// single global configuration.\n\twindow.DirectlyRTM( 'config', getDefaultOptions() );\n}",
  "function ArrayType(typeSpec) {\n    if (typeSpec instanceof Type) {\n        this.subtype = typeSpec;\n    }\n    else if (typeof typeSpec === 'string') {\n        this.subtype = types.getType(typeSpec);\n        if (this.subtype == null) {\n            throw new Error('Unknown array subtype: ' + typeSpec);\n        }\n    }\n    else {\n        throw new Error('Can\\' handle array subtype');\n    }\n}",
  "function addTimeToArrayFromToken(token, input, config) {\n        var a, datePartArray = config._a;\n\n        switch (token) {\n        // MONTH\n        case 'M' : // fall through to MM\n        case 'MM' :\n            datePartArray[1] = (input == null) ? 0 : ~~input - 1;\n            break;\n        case 'MMM' : // fall through to MMMM\n        case 'MMMM' :\n            a = getLangDefinition(config._l).monthsParse(input);\n            // if we didn't find a month name, mark the date as invalid.\n            if (a != null) {\n                datePartArray[1] = a;\n            } else {\n                config._isValid = false;\n            }\n            break;\n        // DAY OF MONTH\n        case 'D' : // fall through to DDDD\n        case 'DD' : // fall through to DDDD\n        case 'DDD' : // fall through to DDDD\n        case 'DDDD' :\n            if (input != null) {\n                datePartArray[2] = ~~input;\n            }\n            break;\n        // YEAR\n        case 'YY' :\n            datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2000);\n            break;\n        case 'YYYY' :\n        case 'YYYYY' :\n            datePartArray[0] = ~~input;\n            break;\n        // AM / PM\n        case 'a' : // fall through to A\n        case 'A' :\n            config._isPm = getLangDefinition(config._l).isPM(input);\n            break;\n        // 24 HOUR\n        case 'H' : // fall through to hh\n        case 'HH' : // fall through to hh\n        case 'h' : // fall through to hh\n        case 'hh' :\n            datePartArray[3] = ~~input;\n            break;\n        // MINUTE\n        case 'm' : // fall through to mm\n        case 'mm' :\n            datePartArray[4] = ~~input;\n            break;\n        // SECOND\n        case 's' : // fall through to ss\n        case 'ss' :\n            datePartArray[5] = ~~input;\n            break;\n        // MILLISECOND\n        case 'S' :\n        case 'SS' :\n        case 'SSS' :\n            datePartArray[6] = ~~ (('0.' + input) * 1000);\n            break;\n        // UNIX TIMESTAMP WITH MS\n        case 'X':\n            config._d = new Date(parseFloat(input) * 1000);\n            break;\n        // TIMEZONE\n        case 'Z' : // fall through to ZZ\n        case 'ZZ' :\n            config._useUTC = true;\n            config._tzm = timezoneMinutesFromString(input);\n            break;\n        }\n\n        // if the input is null, the date is not valid\n        if (input == null) {\n            config._isValid = false;\n        }\n    }",
  "function (success, fail, args) {\r\n\t\targs = JSON.parse(decodeURIComponent(args[\"input\"]));\r\n\t\tvibration.getInstance().vibration_request(args);\r\n\t\tsuccess();\r\n\t}",
  "function _getOuterSize(gridSize, sizeScreen) {\n  if ('lg' === sizeScreen) {\n    if (gridSize && gridSize.lg) {\n      return gridSize.lg;\n    }\n    else if (gridSize && gridSize.md) {\n      return gridSize.md;\n    }\n    else if (gridSize && gridSize.sm) {\n      return gridSize.sm;\n    }\n    else if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  else if ('md' === sizeScreen) {\n    if (gridSize && gridSize.md) {\n      return gridSize.md;\n    }\n    else if (gridSize && gridSize.sm) {\n      return gridSize.sm;\n    }\n    else if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  else if ('sm' === sizeScreen) {\n    if (gridSize && gridSize.sm) {\n      return gridSize.sm;\n    }\n    else if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  else if ('xs' === sizeScreen) {\n    if (gridSize && gridSize.xs) {\n      return gridSize.xs;\n    }\n  }\n  // default\n  return grid;\n}",
  "function codeConfig(config) {\n  const conf = Object.create(null);\n  for (const key in config.custom) {\n    conf[key] = config.custom[key];\n  }\n  for (const key of ['host', 'port', 'backendPort']) {\n    conf[key] = config[key];\n  }\n  return conf;\n}",
  "function () {\n    var apps = {};\n    var baseUrl = configHelpers.getServerUrl();\n    Object.keys(config.apps || {}).forEach(function(name){\n      apps[name] = {\n        name: config.apps[name].name,\n        displayName: config.apps[name].displayName,\n        version: config.apps[name].version,\n        url: baseUrl + '/apps/' + config.apps[name].name + '/'\n      };\n    });\n    return apps;\n  }",
  "function readLength() {\n    var byte = delta[deltaOffset++];\n    var length = byte & 0x7f;\n    var shift = 7;\n    while (byte & 0x80) {\n      byte = delta[deltaOffset++];\n      length |= (byte & 0x7f) << shift;\n      shift += 7;\n    }\n    return length;\n  }",
  "function preprocessCartForServer( {\n\tcoupon,\n\tis_coupon_applied,\n\tis_coupon_removed,\n\tcurrency,\n\ttemporary,\n\textra,\n\tproducts,\n\ttax,\n} ) {\n\tconst needsUrlCoupon = ! (\n\t\tcoupon ||\n\t\tis_coupon_applied ||\n\t\tis_coupon_removed ||\n\t\ttypeof document === 'undefined'\n\t);\n\tconst urlCoupon = needsUrlCoupon ? url.parse( document.URL, true ).query.coupon : '';\n\n\treturn Object.assign(\n\t\t{\n\t\t\tcoupon,\n\t\t\tis_coupon_applied,\n\t\t\tis_coupon_removed,\n\t\t\tcurrency,\n\t\t\ttax,\n\t\t\ttemporary,\n\t\t\textra,\n\t\t\tproducts: products.map(\n\t\t\t\t( { product_id, meta, free_trial, volume, extra: productExtra } ) => ( {\n\t\t\t\t\tproduct_id,\n\t\t\t\t\tmeta,\n\t\t\t\t\tfree_trial,\n\t\t\t\t\tvolume,\n\t\t\t\t\textra: productExtra,\n\t\t\t\t} )\n\t\t\t),\n\t\t},\n\t\tneedsUrlCoupon &&\n\t\t\turlCoupon && {\n\t\t\t\tcoupon: urlCoupon,\n\t\t\t\tis_coupon_applied: false,\n\t\t\t}\n\t);\n}",
  "function _getNextSiblingThatIsNotBlank(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling && _isBlankTextNode(nextSibling)) {\n      nextSibling = nextSibling.nextSibling;\n    }\n    return nextSibling;\n  }",
  "function sample(collection, n, guard) {\n      var length = collection ? collection.length : 0;\n      if (typeof length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[random(length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }",
  "function LineCommand(args) {\n    var parsed = new statements.ArgumentStatement(args);\n\n    if (parsed.args.length < 4) throw new SyntaxError('LINE command requires 4 arguments');\n    this.x1 = parsed.args[0];\n    this.y1 = parsed.args[1];\n    this.x2 = parsed.args[2];\n    this.y2 = parsed.args[3];\n    this.width = parsed.args.length > 4 ? parsed.args[4] : false;\n}",
  "function _getClusterState() {\n        return k8s.list('app=teraslice', 'pods')\n            .then(k8sPods => k8sState.gen(k8sPods, clusterState, clusterNameLabel))\n            .catch((err) => {\n                // TODO: We might need to do more here.  I think it's OK to just\n                // log though.  This only gets used to show slicer info through\n                // the API.  We wouldn't want to disrupt the cluster master\n                // for rare failures to reach the k8s API.\n                logger.error(err, 'Error listing teraslice pods in k8s');\n            });\n    }",
  "function convertOfficialMap (attributes) {\n  let map = {}\n  for (let attribute in attributes) {\n    let key = officialAttributeMap[attribute]\n    map[key] = attributes[attribute]\n  }\n  return map\n}",
  "function nextVersions (options, nameVersionPairs, checkLatestOnly) {\n  check.verify.object(options, 'expected object with options')\n  check.verify.array(nameVersionPairs, 'expected array')\n  nameVersionPairs = cleanVersions(nameVersionPairs)\n\n  const verbose = verboseLog(options)\n  verbose('checking NPM registry')\n  var MAX_CHECK_TIMEOUT = options.checkVersionTimeout || 10000\n\n  var fetchPromises = nameVersionPairs.map(fetchVersions.bind(null, options))\n  var fetchAllPromise = q.all(fetchPromises)\n        .timeout(MAX_CHECK_TIMEOUT, 'timed out waiting for NPM after ' + MAX_CHECK_TIMEOUT + 'ms')\n\n  return fetchAllPromise.then(\n    _.partial(filterFetchedVersions, checkLatestOnly),\n    q.reject\n  )\n}",
  "function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tmemo = memo || [];\n\t\t\t\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-'))\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function(n) {\n\t\t\t\t\t\tif (data[n])\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\t\t\t\n\t\t\treturn matchedItem;\n\t\t}",
  "function parse_status_block(block) {\n    var match;\n\n    var parsed = {};\n    if ((match = block.match(/bssid=([A-Fa-f0-9:]{17})/))) {\n        parsed.bssid = match[1].toLowerCase();\n    }\n\n    if ((match = block.match(/freq=([0-9]+)/))) {\n        parsed.frequency = parseInt(match[1], 10);\n    }\n\n    if ((match = block.match(/mode=([^\\s]+)/))) {\n        parsed.mode = match[1];\n    }\n\n    if ((match = block.match(/key_mgmt=([^\\s]+)/))) {\n        parsed.key_mgmt = match[1].toLowerCase();\n    }\n\n    if ((match = block.match(/[^b]ssid=([^\\n]+)/))) {\n        parsed.ssid = match[1];\n    }\n\n    if ((match = block.match(/[^b]pairwise_cipher=([^\\n]+)/))) {\n        parsed.pairwise_cipher = match[1];\n    }\n\n    if ((match = block.match(/[^b]group_cipher=([^\\n]+)/))) {\n        parsed.group_cipher = match[1];\n    }\n\n    if ((match =  block.match(/p2p_device_address=([A-Fa-f0-9:]{17})/))) {\n        parsed.p2p_device_address = match[1];\n    }\n\n    if ((match = block.match(/wpa_state=([^\\s]+)/))) {\n        parsed.wpa_state = match[1];\n    }\n\n    if ((match = block.match(/ip_address=([^\\n]+)/))) {\n        parsed.ip = match[1];\n    }\n\n    if ((match = block.match(/[^_]address=([A-Fa-f0-9:]{17})/))) {\n        parsed.mac = match[1].toLowerCase();\n    }\n\n    if ((match = block.match(/uuid=([^\\n]+)/))) {\n        parsed.uuid = match[1];\n    }\n\n    if ((match = block.match(/[^s]id=([0-9]+)/))) {\n        parsed.id = parseInt(match[1], 10);\n    }\n\n    return parsed;\n}",
  "function removeAttribute(node, prop) {\n            if (node && node.el) {\n                node.el.removeAttribute(prop);\n            }\n        }",
  "function() {\n            var cid = this.containerId,\n                scroll = \"scroll.\" + cid,\n                resize = \"resize.\"+cid,\n                orient = \"orientationchange.\"+cid,\n                mask, maskCss;\n\n            this.container.addClass(\"select2-dropdown-open\").addClass(\"select2-container-active\");\n\n            this.clearDropdownAlignmentPreference();\n\n            if(this.dropdown[0] !== this.body().children().last()[0]) {\n                this.dropdown.detach().appendTo(this.body());\n            }\n\n            // create the dropdown mask if doesnt already exist\n            mask = $(\"#select2-drop-mask\");\n            if (mask.length == 0) {\n                mask = $(document.createElement(\"div\"));\n                mask.attr(\"id\",\"select2-drop-mask\").attr(\"class\",\"select2-drop-mask\");\n                mask.hide();\n                mask.appendTo(this.body());\n                mask.on(\"mousedown touchstart click\", function (e) {\n                    var dropdown = $(\"#select2-drop\"), self;\n                    if (dropdown.length > 0) {\n                        self=dropdown.data(\"select2\");\n                        if (self.opts.selectOnBlur) {\n                            self.selectHighlighted({noFocus: true});\n                        }\n                        self.close();\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                });\n            }\n\n            // ensure the mask is always right before the dropdown\n            if (this.dropdown.prev()[0] !== mask[0]) {\n                this.dropdown.before(mask);\n            }\n\n            // move the global id to the correct dropdown\n            $(\"#select2-drop\").removeAttr(\"id\");\n            this.dropdown.attr(\"id\", \"select2-drop\");\n\n            // show the elements\n            maskCss=_makeMaskCss();\n\n            mask.css(maskCss).show();\n\n            this.dropdown.show();\n            this.positionDropdown();\n\n            this.dropdown.addClass(\"select2-drop-active\");\n\n            // attach listeners to events that can change the position of the container and thus require\n            // the position of the dropdown to be updated as well so it does not come unglued from the container\n            var that = this;\n            this.container.parents().add(window).each(function () {\n                $(this).on(resize+\" \"+scroll+\" \"+orient, function (e) {\n                    var maskCss=_makeMaskCss();\n                    $(\"#select2-drop-mask\").css(maskCss);\n                    that.positionDropdown();\n                });\n            });\n\n            function _makeMaskCss() {\n                return {\n                    width  : Math.max(document.documentElement.scrollWidth,  $(window).width()),\n                    height : Math.max(document.documentElement.scrollHeight, $(window).height())\n                }\n            }\n        }"
]